---
layout: post
title:  "v8 Exploitation: *CTF 2019 oob-v8"
date:   2019-12-12 23:59:00 +0800
categories: pwn
tags: *CTF-2019
---

# Introduction

I've recently been researching browsers, specifically JavaScript Engine exploitation in Chrome's v8. Being a CTF player myself, I thought doing a fairly recent CTF challenge might help me wrap my head around some of the exploitation techniques that are widely used provided a vulnerability ***does*** exist.

I picked the challenge `oob-v8` from `*CTF 2019`, because it seems as though all the writeups for it are fairly incomplete. They either assume a bunch of prerequisite knowledge, or just don't explain things well. I spent a lot of time debugging and understanding every part of my exploit, and popped calc in two separate ways.

The other reason I wanted to create this writeup is because most of the prerequisite knowledge required is scattered around a bunch of different places. I wanted to bring together all of that information in a single post, so that the reader will not need to read from multiple sources to understand the writeup.

Without further ado, let's get started.

## Building d8

`d8` is the name given to the JavaScript REPL created by Google for v8. I will build both the release and debug versions of it.

For reference, I am doing all of this on an Ubuntu 18.04.3 LTS vm.

You will first have to install Google's `depot_tools` and add the folder to your PATH by following the guide [here](https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up):
```sh
pwn@ubuntu:~/tools$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
pwn@ubuntu:~/tools$ echo "export PATH=/home/pwn/tools/depot_tools:$PATH" >> ~/.bashrc
```

Next, download the challenge archive from [here](https://github.com/Changochen/CTF/raw/master/2019/*ctf/Chrome.tar.gz). You will only need the `oob.diff` file from inside it. Run the following commands to download and build the correct version of d8:
```sh
pwn@ubuntu:~$ fetch v8
pwn@ubuntu:~$ cd v8
pwn@ubuntu:~/v8$ ./build/install-build-deps.sh # Assumes you're using apt
pwn@ubuntu:~/v8$ git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598
pwn@ubuntu:~/v8$ gclient sync
pwn@ubuntu:~/v8$ git apply ../oob.diff
pwn@ubuntu:~/v8$ ./tools/dev/v8gen.py x64.release
pwn@ubuntu:~/v8$ ninja -C ./out.gn/x64.release # Release version
pwn@ubuntu:~/v8$ ninja -C ./out.gn/x64.debug # Debug version
```

The builds will take a while, but afterwards, you will find the release build in `v8/out.gn/x64.release/d8`, and the debug build in `v8/out.gn/x64.debug/d8`.

## The patch

First, let's take a brief look at the patch file. You don't have to understand every single line of code (the v8 code base is huge after all), but you should be able to find the vulnerability fairly quickly:
```diff
diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc
index b027d36..ef1002f 100644
--- a/src/bootstrapper.cc
+++ b/src/bootstrapper.cc
@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                           Builtins::kArrayPrototypeCopyWithin, 2, false);
     SimpleInstallFunction(isolate_, proto, "fill",
                           Builtins::kArrayPrototypeFill, 1, false);
+    SimpleInstallFunction(isolate_, proto, "oob",
+                          Builtins::kArrayOob,2,false);
     SimpleInstallFunction(isolate_, proto, "find",
                           Builtins::kArrayPrototypeFind, 1, false);
     SimpleInstallFunction(isolate_, proto, "findIndex",
diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc
index 8df340e..9b828ab 100644
--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,
   return *final_length;
 }
 }  // namespace
+BUILTIN(ArrayOob){
+    uint32_t len = args.length();
+    if(len > 2) return ReadOnlyRoots(isolate).undefined_value();
+    Handle<JSReceiver> receiver;
+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+            isolate, receiver, Object::ToObject(isolate, args.receiver()));
+    Handle<JSArray> array = Handle<JSArray>::cast(receiver);
+    FixedDoubleArray elements = FixedDoubleArray::cast(array->elements());
+    uint32_t length = static_cast<uint32_t>(array->length()->Number());
+    if(len == 1){
+        //read
+        return *(isolate->factory()->NewNumber(elements.get_scalar(length)));
+    }else{
+        //write
+        Handle<Object> value;
+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+                isolate, value, Object::ToNumber(isolate, args.at<Object>(1)));
+        elements.set(length,value->Number());
+        return ReadOnlyRoots(isolate).undefined_value();
+    }
+}
 
 BUILTIN(ArrayPush) {
   HandleScope scope(isolate);
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 0447230..f113a81 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -368,6 +368,7 @@ namespace internal {
   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \
   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \
   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \
+  CPP(ArrayOob)                                                                \
                                                                                \
   /* ArrayBuffer */                                                            \
   /* ES #sec-arraybuffer-constructor */                                        \
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index ed1e4a5..c199e3a 100644
--- a/src/compiler/typer.cc
+++ b/src/compiler/typer.cc
@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {
       return Type::Receiver();
     case Builtins::kArrayUnshift:
       return t->cache_->kPositiveSafeInteger;
+    case Builtins::kArrayOob:
+      return Type::Receiver();
 
     // ArrayBuffer functions.
     case Builtins::kArrayBufferIsView:
```

Let's break it down a little bit:

* The two lines of code added in `src/bootstrapper.cc` essentially installs a builtin function for arrays called `oob`.
* The lines of code added in `src/builtins/builtins-definitions.h` and `src/compiler.typer.cc` are not important. They are required to add this builtin function correctly.
* The lines of code added into `src/builtins/builtins-array.cc` are important. The vulnerability lies here. 

I urge the reader to take a look at the code added to `src/builtins/builtins-array.cc` and try to spot the vulnerability. Even without any further context, it should be easy to spot.

* The function will initially check if the number of arguments is greater than 2 (the first argument is always the `this` argument). If it is, it returns undefined.
* If there is only one argument (`this`), it will cast the array into a `FixedDoubleArray` before returning the element at `array[length]`.
* If there are two arguments (`this` and `value`), it will write `value` as a float into `array[length]`.

Now, since arrays start with index 0, it is evident that `array[length]` results in an out-of-bounds access by one index at the end of the array. 

The question now is, how do we exploit it? In order to figure out what we can do with this vulnerability, we first have to find out what exists past an array's last index.

## What exists past the end of an array?

There are two ways you can figure this out. The much harder way is to go to [https://source.chromium.org](https://source.chromium.org) and try to find the layout of an array by reading the source code. However, that requires you to already have a deep understanding of the v8 code base, as you have to know exactly where to look. Not to mention, there are a lot of different parts of the code you have to understand to even begin to comprehend the layout of a specific object once its allocated.

Instead, let us use the fact that we can build a debug version of `d8` and run it through a debugger to view the memory layout of an array in real time. Note that you have to run `d8` with `./d8 --allow-natives-syntax` to get access to some of the debugging functions, such as `%DebugPrint()`.
```
pwn@ubuntu:~/v8/v8/out.gn/x64.debug$ gdb ./d8
GEF for linux ready, type `gef' to start, `gef config' to configure
77 commands loaded for GDB 8.1.0.20180409-git using Python engine 3.6
[*] 3 commands could not be loaded, run `gef missing` to know why.
Reading symbols from ./d8...done.

gefâž¤  run --allow-natives-syntax
Starting program: /home/pwn/v8/v8/out.gn/x64.debug/d8 --allow-natives-syntax
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff30ec700 (LWP 12183)]
V8 version 7.5.0 (candidate)

d8> var a = [1.1, 2.2];
undefined
d8> %DebugPrint(a);
DebugPrint: 0x21b925ecdd79: [JSArray]
 - map: 0x2233ad9c2ed9 <Map(PACKED_DOUBLE_ELEMENTS)> [FastProperties]
 - prototype: 0x399504751111 <JSArray[0]>
 - elements: 0x21b925ecdd59 <FixedDoubleArray[2]> [PACKED_DOUBLE_ELEMENTS]
 - length: 2
 - properties: 0x121e0ddc0c71 <FixedArray[0]> {
    #length: 0x0d8cbd8001a9 <AccessorInfo> (const accessor descriptor)
 }
 - elements: 0x21b925ecdd59 <FixedDoubleArray[2]> {
           0: 1.1
           1: 2.2
 }
0x2233ad9c2ed9: [Map]
 - type: JS_ARRAY_TYPE
 - instance size: 32
 - inobject properties: 0
 - elements kind: PACKED_DOUBLE_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - back pointer: 0x2233ad9c2e89 <Map(HOLEY_SMI_ELEMENTS)>
 - prototype_validity cell: 0x0d8cbd800609 <Cell value= 1>
 - instance descriptors #1: 0x399504751f49 <DescriptorArray[1]>
 - layout descriptor: (nil)
 - transitions #1: 0x399504751eb9 <TransitionArray[4]>Transition array #1:
     0x121e0ddc4ba1 <Symbol: (elements_transition_symbol)>: (transition to HOLEY_DOUBLE_ELEMENTS) -> 0x2233ad9c2f29 <Map(HOLEY_DOUBLE_ELEMENTS)>

 - prototype: 0x399504751111 <JSArray[0]>
 - constructor: 0x399504750ec1 <JSFunction Array (sfi = 0xd8cbd80aca1)>
 - dependent code: 0x121e0ddc02c1 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
 - construction counter: 0

[1.1, 2.2]
```

That is a lot of information. Before we dive in any further, I should explain that v8 uses a pointer tagging mechanism to distinguish between **pointers**, **doubles**, and **Smis**, which stands for `immediate small integer`. This information can be found in `src/objects.h`. Essentially, we have the following scenario:
```c
Double: Shown as the 64-bit binary representation without any changes
Smi: Represented as value << 32, i.e 0xdeadbeef is represented as 0xdeadbeef00000000
Pointers: Represented as addr & 1. 0x2233ad9c2ed8 is represented as 0x2233ad9c2ed9
```

There is a little more to this, especially when TypedArrays are involved, but I will cover that later when it is relevant.

The important thing to note here is that any memory addresses you see from the `%DebugPrint(a)` output above will have their very last bit set. You need to subtract 1 from all memory addresses before trying to examine them in `gdb` in order to view the correct address in memory.

With that aside, let us view the array in memory:
```
gefâž¤  x/4gx 0x21b925ecdd79-1
0x21b925ecdd78:	0x00002233ad9c2ed9	0x0000121e0ddc0c71
0x21b925ecdd88:	0x000021b925ecdd59	0x0000000200000000
```

Now, corroborating with the debug information given to us, we know that the first address corresponds to this array's Map. The second address corresponds  
