---
layout: post
title:  "Vulnerability Analysis 101 - CVE-2020-16040"
date:   2020-12-08 17:30:00 +0800
---

# Introduction

I recently analyzed a really cool N-day vulnerability in V8 and wanted to blog about it, but I didn’t want it to just be your generic CVE analysis blog post. I wanted to add something extra, so I decided to also talk a little bit about the method that I generally use to analyze complex bugs like this one.

I’ll start out by covering this method. I will then go through how exactly I applied the method to analyze the bug in question. Let's get started.

# Disclaimer

This is the method that I use, and I accept that it won’t necessarily work for everyone. The reason it works so well for me is because it forces me to do the following:

1. Read a lot of code to really understand not just what’s going on, but the internals of how the code is doing what it’s doing. This is really important to get a good feel for the code base, as it helps a ton when auditing the code base for bugs.
   
2. Experiment a lot with a debugger (which is GDB, in my case). This really teaches you things like how to inspect certain objects in memory (in the case of TurboFan, the most important object would be a Node object), where to set breakpoints to get execution to certain functions in the fastest way possible, and lots of other niche things, all of which really help when auditing for bugs.

If my method doesn’t work for you, then you should try to find a method that helps you achieve the same things (i.e lots of reading the code, lots of playing around in a debugger, etc). At the end of the day, it’s really all just a mindset. As long as it gets you reading the code and breaking down the bug in ways that help you understand it, you’ll be fine.

# CVE-2020-16040

On the 24th of November, a [very interesting V8 commit](https://chromium-review.googlesource.com/c/v8/v8/+/2557498) was made visible as part of [Chromium Issue 1150649](https://crbug.com/1150649) (which still hasn’t been disclosed). The commit seemed to patch a bug in the Simplified Lowering phase of V8’s optimizing JIT compiler, TurboFan. The latest V8 version that this bug affects is version **8.9.40**. I will be using this as the unpatched version for analysis, and I will be comparing things like Turbolizer output against version **8.9.41**, where the bug is fixed. 

The patch also included a nice regression test that showcased how to trigger the bug. It did not however grant any immediate exploitable primitives, so some work would need to be done to figure out whether the bug is exploitable at all (and how to exploit it).

Prior to analyzing this bug, I hadn’t really ever looked at the Simplified Lowering phase in detail, so I took this as the perfect opportunity to learn about it. There was also the added benefit of having to look at all the optimization phases that come *after* the Simplified Lowering phase in order to figure out whether this bug was exploitable or not. This would mean there would be tons of new things for me to learn, and that’s really all I aim for at the end of the day.

# Taking notes

One of the most important things to have when analyzing any bug is a nice, reliable way to take notes. I prefer Markdown syntax, so I usually just create a new Github repository for every bug that I analyze. You might prefer something like Google Docs, or OneNote, or etc, just pick whatever works for you.

**Do not skip this step**. Taking notes is going to be key to deeply understanding some of the most complex bugs, as it is next to impossible to remember everything about a bug when it takes days or weeks to analyze it. There’s just too much information to keep track of (trust me, I’ve tried :P), and your future self will be proud of you for keeping the notes when they end up having to look back at them to try to remember how something worked in detail.

# Background

Before actually starting to analyze the bug, it is helpful to have some background knowledge about the software that the bug applies to. In this case, having some knowledge of how TurboFan works would help. 

[Jeremy Fetiveau (@__x86)](https://twitter.com/__x86) recently [wrote a blog post that I would recommend to read](https://doar-e.github.io/blog/2020/11/17/modern-attacks-on-the-chrome-browser-optimizations-and-deoptimizations/). It has a section that talks about how the Simplified Lowering phase works in TurboFan. There are also a few other blog posts on that same blog (as well as online elsewhere) that cover topics like TurboFan’s typer, and etc.

Although I’ll try to explain everything that’s required to understand this specific bug, feel free to refer to other resources to understand what I’m trying to say. Information about complex topics is often really difficult to relay in a manner that’s comprehensible by everyone.

# First steps - coming up with some questions

The first thing that I always do is take all the information that I initially have about the bug that I’m analyzing, and come up with some exploratory questions that I’ll hopefully be able to answer after I’m done with my analysis. The one and only important thing to note here is that the questions should never be left half answered. No matter how tedious it is, I always fully answer every question and ensure that there are no gaps in my knowledge when I do so.

How does this apply to this bug? Well, for starters, we have the patch, a commit message, and regression test. The regression test especially is very useful. If I didn’t have the regression test handy, then the first thing I’d do is try to figure out how to trigger the bug (which is easier said than done with something as complex as V8 / TurboFan). Since we have the regression test in this case though, I’ll just leave the whole “how to come up with a proof of concept” for another blog post.

Looking at the commit message, we see that it states the following:

```
[compiler] Fix a bug in SimplifiedLowering

SL's VisitSpeculativeIntegerAdditiveOp was setting Signed32 as restriction type even when 
relying on a Word32 truncation in order to skip the overflow check. This is not sound.
```

By itself, without any prior knowledge about the Simplified Lowering phase, this might be difficult to understand. The patch though has a nice comment that provides a bit more information:

```diff
+    // Using Signed32 as restriction type amounts to promising there won't be
+    // signed overflow. This is incompatible with relying on a Word32
+    // truncation in order to skip the overflow check.
+    Type const restriction =
+        truncation.IsUsedAsWord32() ? Type::Any() : Type::Signed32();
```

Right here, we have a few different terms such as “restriction type”, “Word32 truncation”, etc, that we have to learn about, but it should be pretty logical to conclude that the effect of the bug is this: the engine makes a promise and says that a signed integer overflow will not take place, but the actual outcome is that a signed integer overflow *does* take place.

Knowing this, let’s have a look at the regression test now. I added my own `assertTrue` and `assertFalse` functions to it so that I could actually run it (I believe ClusterFuzz does this automatically). Here is the modified one:

```js
// Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function assertTrue(c) {
    if (!c) { throw "Assertion failed"; }
}

function assertFalse(c) {
    assertTrue(!c);
}

function foo(a) {
  var y = 0x7fffffff;  // 2^31 - 1

  // Widen the static type of y (this condition never holds).
  if (a == NaN) y = NaN;

  // The next condition holds only in the warmup run. It leads to Smi
  // (SignedSmall) feedback being collected for the addition below.
  if (a) y = -1;

  const z = (y + 1)|0;
  return z < 0;
}

%PrepareFunctionForOptimization(foo);
assertFalse(foo(true));
%OptimizeFunctionOnNextCall(foo);
assertTrue(foo(false));
```

Looking at the code itself, we can quickly determine the following:

1. A variable `y` is set to `0x7fffffff`, which is `INT_MAX`.
2. Some TurboFan specific stuff is done which allows the bug to be triggered (we’ll get into all of this later).
3. A variable `z` is set to `(y + 1)|0`.
4. The return statement is supposed to return `false` for the first call to `foo` (The argument `a` will be `true`, so `y` will be set to `-1`, which will cause `z` to be set to `y+1 == -1+1 == 0`), which it does correctly.
5. For the second call to `foo`, `a` will be `false`, so `z` will be set to `y+1 == 0x7fffffff+1 == 0x80000000`. Based on the regression test, it seems this addition should yield the negative number `-2147483648`, which should cause the function to return `true` as this negative number is less than 0.
6. However, if you run this regression test, you’ll see that the final `assertTrue` will fail. We can conclude that the bug supposedly causes the engine to incorrectly assume that an integer overflow hasn’t occurred, when in fact it has (we haven’t verified yet that it has, but we will later).

Based on this information, I came up with the following questions that I will need to have answered after I’ve finished analyzing the bug:

* The “static type” of `y` is widened initially. The question is, how does this work? What is the “static type”, and why does it need to be widened here?
   
* In the warmup run (i.e the initial call to `foo`), `SignedSmall` feedback is collected by setting `y` to `-1`. Again, why is this required here? How does this specific line of code collect `SignedSmall` feedback?

* Why is `z` set to `(y + 1)|0`? More specifically, why is it bitwise OR’d with `0`?

These are the three questions I started with. Questions like these help give me a purpose, a goal to work towards. The initial goal of “analyse and understand this bug” is too broad for me, and in turn makes it very hard for me to focus. Specific questions like these make it much easier as I know exactly what I’m looking for, which is why this method works so well for me.

# Unpatched vs Patched Turbolizer graphs

Before I started with answering the questions though, I wanted to quickly compare the Turbolizer graphs between the unpatched and patched versions of V8 to see exactly what effect the patch had on the engine. I won’t go into detail about how to use Turbolizer as there are many blog posts and guides out there.

When I looked at the graphs, I noted that the graph looked the exact same during the Escape Analysis phase (which runs right before the Simplified Lowering phase). This is as follows:

Escape Analysis Phase:

![](../images/cve-2020-16040/1.png)

A difference in the graph only shows in the Simplified Lowering phase. Here are the Simplified Lowering phases of both versions:

Unpatched Simplified Lowering Phase:

![](../images/cve-2020-16040/2.png)

Patched Simplified Lowering Phase:

![](../images/cve-2020-16040/3.png)

It's immediately evident that the `NumberLessThan` node from the Escape Analysis Phase has been changed to a `Uint32LessThan` node in the unpatched version. This node is used for the final `return z < 0` comparison. Presumably, the `Uint32LessThan` node means that TurboFan has failed to notice the integer overflow that occurs during the addition, as it attempts to compare the two numbers as unsigned 32-bit integers.

In contrast, the patched version will correctly compare the two numbers as signed 32-bit integers using the `Int32LessThan` node. We can immediately add another question to our list of questions to be answered:

* How exactly is the `Uint32LessThanNode` inserted into the graph? And how does the patch itself cause an `Int32LessThan` node to be inserted instead?